Directory structure:
└── kndndrj-nvim-dbee/
    ├── README.md
    ├── ARCHITECTURE.md
    ├── LICENSE
    ├── .luacheckrc
    ├── .luarc.json
    ├── .stylua.toml
    ├── ci/
    │   ├── build.sh
    │   ├── publish.sh
    │   ├── target-matrix.sh
    │   └── targets.json
    ├── dbee/
    │   ├── endpoints.go
    │   ├── go.mod
    │   ├── go.sum
    │   ├── main.go
    │   ├── adapters/
    │   │   ├── adapters.go
    │   │   ├── bigquery.go
    │   │   ├── bigquery_driver.go
    │   │   ├── bigquery_driver_test.go
    │   │   ├── clickhouse.go
    │   │   ├── clickhouse_driver.go
    │   │   ├── databricks.go
    │   │   ├── databricks_driver.go
    │   │   ├── databricks_driver_test.go
    │   │   ├── databricks_test.go
    │   │   ├── duck.go
    │   │   ├── duck_driver.go
    │   │   ├── duck_driver_test.go
    │   │   ├── mongo.go
    │   │   ├── mongo_driver.go
    │   │   ├── mysql.go
    │   │   ├── mysql_driver.go
    │   │   ├── oracle.go
    │   │   ├── oracle_driver.go
    │   │   ├── postgres.go
    │   │   ├── postgres_driver.go
    │   │   ├── redis.go
    │   │   ├── redis_driver.go
    │   │   ├── redis_test.go
    │   │   ├── redshift.go
    │   │   ├── redshift_driver.go
    │   │   ├── sqlite.go
    │   │   ├── sqlite_driver.go
    │   │   ├── sqlserver.go
    │   │   └── sqlserver_driver.go
    │   ├── core/
    │   │   ├── call.go
    │   │   ├── call_archive.go
    │   │   ├── call_state.go
    │   │   ├── call_test.go
    │   │   ├── connection.go
    │   │   ├── connection_params.go
    │   │   ├── expand.go
    │   │   ├── expand_test.go
    │   │   ├── result.go
    │   │   ├── result_test.go
    │   │   ├── types.go
    │   │   ├── builders/
    │   │   │   ├── client.go
    │   │   │   ├── client_options.go
    │   │   │   ├── columns.go
    │   │   │   ├── next.go
    │   │   │   ├── next_test.go
    │   │   │   └── result.go
    │   │   ├── format/
    │   │   │   ├── csv.go
    │   │   │   └── json.go
    │   │   └── mock/
    │   │       ├── adapter.go
    │   │       ├── adapter_options.go
    │   │       ├── result.go
    │   │       └── result_options.go
    │   ├── handler/
    │   │   ├── call_log.go
    │   │   ├── event_bus.go
    │   │   ├── format_table.go
    │   │   ├── handler.go
    │   │   ├── marshal.go
    │   │   ├── output_buffer.go
    │   │   └── output_yank.go
    │   ├── plugin/
    │   │   ├── logger.go
    │   │   ├── manifest.go
    │   │   └── plugin.go
    │   └── tests/
    │       ├── README.md
    │       ├── integration/
    │       │   ├── bigquery_integration_test.go
    │       │   ├── clickhouse_integration_test.go
    │       │   ├── docs.go
    │       │   ├── duckdb_integration_test.go
    │       │   ├── mysql_integration_test.go
    │       │   ├── oracle_integration_test.go
    │       │   ├── postgres_integration_test.go
    │       │   ├── redshift_integration_test.go
    │       │   ├── sqlite_integration_test.go
    │       │   └── sqlserver_integration_test.go
    │       ├── testdata/
    │       │   ├── bigquery_seed.yaml
    │       │   ├── clickhouse_seed.sql
    │       │   ├── duckdb_seed.sql
    │       │   ├── mysql_seed.sql
    │       │   ├── oracle_seed.sql
    │       │   ├── postgres_seed.sql
    │       │   ├── sqlite_seed.sql
    │       │   └── sqlserver_seed.sql
    │       └── testhelpers/
    │           ├── bigquery.go
    │           ├── clickhouse.go
    │           ├── duckdb.go
    │           ├── helper.go
    │           ├── mysql.go
    │           ├── oracle.go
    │           ├── postgres.go
    │           ├── sqlite.go
    │           └── sqlserver.go
    ├── doc/
    │   ├── dbee-reference.txt
    │   └── dbee.txt
    ├── lua/
    │   ├── dbee.lua
    │   └── dbee/
    │       ├── config.lua
    │       ├── doc.lua
    │       ├── health.lua
    │       ├── sources.lua
    │       ├── utils.lua
    │       ├── api/
    │       │   ├── __register.lua
    │       │   ├── core.lua
    │       │   ├── init.lua
    │       │   ├── state.lua
    │       │   └── ui.lua
    │       ├── handler/
    │       │   ├── __events.lua
    │       │   └── init.lua
    │       ├── install/
    │       │   ├── __manifest.lua
    │       │   └── init.lua
    │       ├── layouts/
    │       │   ├── init.lua
    │       │   └── tools.lua
    │       └── ui/
    │           ├── call_log.lua
    │           ├── common/
    │           │   ├── floats.lua
    │           │   └── init.lua
    │           ├── drawer/
    │           │   ├── convert.lua
    │           │   ├── expansion.lua
    │           │   ├── init.lua
    │           │   └── menu.lua
    │           ├── editor/
    │           │   ├── init.lua
    │           │   └── welcome.lua
    │           └── result/
    │               ├── init.lua
    │               └── progress.lua
    ├── plugin/
    │   └── dbee.lua
    └── .github/
        └── workflows/
            ├── compile.yml
            ├── docgen.yml
            ├── lint.yml
            └── test.yml

================================================
FILE: README.md
================================================
<!-- DOCGEN_IGNORE_START -->

<!-- This tag controlls what's ignored by the docgen workflow. -->

![Linting Status](https://img.shields.io/github/actions/workflow/status/kndndrj/nvim-dbee/lint.yml?label=linting&style=for-the-badge)
![Docgen Status](https://img.shields.io/github/actions/workflow/status/kndndrj/nvim-dbee/docgen.yml?label=docgen&logo=neovim&logoColor=white&style=for-the-badge)
![Backend](https://img.shields.io/badge/go-backend-lightblue?style=for-the-badge&logo=go&logoColor=white)
![Frontend](https://img.shields.io/badge/lua-frontend-blue?style=for-the-badge&logo=lua&logoColor=white)

[!["Buy Me A Coffee"](https://www.buymeacoffee.com/assets/img/custom_images/yellow_img.png)](https://www.buymeacoffee.com/kndndrj)

<!-- DOCGEN_IGNORE_END -->

# Neovim DBee

**Database Client for NeoVim!**

**Execute Your Favourite Queries From the Comfort of Your Editor!**

**Backend in Go!**

**Frontend in Lua!**

**Doesn't rely on CLI tools!**

**Get Results FAST With Under-the-hood Iterator!**

**Bees Love It!**

***Alpha Software - Expect Breaking Changes!***

<!-- DOCGEN_IGNORE_START -->

![Screenshot](assets/screenshot.jpg)

<!-- DOCGEN_IGNORE_END -->

<!-- DOCGEN_IGNORE_START -->

### Video Introduction

If you prefer to watch a video than to browse through docs, I made a video, which you can watch
[here](https://youtu.be/MDlYsGbKJyQ)

<!-- DOCGEN_IGNORE_END -->

## Installation

**requires nvim>=0.10**

- packer.nvim:

  ```lua
  use {
    "kndndrj/nvim-dbee",
    requires = {
      "MunifTanjim/nui.nvim",
    },
    run = function()
      -- Install tries to automatically detect the install method.
      -- if it fails, try calling it with one of these parameters:
      --    "curl", "wget", "bitsadmin", "go"
      require("dbee").install()
    end,
    config = function()
      require("dbee").setup(--[[optional config]])
    end
  }
  ```

- lazy.nvim:

  ```lua
  {
    "kndndrj/nvim-dbee",
    dependencies = {
      "MunifTanjim/nui.nvim",
    },
    build = function()
      -- Install tries to automatically detect the install method.
      -- if it fails, try calling it with one of these parameters:
      --    "curl", "wget", "bitsadmin", "go"
      require("dbee").install()
    end,
    config = function()
      require("dbee").setup(--[[optional config]])
    end,
  },
  ```

### Platform Support

<!-- DOCGEN_IGNORE_START -->

<details>
  <summary>Click to expand</summary>
<!-- DOCGEN_IGNORE_END -->

This project aims to be as cross-platform as possible, but there are some limitations (for example
some of the go dependencies only work on certain platforms). To address this issue, the client
implementations are detached from the main logic and they register themselves to dbee backend on
plugin start. This allows the use of build constraints, which we use to exclued certain client
implementations on certain platforms.

The CI pipeline tries building the binary for GOARCH/GOOS combinations specified in
[targets.json](ci/targets.json) - if the builds succeed, they are stored in a
[remote bucket](https://github.com/kndndrj/nvim-dbee-bucket) on a separate branch per run.
Additionally, the [install manifest](lua/dbee/install/__manifest.lua) gets created.

To increase cgo cross-platform support, the pipeline uses zig as a C compiler.

To check if your platform is currently supported, check out the mentioned manifest and the targets
file.

<!-- DOCGEN_IGNORE_START -->

</details>
<!-- DOCGEN_IGNORE_END -->

### Manual Binary Installation

<!-- DOCGEN_IGNORE_START -->

<details>
  <summary>Click to expand</summary>
<!-- DOCGEN_IGNORE_END -->

The installation examples include the `build`/`run` functions, which get triggered once the plugin
updates. This should be sufficient for the majority of users. If that doesn't include you, then you
have a few options:

- just install with the `"go"` option (this performs `go build` under the hood):
  ```lua
  require("dbee").install("go")
  ```
- Download an already compiled binary from one of urls in the
  [install manifest](lua/dbee/install/__manifest.lua)
- `go install` (the install location will vary depending on your local go configuration):
  ```sh
  go install github.com/kndndrj/nvim-dbee/dbee@<version>
  ```
- Clone and build
  ```sh
  # Clone the repository and cd into the "go subfolder"
  git clone <this_repo>
  cd <this_repo>/dbee
  # Build the binary (optional output path)
  go build [-o ~/.local/share/nvim/dbee/bin/dbee]
  ```

<!-- DOCGEN_IGNORE_START -->

</details>
<!-- DOCGEN_IGNORE_END -->

## Configuration

You can pass an optional table parameter to `setup()` function.

Here are the defaults:

<!--DOCGEN_CONFIG_START-->

<!-- Contents from lua/dbee/config.lua are inserted between these tags for docgen. -->

[`config.lua`](lua/dbee/config.lua)

<!--DOCGEN_CONFIG_END-->

## Usage

Call the `setup()` function with an optional config parameter.

<!-- DOCGEN_IGNORE_START -->

<details>
  <summary>Brief reference (click to expand):</summary>
<!-- DOCGEN_IGNORE_END -->

```lua
-- Open/close/toggle the UI.
require("dbee").open()
require("dbee").close()
require("dbee").toggle()
-- Run a query on the currently active connection.
require("dbee").execute(query)
-- Store the current result to file/buffer/yank-register (see "Getting Started").
require("dbee").store(format, output, opts)
```

The same functions are also available through the `:Dbee` user command.

<!-- DOCGEN_IGNORE_START -->

</details>
<!-- DOCGEN_IGNORE_END -->

### Getting Started

Here are a few steps to quickly get started:

- call the `setup()` function in your `init.lua`

- Specify connections using one or more sources (reffer to [this section](#specifying-connections)).

- When you restart the editor, call `lua require("dbee").open()` to open the UI.

- Navigate to the drawer (tree) and use the following key-bindings to perform different actions
  depending on the context (the mappings can all be changed in the config):

  - All nodes:

    - Press `o` to toggle the tree node.
    - Press `r` to manually refresh the tree.

  - Connections:

    - Press `cw` to edit the connection
    - Press `dd` to delete it (if source supports saving, it's also removed from there - see more
      below.)
    - Press `<CR>` to perform an action - view history or look at helper queries. Pressing `<CR>`
      directly on the connection node will set it as the active one

  - Scratchpads:

    - Press `<CR>` on the `new` node to create a new scratchpad.
    - When you try to save it to disk (`:w`), the path is automatically filled for you. You can
      change the name to anything you want, if you save it to the suggested directory, it will load
      the next time you open DBee.
    - Press `cw` to rename the scratchpad.
    - Press `dd` to delete it (also from disk).
    - Pressing `<CR>` on an existing scratchpad in the drawer will open it in the editor pane.

  - Help:

    - Just view the key bindings.

- Once you selected the connection and created a scratchpad, you can navigate to the editor pane
  (top-right by default) and start writing queries. In editor pane, you can use the following
  actions:

  - Highlight some text in visual mode and press `BB` - this will run the selected query on the
    active connection.
  - If you press `BB` in normal mode, you run the whole scratchpad on the active connection.

- If the request was successful, the results should appear in the "result" buffer (bottom right by
  default). If the total number of results was lower than the `page_size` parameter in config (100
  by default), all results should already be present. If there are more than `page_size` results,
  you can "page" through them using one of the following:

| Navigation using lua script <br/> (even if your cursor is outside the result buffer) |       Description       | Default key mapping <br/> (cursor should be inside result buffer) |
| ------------------------------------------------------------------------------------ | :---------------------: | :---------------------------------------------------------------: |
| `require("dbee").api.ui.result_page_next()`                                          |     Go to next page     |                                 L                                 |
| `require("dbee").api.ui.result_page_prev()`                                          | Go to the previous page |                                 H                                 |
| `require("dbee").api.ui.result_page_last()`                                          |   Go to the last page   |                                 E                                 |
| `require("dbee").api.ui.result_page_first()`                                         |  Go to the first page   |                                 F                                 |

- Once in the "result" buffer, you can yank the results with the following keys:

  - `yaj` yank current row as json (or row range in visual mode)
  - `yac` yank current row as CSV (or row range in visual mode)
  - `yaJ` to yank all rows as json
  - `yaC` to yank all rows as CSV

- The current result (of the active connection) can also be saved to a file, yank-register or buffer
  using `require("dbee").store()` lua function or `:Dbee store` Ex command. Here are some examples:

  ```lua
  -- All rows as CSV to current buffer:
  require("dbee").store("csv", "buffer", { extra_arg = 0 })
  -- Results from row 2 to row 7 as json to file (index is zero based):
  require("dbee").store("json", "file", { from = 2, to = 7, extra_arg = "path/to/file.json"  })
  -- Yank the first row as table
  require("dbee").store("table", "yank", { from = 0, to = 1 })
  -- Yank the last 2 rows as CSV
  -- (negative indices are interpreted as length+1+index - same as nvim_buf_get_lines())
  -- Be aware that using negative indices requires for the
  -- iterator of the result to be drained completely, which might affect large result sets.
  require("dbee").store("csv", "yank", { from = -3, to = -1 })
  ```

- Once you are done or you want to go back to where you were, you can call
  `require("dbee").close()`.

### Specifying Connections

Connection represents an instance of the database client (i.e. one database). This is how it looks
like:

```lua
{
  id = "optional_identifier" -- only mandatory if you edit a file by hand. IT'S YOUR JOB TO KEEP THESE UNIQUE!
  name = "My Database",
  type = "sqlite", -- type of database driver
  url = "~/path/to/mydb.db",
}
```

The connections are loaded to dbee using so-called "sources". They can be added to dbee using the
`setup()` function:

```lua
  require("dbee").setup {
    sources = {
      require("dbee.sources").MemorySource:new({
        {
          name = "...",
          type = "...",
          url = "...",
        },
        -- ...
      }),
      require("dbee.sources").EnvSource:new("DBEE_CONNECTIONS"),
      require("dbee.sources").FileSource:new(vim.fn.stdpath("cache") .. "/dbee/persistence.json"),
    },
    -- ...
  },
```

The above sources are just built-ins. Here is a short description of them:

- `MemorySource` just loads the connections you give it as an argument.

- `EnvSource` loads connection from an environment variable Just export the variable you gave to the
  loader and you are good to go:

  ```sh
    export DBEE_CONNECTIONS='[
        {
            "name": "DB from env",
            "url": "username:password@tcp(host)/database-name",
            "type": "mysql"
        }
    ]'
  ```

- `FileSource` loads connections from a given json file. It also supports editing and adding
  connections interactively

If the source supports saving and editing you can add connections manually using the "add" item in
the drawer. Fill in the values and write the buffer (`:w`) to save the connection. By default, this
will save the connection to the global connections file and will persist over restarts (because
default `FileSource` supports saving)

Another option is to use "edit" item in the tree and just edit the source manually.

If you aren't satisfied with the default capabilities, you can implement your own source. You just
need to fill the `Source` interface and pass it to config at setup (`:h dbee.sources`).

#### Secrets

If you don't want to have secrets laying around your disk in plain text, you can use the special
placeholders in connection strings (this works using any method for specifying connections).

Each connection parameter is passed through go templating engine, which has two available functions:

- `env` for retrieving environment variables and
- `exec` for evaluating shell commands.

The template syntax for functions is the following: `{{ <func> "<param>" }}`. If you are dealing
with json, you need to escape double quotes, so it's sometimes better to use backticks instead
(`` {{ <func> `<param>` }} ``).

Example:

Using the `DBEE_CONNECTIONS` environment variable for specifying connections and exporting secrets
to environment:

```sh
# Define connections
export DBEE_CONNECTIONS='[
    {
        "name": "{{ exec `echo Hidden Database` }}",
        "url": "postgres://{{ env \"SECRET_DB_USER\" }}:{{ env `SECRET_DB_PASS` }}@localhost:5432/{{ env `SECRET_DB_NAME` }}?sslmode=disable",
        "type": "postgres"
    }
]'

# Export secrets
export SECRET_DB_NAME="secretdb"
export SECRET_DB_USER="secretuser"
export SECRET_DB_PASS="secretpass"
```

If you start neovim in the same shell, this will evaluate to the following connection:

```lua
{ {
  name = "Hidden Database",
  url = "postgres://secretuser:secretpass@localhost:5432/secretdb?sslmode=disable",
  type = "postgres",
} }
```

## API

Dbee comes with it's own API interface. It is split into two parts:

- core (interacting with core of the plugin),
- ui (interacting with ui of the plugin).

You can access it like this:

```lua
require("dbee").api.core.some_func()
require("dbee").api.ui.some_func()
```

## Extensions

- [`nvim-projector`](https://github.com/kndndrj/nvim-projector) To use dbee with projector, use
  [this extension](https://github.com/kndndrj/projector-dbee).

- [`nvim-cmp`](https://github.com/hrsh7th/nvim-cmp) [Here](https://github.com/MattiasMTS/cmp-dbee),
  a completion plugin with dbee support.

<!-- DOCGEN_IGNORE_START -->

## Development

Reffer to [ARCHITECTURE.md](ARCHITECTURE.md) for a brief overview of the architecture.

## Contributing

Contributions are more than welcome!

Do so by creating an `issue` or a `PR`.

You are also welcome to join the [#nvim-dbee:matrix.org](https://matrix.to/#/#nvim-dbee:matrix.org)
chat for more direct communication.

<!-- DOCGEN_IGNORE_END -->



================================================
FILE: ARCHITECTURE.md
================================================
[Binary file]


================================================
FILE: LICENSE
================================================
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.



================================================
FILE: .luacheckrc
================================================
-- Show error codes in the output
codes = true

-- Disable unused argument warning for "self"
self = false

ignore = {
  "122", -- Indirectly setting a readonly global
  "631", -- line too long
}

-- Per file ignores
files["lua/projector/contract/*"] = { ignore = { "212" } } -- Ignore unused argument warning for interfaces

-- Global objects defined by the C code
read_globals = {
  "vim",
}



================================================
FILE: .luarc.json
================================================
{
    "workspace.checkThirdParty": false
}



================================================
FILE: .stylua.toml
================================================
column_width = 120
line_endings = "Unix"
indent_type = "Spaces"
indent_width = 2
quote_style = "AutoPreferDouble"
call_parentheses = "NoSingleTable"



================================================
FILE: ci/build.sh
================================================
#!/bin/sh

# builds a go binary with the provided args
set -e

# args:
goos=""       # -o   GOOS value
goarch=""     # -a   GOARCH value
crossarch=""  # -c   cgo cross compilation target
buildtags=""  # -b   build arguments
cgo=0         # -e   cgo enabled (true or false)
output=""     # -p   output path

while getopts 'o:a:c:b:p:e:' opt; do
    case "$opt" in
        o)
            goos="$OPTARG" ;;
        a)
            goarch="$OPTARG" ;;
        c)
            crossarch="$OPTARG" ;;
        b)
            buildtags="$OPTARG" ;;
        p)
            output="$OPTARG" ;;
        e)
            [ "$OPTARG" = "true" ] && cgo=1 ;;
        *)
            # ignore invalid args
            echo "invalid flag: $opt" ;;
    esac
done

# check if cross platform is specified
if [ -n "$crossarch" ]; then
    cc="zig cc -target $crossarch"
    cxx="zig c++ -target $crossarch"
fi

# Compile
export CGO_ENABLED="$cgo"
export CC="$cc"
export CXX="$cxx"
export GOOS="$goos"
export GOARCH="$goarch"

go build -tags="$buildtags" -o "$output"



================================================
FILE: ci/publish.sh
================================================
#!/bin/sh

# publishes the compiled binary to the bucket repository
set -e

# args:
files=""          # -a   path to file(s) to add
branch=""         # -b   branch name
publish_user=""   # -u   publisher's username
publish_token=""  # -t   publisher's token
repo=""           # -r   short repo name - e.g. "owner/repo"
message=""        # -m   commit message

while getopts 'a:b:u:t:r:m:' opt; do
    case "$opt" in
        a)
            for f in $OPTARG; do
                files="$files $(realpath "$f")"
            done ;;
        b)
            branch="$OPTARG" ;;
        u)
            publish_user="$OPTARG" ;;
        t)
            publish_token="$OPTARG" ;;
        r)
            repo="$OPTARG" ;;
        m)
            message="$OPTARG" ;;
        *)
            # ignore invalid args
            echo "invalid flag: $opt" ;;
    esac
done

# validate input
for var in "$files" "$branch" "$publish_user" "$publish_token" "$repo"; do
    if [ -z "$var" ]; then
        echo "some of the variables are not provided!"
        exit 1
    fi
done

# prepare temporary directory
tempdir="$(mktemp -d)"
cd "$tempdir" || exit 1

# clone
echo "cloning bucket repository"
git clone https://"$publish_user":"$publish_token"@github.com/"$repo" bucket
cd bucket || exit 1
git config user.name "Github Actions"
git config user.email "actions@github.com"

# new branch
git checkout -b "$branch" 2>/dev/null || git checkout "$branch"

# add files to ./bin/ subdir
echo "applying changes"
mkdir -p bin/
# copy files
for f in $files; do
    cp -r "$f" bin/
done
git add bin/
[ -z "$message" ] && message="added $files"
git commit -m "$message"

# try publishing 10 times
echo "trying to push to bucket repository..."
for i in 1 2 3 4 5 6 7 8 9 10 11; do
    echo "attempt $i/10"
    if (git push -u origin "$branch"); then
        echo "push succeeded after $i attempts"
        break
    fi

    git pull origin "$branch" --rebase || true

    if [ "$i" -eq 11 ]; then
        echo "push failed after 10 attempts"
        exit 1
    fi

    sleep 3
done



================================================
FILE: ci/target-matrix.sh
================================================
#!/bin/sh
# assembles github actions matrix from targets list

default_buildplatform="ubuntu-latest"

# handle primary platforms flag (used in pull_request CI/CD)
if [ "$1" = "--primary" ]; then
    primary_filter='[.[] | select(.primary == true)]'
else
    primary_filter='.'
fi
# strip comments
targets="$(sed '/^\s*\/\//d;s/\/\/.*//' "$(dirname "$0")/targets.json")"

# filter for primary platforms if requested
targets="$(echo "$targets" | jq "$primary_filter")"

# assign a default buildplatform
targets="$(echo "$targets" | jq 'map(
    . + if has("buildplatform") then
    {buildplatform}
    else
      {buildplatform: "'"$default_buildplatform"'"}
    end
)')"

# echo the matrix (remove newlines)
echo 'matrix={"include":'"$targets"'}' | tr -d '\n'



================================================
FILE: ci/targets.json
================================================
// This file lists all available platforms for go compilation
// keys other than "goos" and "goarch" are all optional
// supported keys:
//     "goos" - value of GOOS
//     "goarch" - value of GOARCH
//     "buildplatform" - platform to use for github actions image
//     "crossarch" - architecture for the c compiler (zig)
//     "buildtags" - extra tags to pass to go build - comma separated list
//     "cgo" - is cgo enabled or not
//
[
  //
  // 1st class support. We strive to provide best support for these platforms.
  //
  {
    "goos": "darwin",
    "goarch": "amd64",
    "buildplatform": "macos-13",
    "cgo": true,
    "primary": true
  },
  {
    "goos": "darwin",
    "goarch": "arm64",
    "buildplatform": "macos-13",
    "cgo": true,
    "primary": true
  },
  {
    "goos": "linux",
    "goarch": "amd64",
    "crossarch": "x86_64-linux",
    "buildtags": "duckdb_from_source",
    "primary": true
  },
  {
    "goos": "linux",
    "goarch": "arm64",
    "crossarch": "aarch64-linux",
    "primary": true
  },
  {
    "goos": "windows",
    "goarch": "amd64",
    "buildplatform": "windows-latest",
    "cgo": true,
    "primary": true
  },
  {
    "goos": "windows",
    "goarch": "arm64",
    "crossarch": "aarch64-windows",
    "buildplatform": "windows-latest",
    "cgo": true,
    "primary": true
  },
  {
    "goos": "android",
    "goarch": "arm64"
  },
  {
    "goos": "dragonfly",
    "goarch": "amd64"
  },
  {
    "goos": "freebsd",
    "goarch": "386"
  },
  {
    "goos": "freebsd",
    "goarch": "amd64"
  },
  {
    "goos": "freebsd",
    "goarch": "arm"
  },
  {
    "goos": "freebsd",
    "goarch": "arm64"
  },
  {
    "goos": "freebsd",
    "goarch": "riscv64"
  },
  {
    "goos": "illumos",
    "goarch": "amd64"
  },
  {
    "goos": "linux",
    "goarch": "386"
  },
  {
    "goos": "linux",
    "goarch": "arm"
  },
  {
    "goos": "linux",
    "goarch": "loong64"
  },
  {
    "goos": "linux",
    "goarch": "mips64"
  },
  {
    "goos": "linux",
    "goarch": "mips64le"
  },
  {
    "goos": "linux",
    "goarch": "ppc64"
  },
  {
    "goos": "linux",
    "goarch": "ppc64le"
  },
  {
    "goos": "linux",
    "goarch": "riscv64",
    "crossarch": "riscv64-linux"
  },
  {
    "goos": "linux",
    "goarch": "s390x"
  },
  {
    "goos": "netbsd",
    "goarch": "386"
  },
  {
    "goos": "netbsd",
    "goarch": "amd64"
  },
  {
    "goos": "netbsd",
    "goarch": "arm"
  },
  {
    "goos": "netbsd",
    "goarch": "arm64"
  },
  {
    "goos": "openbsd",
    "goarch": "386"
  },
  {
    "goos": "openbsd",
    "goarch": "amd64"
  },
  {
    "goos": "openbsd",
    "goarch": "arm"
  },
  {
    "goos": "openbsd",
    "goarch": "arm64"
  },
  {
    "goos": "solaris",
    "goarch": "amd64"
  },
  {
    "goos": "windows",
    "goarch": "386",
    "crossarch": "x86-windows",
    "buildplatform": "windows-latest"
  },
  {
    "goos": "windows",
    "goarch": "arm",
    "crossarch": "arm-windows",
    "buildplatform": "windows-latest"
  }
  //
  // Unsupported targets.
  //
  // {
  //     "goos": "openbsd",
  //     "goarch": "mips64"
  // },
  // {
  //     "goos": "aix",
  //     "goarch": "ppc64"
  // },
  // {
  //     "goos": "android",
  //     "goarch": "386"
  // },
  // {
  //     "goos": "android",
  //     "goarch": "arm"
  // },
  // {
  //     "goos": "ios",
  //     "goarch": "amd64"
  // },
  // {
  //     "goos": "ios",
  //     "goarch": "arm64"
  // },
  // {
  //     "goos": "js",
  //     "goarch": "wasm"
  // },
  // {
  //     "goos": "linux",
  //     "goarch": "mips"
  // },
  // {
  //     "goos": "linux",
  //     "goarch": "mipsle"
  // },
  // {
  //     "goos": "plan9",
  //     "goarch": "386"
  // },
  // {
  //     "goos": "plan9",
  //     "goarch": "amd64"
  // },
  // {
  //     "goos": "plan9",
  //     "goarch": "arm"
  // }
]
// vim:ft=jsonc



================================================
FILE: dbee/endpoints.go
================================================
package main

import (
	"github.com/neovim/go-client/nvim"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/handler"
	"github.com/kndndrj/nvim-dbee/dbee/plugin"
)

func mountEndpoints(p *plugin.Plugin, h *handler.Handler) {
	p.RegisterEndpoint(
		"DbeeCreateConnection",
		func(args *struct {
			Opts *struct {
				ID   string `msgpack:"id"`
				URL  string `msgpack:"url"`
				Type string `msgpack:"type"`
				Name string `msgpack:"name"`
			} `msgpack:",array"`
		},
		) (core.ConnectionID, error) {
			return h.CreateConnection(&core.ConnectionParams{
				ID:   core.ConnectionID(args.Opts.ID),
				Name: args.Opts.Name,
				Type: args.Opts.Type,
				URL:  args.Opts.URL,
			})
		})

	p.RegisterEndpoint(
		"DbeeDeleteConnection",
		func(args *struct {
			ID string `msgpack:",array"`
		},
		) error {
			return h.DeleteConnection(core.ConnectionID(args.ID))
		})

	p.RegisterEndpoint(
		"DbeeGetConnections",
		func(args *struct {
			IDs []core.ConnectionID `msgpack:",array"`
		},
		) (any, error) {
			return handler.WrapConnections(h.GetConnections(args.IDs)), nil
		})

	p.RegisterEndpoint(
		"DbeeAddHelpers",
		func(args *struct {
			Type    string `msgpack:",array"`
			Helpers map[string]string
		},
		) error {
			return h.AddHelpers(args.Type, args.Helpers)
		})

	p.RegisterEndpoint(
		"DbeeConnectionGetHelpers",
		func(args *struct {
			ID   string `msgpack:",array"`
			Opts *struct {
				Table           string `msgpack:"table"`
				Schema          string `msgpack:"schema"`
				Materialization string `msgpack:"materialization"`
			}
		},
		) (any, error) {
			return h.ConnectionGetHelpers(core.ConnectionID(args.ID), &core.TableOptions{
				Table:           args.Opts.Table,
				Schema:          args.Opts.Schema,
				Materialization: core.StructureTypeFromString(args.Opts.Materialization),
			})
		})

	p.RegisterEndpoint(
		"DbeeSetCurrentConnection",
		func(args *struct {
			ID core.ConnectionID `msgpack:",array"`
		},
		) error {
			return h.SetCurrentConnection(args.ID)
		})

	p.RegisterEndpoint(
		"DbeeGetCurrentConnection",
		func() (any, error) {
			conn, err := h.GetCurrentConnection()
			return handler.WrapConnection(conn), err
		})

	p.RegisterEndpoint(
		"DbeeConnectionExecute",
		func(args *struct {
			ID    core.ConnectionID `msgpack:",array"`
			Query string
		},
		) (any, error) {
			call, err := h.ConnectionExecute(args.ID, args.Query)
			return handler.WrapCall(call), err
		})

	p.RegisterEndpoint(
		"DbeeConnectionGetCalls",
		func(args *struct {
			ID core.ConnectionID `msgpack:",array"`
		},
		) (any, error) {
			calls, err := h.ConnectionGetCalls(args.ID)
			return handler.WrapCalls(calls), err
		})

	p.RegisterEndpoint(
		"DbeeConnectionGetParams",
		func(args *struct {
			ID core.ConnectionID `msgpack:",array"`
		},
		) (any, error) {
			params, err := h.ConnectionGetParams(args.ID)
			return handler.WrapConnectionParams(params), err
		})

	p.RegisterEndpoint(
		"DbeeConnectionGetStructure",
		func(args *struct {
			ID core.ConnectionID `msgpack:",array"`
		},
		) (any, error) {
			str, err := h.ConnectionGetStructure(args.ID)
			return handler.WrapStructures(str), err
		})

	p.RegisterEndpoint("DbeeConnectionGetColumns", func(args *struct {
		ID   core.ConnectionID `msgpack:",array"`
		Opts *struct {
			Table           string `msgpack:"table"`
			Schema          string `msgpack:"schema"`
			Materialization string `msgpack:"materialization"`
		}
	},
	) (any, error) {
		cols, err := h.ConnectionGetColumns(args.ID, &core.TableOptions{
			Table:           args.Opts.Table,
			Schema:          args.Opts.Schema,
			Materialization: core.StructureTypeFromString(args.Opts.Materialization),
		})
		return handler.WrapColumns(cols), err
	})

	p.RegisterEndpoint(
		"DbeeConnectionListDatabases",
		func(args *struct {
			ID core.ConnectionID `msgpack:",array"`
		},
		) (any, error) {
			current, available, err := h.ConnectionListDatabases(args.ID)
			if err != nil {
				return nil, err
			}
			return []any{current, available}, nil
		})

	p.RegisterEndpoint(
		"DbeeConnectionSelectDatabase",
		func(args *struct {
			ID       core.ConnectionID `msgpack:",array"`
			Database string
		},
		) (any, error) {
			return nil, h.ConnectionSelectDatabase(args.ID, args.Database)
		})

	p.RegisterEndpoint(
		"DbeeCallCancel",
		func(args *struct {
			ID core.CallID `msgpack:",array"`
		},
		) (any, error) {
			return nil, h.CallCancel(args.ID)
		})

	p.RegisterEndpoint(
		"DbeeCallDisplayResult",
		func(args *struct {
			ID   core.CallID `msgpack:",array"`
			Opts *struct {
				Buffer int `msgpack:"buffer"`
				From   int `msgpack:"from"`
				To     int `msgpack:"to"`
			}
		},
		) (any, error) {
			return h.CallDisplayResult(args.ID, nvim.Buffer(args.Opts.Buffer), args.Opts.From, args.Opts.To)
		})

	p.RegisterEndpoint(
		"DbeeCallStoreResult",
		func(args *struct {
			ID     core.CallID `msgpack:",array"`
			Format string
			Output string
			Opts   *struct {
				From     int `msgpack:"from"`
				To       int `msgpack:"to"`
				ExtraArg any `msgpack:"extra_arg"`
			}
		},
		) (any, error) {
			return nil, h.CallStoreResult(args.ID, args.Format, args.Output, args.Opts.From, args.Opts.To, args.Opts.ExtraArg)
		})
}



================================================
FILE: dbee/go.mod
================================================
module github.com/kndndrj/nvim-dbee/dbee

go 1.23

toolchain go1.23.4

require (
	cloud.google.com/go/bigquery v1.61.0
	github.com/ClickHouse/clickhouse-go/v2 v2.20.0
	github.com/DATA-DOG/go-sqlmock v1.5.2
	github.com/databricks/databricks-sql-go v1.5.3
	github.com/docker/docker v27.1.1+incompatible
	github.com/go-sql-driver/mysql v1.7.1
	github.com/google/uuid v1.6.0
	github.com/jedib0t/go-pretty/v6 v6.5.8
	github.com/lib/pq v1.10.9
	github.com/marcboeker/go-duckdb v1.7.0
	github.com/microsoft/go-mssqldb v1.7.0
	github.com/neovim/go-client v1.2.1
	github.com/redis/go-redis/v9 v9.0.2
	github.com/sijms/go-ora/v2 v2.7.6
	github.com/stretchr/testify v1.10.0
	github.com/testcontainers/testcontainers-go v0.35.0
	github.com/testcontainers/testcontainers-go/modules/clickhouse v0.35.0
	github.com/testcontainers/testcontainers-go/modules/gcloud v0.35.0
	github.com/testcontainers/testcontainers-go/modules/mssql v0.35.0
	github.com/testcontainers/testcontainers-go/modules/mysql v0.35.0
	github.com/testcontainers/testcontainers-go/modules/postgres v0.35.0
	go.mongodb.org/mongo-driver v1.11.6
	golang.org/x/sync v0.10.0
	google.golang.org/api v0.189.0
	google.golang.org/grpc v1.64.1
	modernc.org/sqlite v1.21.2
)

require (
	cloud.google.com/go v0.115.0 // indirect
	cloud.google.com/go/auth v0.7.2 // indirect
	cloud.google.com/go/auth/oauth2adapt v0.2.3 // indirect
	cloud.google.com/go/compute/metadata v0.5.0 // indirect
	cloud.google.com/go/iam v1.1.10 // indirect
	dario.cat/mergo v1.0.0 // indirect
	github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect
	github.com/ClickHouse/ch-go v0.61.3 // indirect
	github.com/GoogleCloudPlatform/grpc-gcp-go/grpcgcp v1.5.2 // indirect
	github.com/Microsoft/go-winio v0.6.2 // indirect
	github.com/andybalholm/brotli v1.1.0 // indirect
	github.com/apache/arrow/go/v12 v12.0.1 // indirect
	github.com/apache/arrow/go/v14 v14.0.2 // indirect
	github.com/apache/arrow/go/v15 v15.0.2 // indirect
	github.com/apache/thrift v0.17.0 // indirect
	github.com/cenkalti/backoff/v4 v4.2.1 // indirect
	github.com/cespare/xxhash/v2 v2.2.0 // indirect
	github.com/containerd/containerd v1.7.18 // indirect
	github.com/containerd/log v0.1.0 // indirect
	github.com/containerd/platforms v0.2.1 // indirect
	github.com/coreos/go-oidc/v3 v3.5.0 // indirect
	github.com/cpuguy83/dockercfg v0.3.2 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/distribution/reference v0.6.0 // indirect
	github.com/dnephin/pflag v1.0.7 // indirect
	github.com/docker/go-connections v0.5.0 // indirect
	github.com/docker/go-units v0.5.0 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/fatih/color v1.15.0 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/go-faster/city v1.0.1 // indirect
	github.com/go-faster/errors v0.7.1 // indirect
	github.com/go-jose/go-jose/v3 v3.0.3 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-ole/go-ole v1.2.6 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 // indirect
	github.com/golang-sql/sqlexp v0.1.0 // indirect
	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
	github.com/golang/protobuf v1.5.4 // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/google/flatbuffers v23.5.26+incompatible // indirect
	github.com/google/s2a-go v0.1.7 // indirect
	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.2 // indirect
	github.com/googleapis/gax-go/v2 v2.12.5 // indirect
	github.com/hashicorp/go-cleanhttp v0.5.1 // indirect
	github.com/hashicorp/go-retryablehttp v0.7.1 // indirect
	github.com/hashicorp/go-uuid v1.0.3 // indirect
	github.com/jcmturner/aescts/v2 v2.0.0 // indirect
	github.com/jcmturner/dnsutils/v2 v2.0.0 // indirect
	github.com/jcmturner/gofork v1.7.6 // indirect
	github.com/jcmturner/goidentity/v6 v6.0.1 // indirect
	github.com/jcmturner/gokrb5/v8 v8.4.4 // indirect
	github.com/jcmturner/rpc/v2 v2.0.3 // indirect
	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
	github.com/klauspost/asmfmt v1.3.2 // indirect
	github.com/klauspost/compress v1.17.7 // indirect
	github.com/klauspost/cpuid/v2 v2.2.5 // indirect
	github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.19 // indirect
	github.com/mattn/go-runewidth v0.0.15 // indirect
	github.com/minio/asm2plan9s v0.0.0-20200509001527-cdd76441f9d8 // indirect
	github.com/minio/c2goasm v0.0.0-20190812172519-36a3d3bbc4f3 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/moby/docker-image-spec v1.3.1 // indirect
	github.com/moby/patternmatcher v0.6.0 // indirect
	github.com/moby/sys/sequential v0.5.0 // indirect
	github.com/moby/sys/user v0.1.0 // indirect
	github.com/moby/term v0.5.0 // indirect
	github.com/montanaflynn/stats v0.6.6 // indirect
	github.com/morikuni/aec v1.0.0 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.1.0 // indirect
	github.com/paulmach/orb v0.11.1 // indirect
	github.com/pierrec/lz4/v4 v4.1.21 // indirect
	github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	github.com/rivo/uniseg v0.2.0 // indirect
	github.com/rs/zerolog v1.32.0 // indirect
	github.com/segmentio/asm v1.2.0 // indirect
	github.com/shirou/gopsutil/v3 v3.23.12 // indirect
	github.com/shoenig/go-m1cpu v0.1.6 // indirect
	github.com/shopspring/decimal v1.3.1 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/tklauser/go-sysconf v0.3.12 // indirect
	github.com/tklauser/numcpus v0.6.1 // indirect
	github.com/xdg-go/pbkdf2 v1.0.0 // indirect
	github.com/xdg-go/scram v1.1.1 // indirect
	github.com/xdg-go/stringprep v1.0.3 // indirect
	github.com/youmark/pkcs8 v0.0.0-20181117223130-1be2e3e5546d // indirect
	github.com/yusufpapurcu/wmi v1.2.3 // indirect
	github.com/zeebo/xxh3 v1.0.2 // indirect
	go.opencensus.io v0.24.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 // indirect
	go.opentelemetry.io/otel v1.24.0 // indirect
	go.opentelemetry.io/otel/metric v1.24.0 // indirect
	go.opentelemetry.io/otel/trace v1.24.0 // indirect
	golang.org/x/crypto v0.31.0 // indirect
	golang.org/x/exp v0.0.0-20231006140011-7918f672742d // indirect
	golang.org/x/mod v0.17.0 // indirect
	golang.org/x/net v0.27.0 // indirect
	golang.org/x/oauth2 v0.21.0 // indirect
	golang.org/x/sys v0.28.0 // indirect
	golang.org/x/term v0.27.0 // indirect
	golang.org/x/text v0.21.0 // indirect
	golang.org/x/time v0.5.0 // indirect
	golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d // indirect
	golang.org/x/xerrors v0.0.0-20231012003039-104605ab7028 // indirect
	google.golang.org/genproto v0.0.0-20240722135656-d784300faade // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20240701130421-f6361c86f094 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240722135656-d784300faade // indirect
	google.golang.org/protobuf v1.34.2 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	gotest.tools/gotestsum v1.8.2 // indirect
	lukechampine.com/uint128 v1.3.0 // indirect
	modernc.org/cc/v3 v3.40.0 // indirect
	modernc.org/ccgo/v3 v3.16.13 // indirect
	modernc.org/libc v1.22.4 // indirect
	modernc.org/mathutil v1.5.0 // indirect
	modernc.org/memory v1.5.0 // indirect
	modernc.org/opt v0.1.3 // indirect
	modernc.org/strutil v1.1.3 // indirect
	modernc.org/token v1.1.0 // indirect
)



================================================
FILE: dbee/go.sum
================================================
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=
cloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=
cloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
cloud.google.com/go v0.44.3/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
cloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=
cloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=
cloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=
cloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=
cloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=
cloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=
cloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=
cloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=
cloud.google.com/go v0.62.0/go.mod h1:jmCYTdRCQuc1PHIIJ/maLInMho30T/Y0M4hTdTShOYc=
cloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHObY=
cloud.google.com/go v0.72.0/go.mod h1:M+5Vjvlc2wnp6tjzE102Dw08nGShTscUx2nZMufOKPI=
cloud.google.com/go v0.74.0/go.mod h1:VV1xSbzvo+9QJOxLDaJfTjx5e+MePCpCWwvftOeQmWk=
cloud.google.com/go v0.75.0/go.mod h1:VGuuCn7PG0dwsd5XPVm2Mm3wlh3EL55/79EKB6hlPTY=
cloud.google.com/go v0.78.0/go.mod h1:QjdrLG0uq+YwhjoVOLsS1t7TW8fs36kLs4XO5R5ECHg=
cloud.google.com/go v0.79.0/go.mod h1:3bzgcEeQlzbuEAYu4mrWhKqWjmpprinYgKJLgKHnbb8=
cloud.google.com/go v0.81.0/go.mod h1:mk/AM35KwGk/Nm2YSeZbxXdrNK3KZOYHmLkOqC2V6E0=
cloud.google.com/go v0.83.0/go.mod h1:Z7MJUsANfY0pYPdw0lbnivPx4/vhy/e2FEkSkF7vAVY=
cloud.google.com/go v0.84.0/go.mod h1:RazrYuxIK6Kb7YrzzhPoLmCVzl7Sup4NrbKPg8KHSUM=
cloud.google.com/go v0.87.0/go.mod h1:TpDYlFy7vuLzZMMZ+B6iRiELaY7z/gJPaqbMx6mlWcY=
cloud.google.com/go v0.90.0/go.mod h1:kRX0mNRHe0e2rC6oNakvwQqzyDmg57xJ+SZU1eT2aDQ=
cloud.google.com/go v0.93.3/go.mod h1:8utlLll2EF5XMAV15woO4lSbWQlk8rer9aLOfLh7+YI=
cloud.google.com/go v0.94.1/go.mod h1:qAlAugsXlC+JWO+Bke5vCtc9ONxjQT3drlTTnAplMW4=
cloud.google.com/go v0.97.0/go.mod h1:GF7l59pYBVlXQIBLx3a761cZ41F9bBH3JUlihCt2Udc=
cloud.google.com/go v0.99.0/go.mod h1:w0Xx2nLzqWJPuozYQX+hFfCSI8WioryfRDzkoI/Y2ZA=
cloud.google.com/go v0.100.1/go.mod h1:fs4QogzfH5n2pBXBP9vRiU+eCny7lD2vmFZy79Iuw1U=
cloud.google.com/go v0.100.2/go.mod h1:4Xra9TjzAeYHrl5+oeLlzbM2k3mjVhZh4UqTZ//w99A=
cloud.google.com/go v0.102.0/go.mod h1:oWcCzKlqJ5zgHQt9YsaeTY9KzIvjyy0ArmiBUgpQ+nc=
cloud.google.com/go v0.102.1/go.mod h1:XZ77E9qnTEnrgEOvr4xzfdX5TRo7fB4T2F4O6+34hIU=
cloud.google.com/go v0.104.0/go.mod h1:OO6xxXdJyvuJPcEPBLN9BJPD+jep5G1+2U5B5gkRYtA=
cloud.google.com/go v0.105.0/go.mod h1:PrLgOJNe5nfE9UMxKxgXj4mD3voiP+YQ6gdt6KMFOKM=
cloud.google.com/go v0.107.0/go.mod h1:wpc2eNrD7hXUTy8EKS10jkxpZBjASrORK7goS+3YX2I=
cloud.google.com/go v0.110.0/go.mod h1:SJnCLqQ0FCFGSZMUNUf84MV3Aia54kn7pi8st7tMzaY=
cloud.google.com/go v0.115.0 h1:CnFSK6Xo3lDYRoBKEcAtia6VSC837/ZkJuRduSFnr14=
cloud.google.com/go v0.115.0/go.mod h1:8jIM5vVgoAEoiVxQ/O4BFTfHqulPZgs/ufEzMcFMdWU=
cloud.google.com/go/accessapproval v1.4.0/go.mod h1:zybIuC3KpDOvotz59lFe5qxRZx6C75OtwbisN56xYB4=
cloud.google.com/go/accessapproval v1.5.0/go.mod h1:HFy3tuiGvMdcd/u+Cu5b9NkO1pEICJ46IR82PoUdplw=
cloud.google.com/go/accessapproval v1.6.0/go.mod h1:R0EiYnwV5fsRFiKZkPHr6mwyk2wxUJ30nL4j2pcFY2E=
cloud.google.com/go/accesscontextmanager v1.3.0/go.mod h1:TgCBehyr5gNMz7ZaH9xubp+CE8dkrszb4oK9CWyvD4o=
cloud.google.com/go/accesscontextmanager v1.4.0/go.mod h1:/Kjh7BBu/Gh83sv+K60vN9QE5NJcd80sU33vIe2IFPE=
cloud.google.com/go/accesscontextmanager v1.6.0/go.mod h1:8XCvZWfYw3K/ji0iVnp+6pu7huxoQTLmxAbVjbloTtM=
cloud.google.com/go/accesscontextmanager v1.7.0/go.mod h1:CEGLewx8dwa33aDAZQujl7Dx+uYhS0eay198wB/VumQ=
cloud.google.com/go/aiplatform v1.22.0/go.mod h1:ig5Nct50bZlzV6NvKaTwmplLLddFx0YReh9WfTO5jKw=
cloud.google.com/go/aiplatform v1.24.0/go.mod h1:67UUvRBKG6GTayHKV8DBv2RtR1t93YRu5B1P3x99mYY=
cloud.google.com/go/aiplatform v1.27.0/go.mod h1:Bvxqtl40l0WImSb04d0hXFU7gDOiq9jQmorivIiWcKg=
cloud.google.com/go/aiplatform v1.35.0/go.mod h1:7MFT/vCaOyZT/4IIFfxH4ErVg/4ku6lKv3w0+tFTgXQ=
cloud.google.com/go/aiplatform v1.36.1/go.mod h1:WTm12vJRPARNvJ+v6P52RDHCNe4AhvjcIZ/9/RRHy/k=
cloud.google.com/go/aiplatform v1.37.0/go.mod h1:IU2Cv29Lv9oCn/9LkFiiuKfwrRTq+QQMbW+hPCxJGZw=
cloud.google.com/go/analytics v0.11.0/go.mod h1:DjEWCu41bVbYcKyvlws9Er60YE4a//bK6mnhWvQeFNI=
cloud.google.com/go/analytics v0.12.0/go.mod h1:gkfj9h6XRf9+TS4bmuhPEShsh3hH8PAZzm/41OOhQd4=
cloud.google.com/go/analytics v0.17.0/go.mod h1:WXFa3WSym4IZ+JiKmavYdJwGG/CvpqiqczmL59bTD9M=
cloud.google.com/go/analytics v0.18.0/go.mod h1:ZkeHGQlcIPkw0R/GW+boWHhCOR43xz9RN/jn7WcqfIE=
cloud.google.com/go/analytics v0.19.0/go.mod h1:k8liqf5/HCnOUkbawNtrWWc+UAzyDlW89doe8TtoDsE=
cloud.google.com/go/apigateway v1.3.0/go.mod h1:89Z8Bhpmxu6AmUxuVRg/ECRGReEdiP3vQtk4Z1J9rJk=
cloud.google.com/go/apigateway v1.4.0/go.mod h1:pHVY9MKGaH9PQ3pJ4YLzoj6U5FUDeDFBllIz7WmzJoc=
cloud.google.com/go/apigateway v1.5.0/go.mod h1:GpnZR3Q4rR7LVu5951qfXPJCHquZt02jf7xQx7kpqN8=
cloud.google.com/go/apigeeconnect v1.3.0/go.mod h1:G/AwXFAKo0gIXkPTVfZDd2qA1TxBXJ3MgMRBQkIi9jc=
cloud.google.com/go/apigeeconnect v1.4.0/go.mod h1:kV4NwOKqjvt2JYR0AoIWo2QGfoRtn/pkS3QlHp0Ni04=
cloud.google.com/go/apigeeconnect v1.5.0/go.mod h1:KFaCqvBRU6idyhSNyn3vlHXc8VMDJdRmwDF6JyFRqZ8=
cloud.google.com/go/apigeeregistry v0.4.0/go.mod h1:EUG4PGcsZvxOXAdyEghIdXwAEi/4MEaoqLMLDMIwKXY=
cloud.google.com/go/apigeeregistry v0.5.0/go.mod h1:YR5+s0BVNZfVOUkMa5pAR2xGd0A473vA5M7j247o1wM=
cloud.google.com/go/apigeeregistry v0.6.0/go.mod h1:BFNzW7yQVLZ3yj0TKcwzb8n25CFBri51GVGOEUcgQsc=
cloud.google.com/go/apikeys v0.4.0/go.mod h1:XATS/yqZbaBK0HOssf+ALHp8jAlNHUgyfprvNcBIszU=
cloud.google.com/go/apikeys v0.5.0/go.mod h1:5aQfwY4D+ewMMWScd3hm2en3hCj+BROlyrt3ytS7KLI=
cloud.google.com/go/apikeys v0.6.0/go.mod h1:kbpXu5upyiAlGkKrJgQl8A0rKNNJ7dQ377pdroRSSi8=
cloud.google.com/go/appengine v1.4.0/go.mod h1:CS2NhuBuDXM9f+qscZ6V86m1MIIqPj3WC/UoEuR1Sno=
cloud.google.com/go/appengine v1.5.0/go.mod h1:TfasSozdkFI0zeoxW3PTBLiNqRmzraodCWatWI9Dmak=
cloud.google.com/go/appengine v1.6.0/go.mod h1:hg6i0J/BD2cKmDJbaFSYHFyZkgBEfQrDg/X0V5fJn84=
cloud.google.com/go/appengine v1.7.0/go.mod h1:eZqpbHFCqRGa2aCdope7eC0SWLV1j0neb/QnMJVWx6A=
cloud.google.com/go/appengine v1.7.1/go.mod h1:IHLToyb/3fKutRysUlFO0BPt5j7RiQ45nrzEJmKTo6E=
cloud.google.com/go/area120 v0.5.0/go.mod h1:DE/n4mp+iqVyvxHN41Vf1CR602GiHQjFPusMFW6bGR4=
cloud.google.com/go/area120 v0.6.0/go.mod h1:39yFJqWVgm0UZqWTOdqkLhjoC7uFfgXRC8g/ZegeAh0=
cloud.google.com/go/area120 v0.7.0/go.mod h1:a3+8EUD1SX5RUcCs3MY5YasiO1z6yLiNLRiFrykbynY=
cloud.google.com/go/area120 v0.7.1/go.mod h1:j84i4E1RboTWjKtZVWXPqvK5VHQFJRF2c1Nm69pWm9k=
cloud.google.com/go/artifactregistry v1.6.0/go.mod h1:IYt0oBPSAGYj/kprzsBjZ/4LnG/zOcHyFHjWPCi6SAQ=
cloud.google.com/go/artifactregistry v1.7.0/go.mod h1:mqTOFOnGZx8EtSqK/ZWcsm/4U8B77rbcLP6ruDU2Ixk=
cloud.google.com/go/artifactregistry v1.8.0/go.mod h1:w3GQXkJX8hiKN0v+at4b0qotwijQbYUqF2GWkZzAhC0=
cloud.google.com/go/artifactregistry v1.9.0/go.mod h1:2K2RqvA2CYvAeARHRkLDhMDJ3OXy26h3XW+3/Jh2uYc=
cloud.google.com/go/artifactregistry v1.11.1/go.mod h1:lLYghw+Itq9SONbCa1YWBoWs1nOucMH0pwXN1rOBZFI=
cloud.google.com/go/artifactregistry v1.11.2/go.mod h1:nLZns771ZGAwVLzTX/7Al6R9ehma4WUEhZGWV6CeQNQ=
cloud.google.com/go/artifactregistry v1.12.0/go.mod h1:o6P3MIvtzTOnmvGagO9v/rOjjA0HmhJ+/6KAXrmYDCI=
cloud.google.com/go/artifactregistry v1.13.0/go.mod h1:uy/LNfoOIivepGhooAUpL1i30Hgee3Cu0l4VTWHUC08=
cloud.google.com/go/asset v1.5.0/go.mod h1:5mfs8UvcM5wHhqtSv8J1CtxxaQq3AdBxxQi2jGW/K4o=
cloud.google.com/go/asset v1.7.0/go.mod h1:YbENsRK4+xTiL+Ofoj5Ckf+O17kJtgp3Y3nn4uzZz5s=
cloud.google.com/go/asset v1.8.0/go.mod h1:mUNGKhiqIdbr8X7KNayoYvyc4HbbFO9URsjbytpUaW0=
cloud.google.com/go/asset v1.9.0/go.mod h1:83MOE6jEJBMqFKadM9NLRcs80Gdw76qGuHn8m3h8oHQ=
cloud.google.com/go/asset v1.10.0/go.mod h1:pLz7uokL80qKhzKr4xXGvBQXnzHn5evJAEAtZiIb0wY=
cloud.google.com/go/asset v1.11.1/go.mod h1:fSwLhbRvC9p9CXQHJ3BgFeQNM4c9x10lqlrdEUYXlJo=
cloud.google.com/go/asset v1.12.0/go.mod h1:h9/sFOa4eDIyKmH6QMpm4eUK3pDojWnUhTgJlk762Hg=
cloud.google.com/go/asset v1.13.0/go.mod h1:WQAMyYek/b7NBpYq/K4KJWcRqzoalEsxz/t/dTk4THw=
cloud.google.com/go/assuredworkloads v1.5.0/go.mod h1:n8HOZ6pff6re5KYfBXcFvSViQjDwxFkAkmUFffJRbbY=
cloud.google.com/go/assuredworkloads v1.6.0/go.mod h1:yo2YOk37Yc89Rsd5QMVECvjaMKymF9OP+QXWlKXUkXw=
cloud.google.com/go/assuredworkloads v1.7.0/go.mod h1:z/736/oNmtGAyU47reJgGN+KVoYoxeLBoj4XkKYscNI=
cloud.google.com/go/assuredworkloads v1.8.0/go.mod h1:AsX2cqyNCOvEQC8RMPnoc0yEarXQk6WEKkxYfL6kGIo=
cloud.google.com/go/assuredworkloads v1.9.0/go.mod h1:kFuI1P78bplYtT77Tb1hi0FMxM0vVpRC7VVoJC3ZoT0=
cloud.google.com/go/assuredworkloads v1.10.0/go.mod h1:kwdUQuXcedVdsIaKgKTp9t0UJkE5+PAVNhdQm4ZVq2E=
cloud.google.com/go/auth v0.7.2 h1:uiha352VrCDMXg+yoBtaD0tUF4Kv9vrtrWPYXwutnDE=
cloud.google.com/go/auth v0.7.2/go.mod h1:VEc4p5NNxycWQTMQEDQF0bd6aTMb6VgYDXEwiJJQAbs=
cloud.google.com/go/auth/oauth2adapt v0.2.3 h1:MlxF+Pd3OmSudg/b1yZ5lJwoXCEaeedAguodky1PcKI=
cloud.google.com/go/auth/oauth2adapt v0.2.3/go.mod h1:tMQXOfZzFuNuUxOypHlQEXgdfX5cuhwU+ffUuXRJE8I=
cloud.google.com/go/automl v1.5.0/go.mod h1:34EjfoFGMZ5sgJ9EoLsRtdPSNZLcfflJR39VbVNS2M0=
cloud.google.com/go/automl v1.6.0/go.mod h1:ugf8a6Fx+zP0D59WLhqgTDsQI9w07o64uf/Is3Nh5p8=
cloud.google.com/go/automl v1.7.0/go.mod h1:RL9MYCCsJEOmt0Wf3z9uzG0a7adTT1fe+aObgSpkCt8=
cloud.google.com/go/automl v1.8.0/go.mod h1:xWx7G/aPEe/NP+qzYXktoBSDfjO+vnKMGgsApGJJquM=
cloud.google.com/go/automl v1.12.0/go.mod h1:tWDcHDp86aMIuHmyvjuKeeHEGq76lD7ZqfGLN6B0NuU=
cloud.google.com/go/baremetalsolution v0.3.0/go.mod h1:XOrocE+pvK1xFfleEnShBlNAXf+j5blPPxrhjKgnIFc=
cloud.google.com/go/baremetalsolution v0.4.0/go.mod h1:BymplhAadOO/eBa7KewQ0Ppg4A4Wplbn+PsFKRLo0uI=
cloud.google.com/go/baremetalsolution v0.5.0/go.mod h1:dXGxEkmR9BMwxhzBhV0AioD0ULBmuLZI8CdwalUxuss=
cloud.google.com/go/batch v0.3.0/go.mod h1:TR18ZoAekj1GuirsUsR1ZTKN3FC/4UDnScjT8NXImFE=
cloud.google.com/go/batch v0.4.0/go.mod h1:WZkHnP43R/QCGQsZ+0JyG4i79ranE2u8xvjq/9+STPE=
cloud.google.com/go/batch v0.7.0/go.mod h1:vLZN95s6teRUqRQ4s3RLDsH8PvboqBK+rn1oevL159g=
cloud.google.com/go/beyondcorp v0.2.0/go.mod h1:TB7Bd+EEtcw9PCPQhCJtJGjk/7TC6ckmnSFS+xwTfm4=
cloud.google.com/go/beyondcorp v0.3.0/go.mod h1:E5U5lcrcXMsCuoDNyGrpyTm/hn7ne941Jz2vmksAxW8=
cloud.google.com/go/beyondcorp v0.4.0/go.mod h1:3ApA0mbhHx6YImmuubf5pyW8srKnCEPON32/5hj+RmM=
cloud.google.com/go/beyondcorp v0.5.0/go.mod h1:uFqj9X+dSfrheVp7ssLTaRHd2EHqSL4QZmH4e8WXGGU=
cloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=
cloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=
cloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=
cloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=
cloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=
cloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=
cloud.google.com/go/bigquery v1.42.0/go.mod h1:8dRTJxhtG+vwBKzE5OseQn/hiydoQN3EedCaOdYmxRA=
cloud.google.com/go/bigquery v1.43.0/go.mod h1:ZMQcXHsl+xmU1z36G2jNGZmKp9zNY5BUua5wDgmNCfw=
cloud.google.com/go/bigquery v1.44.0/go.mod h1:0Y33VqXTEsbamHJvJHdFmtqHvMIY28aK1+dFsvaChGc=
cloud.google.com/go/bigquery v1.47.0/go.mod h1:sA9XOgy0A8vQK9+MWhEQTY6Tix87M/ZurWFIxmF9I/E=
cloud.google.com/go/bigquery v1.48.0/go.mod h1:QAwSz+ipNgfL5jxiaK7weyOhzdoAy1zFm0Nf1fysJac=
cloud.google.com/go/bigquery v1.49.0/go.mod h1:Sv8hMmTFFYBlt/ftw2uN6dFdQPzBlREY9yBh7Oy7/4Q=
cloud.google.com/go/bigquery v1.50.0/go.mod h1:YrleYEh2pSEbgTBZYMJ5SuSr0ML3ypjRB1zgf7pvQLU=
cloud.google.com/go/bigquery v1.61.0 h1:w2Goy9n6gh91LVi6B2Sc+HpBl8WbWhIyzdvVvrAuEIw=
cloud.google.com/go/bigquery v1.61.0/go.mod h1:PjZUje0IocbuTOdq4DBOJLNYB0WF3pAKBHzAYyxCwFo=
cloud.google.com/go/bigtable v1.21.0 h1:BFN4jhkA9ULYYV2Ug7AeOtetVLnN2jKuIq5TcRc5C38=
cloud.google.com/go/bigtable v1.21.0/go.mod h1:V0sYNRtk0dgAKjyRr/MyBpHpSXqh+9P39euf820EZ74=
cloud.google.com/go/billing v1.4.0/go.mod h1:g9IdKBEFlItS8bTtlrZdVLWSSdSyFUZKXNS02zKMOZY=
cloud.google.com/go/billing v1.5.0/go.mod h1:mztb1tBc3QekhjSgmpf/CV4LzWXLzCArwpLmP2Gm88s=
cloud.google.com/go/billing v1.6.0/go.mod h1:WoXzguj+BeHXPbKfNWkqVtDdzORazmCjraY+vrxcyvI=
cloud.google.com/go/billing v1.7.0/go.mod h1:q457N3Hbj9lYwwRbnlD7vUpyjq6u5U1RAOArInEiD5Y=
cloud.google.com/go/billing v1.12.0/go.mod h1:yKrZio/eu+okO/2McZEbch17O5CB5NpZhhXG6Z766ss=
cloud.google.com/go/billing v1.13.0/go.mod h1:7kB2W9Xf98hP9Sr12KfECgfGclsH3CQR0R08tnRlRbc=
cloud.google.com/go/binaryauthorization v1.1.0/go.mod h1:xwnoWu3Y84jbuHa0zd526MJYmtnVXn0syOjaJgy4+dM=
cloud.google.com/go/binaryauthorization v1.2.0/go.mod h1:86WKkJHtRcv5ViNABtYMhhNWRrD1Vpi//uKEy7aYEfI=
cloud.google.com/go/binaryauthorization v1.3.0/go.mod h1:lRZbKgjDIIQvzYQS1p99A7/U1JqvqeZg0wiI5tp6tg0=
cloud.google.com/go/binaryauthorization v1.4.0/go.mod h1:tsSPQrBd77VLplV70GUhBf/Zm3FsKmgSqgm4UmiDItk=
cloud.google.com/go/binaryauthorization v1.5.0/go.mod h1:OSe4OU1nN/VswXKRBmciKpo9LulY41gch5c68htf3/Q=
cloud.google.com/go/certificatemanager v1.3.0/go.mod h1:n6twGDvcUBFu9uBgt4eYvvf3sQ6My8jADcOVwHmzadg=
cloud.google.com/go/certificatemanager v1.4.0/go.mod h1:vowpercVFyqs8ABSmrdV+GiFf2H/ch3KyudYQEMM590=
cloud.google.com/go/certificatemanager v1.6.0/go.mod h1:3Hh64rCKjRAX8dXgRAyOcY5vQ/fE1sh8o+Mdd6KPgY8=
cloud.google.com/go/channel v1.8.0/go.mod h1:W5SwCXDJsq/rg3tn3oG0LOxpAo6IMxNa09ngphpSlnk=
cloud.google.com/go/channel v1.9.0/go.mod h1:jcu05W0my9Vx4mt3/rEHpfxc9eKi9XwsdDL8yBMbKUk=
cloud.google.com/go/channel v1.11.0/go.mod h1:IdtI0uWGqhEeatSB62VOoJ8FSUhJ9/+iGkJVqp74CGE=
cloud.google.com/go/channel v1.12.0/go.mod h1:VkxCGKASi4Cq7TbXxlaBezonAYpp1GCnKMY6tnMQnLU=
cloud.google.com/go/cloudbuild v1.3.0/go.mod h1:WequR4ULxlqvMsjDEEEFnOG5ZSRSgWOywXYDb1vPE6U=
cloud.google.com/go/cloudbuild v1.4.0/go.mod h1:5Qwa40LHiOXmz3386FrjrYM93rM/hdRr7b53sySrTqA=
cloud.google.com/go/cloudbuild v1.6.0/go.mod h1:UIbc/w9QCbH12xX+ezUsgblrWv+Cv4Tw83GiSMHOn9M=
cloud.google.com/go/cloudbuild v1.7.0/go.mod h1:zb5tWh2XI6lR9zQmsm1VRA+7OCuve5d8S+zJUul8KTg=
cloud.google.com/go/cloudbuild v1.9.0/go.mod h1:qK1d7s4QlO0VwfYn5YuClDGg2hfmLZEb4wQGAbIgL1s=
cloud.google.com/go/clouddms v1.3.0/go.mod h1:oK6XsCDdW4Ib3jCCBugx+gVjevp2TMXFtgxvPSee3OM=
cloud.google.com/go/clouddms v1.4.0/go.mod h1:Eh7sUGCC+aKry14O1NRljhjyrr0NFC0G2cjwX0cByRk=
cloud.google.com/go/clouddms v1.5.0/go.mod h1:QSxQnhikCLUw13iAbffF2CZxAER3xDGNHjsTAkQJcQA=
cloud.google.com/go/cloudtasks v1.5.0/go.mod h1:fD92REy1x5woxkKEkLdvavGnPJGEn8Uic9nWuLzqCpY=
cloud.google.com/go/cloudtasks v1.6.0/go.mod h1:C6Io+sxuke9/KNRkbQpihnW93SWDU3uXt92nu85HkYI=
cloud.google.com/go/cloudtasks v1.7.0/go.mod h1:ImsfdYWwlWNJbdgPIIGJWC+gemEGTBK/SunNQQNCAb4=
cloud.google.com/go/cloudtasks v1.8.0/go.mod h1:gQXUIwCSOI4yPVK7DgTVFiiP0ZW/eQkydWzwVMdHxrI=
cloud.google.com/go/cloudtasks v1.9.0/go.mod h1:w+EyLsVkLWHcOaqNEyvcKAsWp9p29dL6uL9Nst1cI7Y=
cloud.google.com/go/cloudtasks v1.10.0/go.mod h1:NDSoTLkZ3+vExFEWu2UJV1arUyzVDAiZtdWcsUyNwBs=
cloud.google.com/go/compute v0.1.0/go.mod h1:GAesmwr110a34z04OlxYkATPBEfVhkymfTBXtfbBFow=
cloud.google.com/go/compute v1.3.0/go.mod h1:cCZiE1NHEtai4wiufUhW8I8S1JKkAnhnQJWM7YD99wM=
cloud.google.com/go/compute v1.5.0/go.mod h1:9SMHyhJlzhlkJqrPAc839t2BZFTSk6Jdj6mkzQJeu0M=
cloud.google.com/go/compute v1.6.0/go.mod h1:T29tfhtVbq1wvAPo0E3+7vhgmkOYeXjhFvz/FMzPu0s=
cloud.google.com/go/compute v1.6.1/go.mod h1:g85FgpzFvNULZ+S8AYq87axRKuf2Kh7deLqV/jJ3thU=
cloud.google.com/go/compute v1.7.0/go.mod h1:435lt8av5oL9P3fv1OEzSbSUe+ybHXGMPQHHZWZxy9U=
cloud.google.com/go/compute v1.10.0/go.mod h1:ER5CLbMxl90o2jtNbGSbtfOpQKR0t15FOtRsugnLrlU=
cloud.google.com/go/compute v1.12.0/go.mod h1:e8yNOBcBONZU1vJKCvCoDw/4JQsA0dpM4x/6PIIOocU=
cloud.google.com/go/compute v1.12.1/go.mod h1:e8yNOBcBONZU1vJKCvCoDw/4JQsA0dpM4x/6PIIOocU=
cloud.google.com/go/compute v1.13.0/go.mod h1:5aPTS0cUNMIc1CE546K+Th6weJUNQErARyZtRXDJ8GE=
cloud.google.com/go/compute v1.14.0/go.mod h1:YfLtxrj9sU4Yxv+sXzZkyPjEyPBZfXHUvjxega5vAdo=
cloud.google.com/go/compute v1.15.1/go.mod h1:bjjoF/NtFUrkD/urWfdHaKuOPDR5nWIs63rR+SXhcpA=
cloud.google.com/go/compute v1.18.0/go.mod h1:1X7yHxec2Ga+Ss6jPyjxRxpu2uu7PLgsOVXvgU0yacs=
cloud.google.com/go/compute v1.19.0/go.mod h1:rikpw2y+UMidAe9tISo04EHNOIf42RLYF/q8Bs93scU=
cloud.google.com/go/compute v1.19.1/go.mod h1:6ylj3a05WF8leseCdIf77NK0g1ey+nj5IKd5/kvShxE=
cloud.google.com/go/compute/metadata v0.1.0/go.mod h1:Z1VN+bulIf6bt4P/C37K4DyZYZEXYonfTBHHFPO/4UU=
cloud.google.com/go/compute/metadata v0.2.0/go.mod h1:zFmK7XCadkQkj6TtorcaGlCW1hT1fIilQDwofLpJ20k=
cloud.google.com/go/compute/metadata v0.2.1/go.mod h1:jgHgmJd2RKBGzXqF5LR2EZMGxBkeanZ9wwa75XHJgOM=
cloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=
cloud.google.com/go/compute/metadata v0.5.0 h1:Zr0eK8JbFv6+Wi4ilXAR8FJ3wyNdpxHKJNPos6LTZOY=
cloud.google.com/go/compute/metadata v0.5.0/go.mod h1:aHnloV2TPI38yx4s9+wAZhHykWvVCfu7hQbF+9CWoiY=
cloud.google.com/go/contactcenterinsights v1.3.0/go.mod h1:Eu2oemoePuEFc/xKFPjbTuPSj0fYJcPls9TFlPNnHHY=
cloud.google.com/go/contactcenterinsights v1.4.0/go.mod h1:L2YzkGbPsv+vMQMCADxJoT9YiTTnSEd6fEvCeHTYVck=
cloud.google.com/go/contactcenterinsights v1.6.0/go.mod h1:IIDlT6CLcDoyv79kDv8iWxMSTZhLxSCofVV5W6YFM/w=
cloud.google.com/go/container v1.6.0/go.mod h1:Xazp7GjJSeUYo688S+6J5V+n/t+G5sKBTFkKNudGRxg=
cloud.google.com/go/container v1.7.0/go.mod h1:Dp5AHtmothHGX3DwwIHPgq45Y8KmNsgN3amoYfxVkLo=
cloud.google.com/go/container v1.13.1/go.mod h1:6wgbMPeQRw9rSnKBCAJXnds3Pzj03C4JHamr8asWKy4=
cloud.google.com/go/container v1.14.0/go.mod h1:3AoJMPhHfLDxLvrlVWaK57IXzaPnLaZq63WX59aQBfM=
cloud.google.com/go/container v1.15.0/go.mod h1:ft+9S0WGjAyjDggg5S06DXj+fHJICWg8L7isCQe9pQA=
cloud.google.com/go/containeranalysis v0.5.1/go.mod h1:1D92jd8gRR/c0fGMlymRgxWD3Qw9C1ff6/T7mLgVL8I=
cloud.google.com/go/containeranalysis v0.6.0/go.mod h1:HEJoiEIu+lEXM+k7+qLCci0h33lX3ZqoYFdmPcoO7s4=
cloud.google.com/go/containeranalysis v0.7.0/go.mod h1:9aUL+/vZ55P2CXfuZjS4UjQ9AgXoSw8Ts6lemfmxBxI=
cloud.google.com/go/containeranalysis v0.9.0/go.mod h1:orbOANbwk5Ejoom+s+DUCTTJ7IBdBQJDcSylAx/on9s=
cloud.google.com/go/datacatalog v1.3.0/go.mod h1:g9svFY6tuR+j+hrTw3J2dNcmI0dzmSiyOzm8kpLq0a0=
cloud.google.com/go/datacatalog v1.5.0/go.mod h1:M7GPLNQeLfWqeIm3iuiruhPzkt65+Bx8dAKvScX8jvs=
cloud.google.com/go/datacatalog v1.6.0/go.mod h1:+aEyF8JKg+uXcIdAmmaMUmZ3q1b/lKLtXCmXdnc0lbc=
cloud.google.com/go/datacatalog v1.7.0/go.mod h1:9mEl4AuDYWw81UGc41HonIHH7/sn52H0/tc8f8ZbZIE=
cloud.google.com/go/datacatalog v1.8.0/go.mod h1:KYuoVOv9BM8EYz/4eMFxrr4DUKhGIOXxZoKYF5wdISM=
cloud.google.com/go/datacatalog v1.8.1/go.mod h1:RJ58z4rMp3gvETA465Vg+ag8BGgBdnRPEMMSTr5Uv+M=
cloud.google.com/go/datacatalog v1.12.0/go.mod h1:CWae8rFkfp6LzLumKOnmVh4+Zle4A3NXLzVJ1d1mRm0=
cloud.google.com/go/datacatalog v1.13.0/go.mod h1:E4Rj9a5ZtAxcQJlEBTLgMTphfP11/lNaAshpoBgemX8=
cloud.google.com/go/datacatalog v1.20.3 h1:lzMtWaUlaz9Bd9anvq2KBZwcFujzhVuxhIz1MsqRJv8=
cloud.google.com/go/datacatalog v1.20.3/go.mod h1:AKC6vAy5urnMg5eJK3oUjy8oa5zMbiY33h125l8lmlo=
cloud.google.com/go/dataflow v0.6.0/go.mod h1:9QwV89cGoxjjSR9/r7eFDqqjtvbKxAK2BaYU6PVk9UM=
cloud.google.com/go/dataflow v0.7.0/go.mod h1:PX526vb4ijFMesO1o202EaUmouZKBpjHsTlCtB4parQ=
cloud.google.com/go/dataflow v0.8.0/go.mod h1:Rcf5YgTKPtQyYz8bLYhFoIV/vP39eL7fWNcSOyFfLJE=
cloud.google.com/go/dataform v0.3.0/go.mod h1:cj8uNliRlHpa6L3yVhDOBrUXH+BPAO1+KFMQQNSThKo=
cloud.google.com/go/dataform v0.4.0/go.mod h1:fwV6Y4Ty2yIFL89huYlEkwUPtS7YZinZbzzj5S9FzCE=
cloud.google.com/go/dataform v0.5.0/go.mod h1:GFUYRe8IBa2hcomWplodVmUx/iTL0FrsauObOM3Ipr0=
cloud.google.com/go/dataform v0.6.0/go.mod h1:QPflImQy33e29VuapFdf19oPbE4aYTJxr31OAPV+ulA=
cloud.google.com/go/dataform v0.7.0/go.mod h1:7NulqnVozfHvWUBpMDfKMUESr+85aJsC/2O0o3jWPDE=
cloud.google.com/go/datafusion v1.4.0/go.mod h1:1Zb6VN+W6ALo85cXnM1IKiPw+yQMKMhB9TsTSRDo/38=
cloud.google.com/go/datafusion v1.5.0/go.mod h1:Kz+l1FGHB0J+4XF2fud96WMmRiq/wj8N9u007vyXZ2w=
cloud.google.com/go/datafusion v1.6.0/go.mod h1:WBsMF8F1RhSXvVM8rCV3AeyWVxcC2xY6vith3iw3S+8=
cloud.google.com/go/datalabeling v0.5.0/go.mod h1:TGcJ0G2NzcsXSE/97yWjIZO0bXj0KbVlINXMG9ud42I=
cloud.google.com/go/datalabeling v0.6.0/go.mod h1:WqdISuk/+WIGeMkpw/1q7bK/tFEZxsrFJOJdY2bXvTQ=
cloud.google.com/go/datalabeling v0.7.0/go.mod h1:WPQb1y08RJbmpM3ww0CSUAGweL0SxByuW2E+FU+wXcM=
cloud.google.com/go/dataplex v1.3.0/go.mod h1:hQuRtDg+fCiFgC8j0zV222HvzFQdRd+SVX8gdmFcZzA=
cloud.google.com/go/dataplex v1.4.0/go.mod h1:X51GfLXEMVJ6UN47ESVqvlsRplbLhcsAt0kZCCKsU0A=
cloud.google.com/go/dataplex v1.5.2/go.mod h1:cVMgQHsmfRoI5KFYq4JtIBEUbYwc3c7tXmIDhRmNNVQ=
cloud.google.com/go/dataplex v1.6.0/go.mod h1:bMsomC/aEJOSpHXdFKFGQ1b0TDPIeL28nJObeO1ppRs=
cloud.google.com/go/dataproc v1.7.0/go.mod h1:CKAlMjII9H90RXaMpSxQ8EU6dQx6iAYNPcYPOkSbi8s=
cloud.google.com/go/dataproc v1.8.0/go.mod h1:5OW+zNAH0pMpw14JVrPONsxMQYMBqJuzORhIBfBn9uI=
cloud.google.com/go/dataproc v1.12.0/go.mod h1:zrF3aX0uV3ikkMz6z4uBbIKyhRITnxvr4i3IjKsKrw4=
cloud.google.com/go/dataqna v0.5.0/go.mod h1:90Hyk596ft3zUQ8NkFfvICSIfHFh1Bc7C4cK3vbhkeo=
cloud.google.com/go/dataqna v0.6.0/go.mod h1:1lqNpM7rqNLVgWBJyk5NF6Uen2PHym0jtVJonplVsDA=
cloud.google.com/go/dataqna v0.7.0/go.mod h1:Lx9OcIIeqCrw1a6KdO3/5KMP1wAmTc0slZWwP12Qq3c=
cloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=
cloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=
cloud.google.com/go/datastore v1.10.0/go.mod h1:PC5UzAmDEkAmkfaknstTYbNpgE49HAgW2J1gcgUfmdM=
cloud.google.com/go/datastore v1.11.0/go.mod h1:TvGxBIHCS50u8jzG+AW/ppf87v1of8nwzFNgEZU1D3c=
cloud.google.com/go/datastore v1.17.1 h1:6Me8ugrAOAxssGhSo8im0YSuy4YvYk4mbGvCadAH5aE=
cloud.google.com/go/datastore v1.17.1/go.mod h1:mtzZ2HcVtz90OVrEXXGDc2pO4NM1kiBQy8YV4qGe0ZM=
cloud.google.com/go/datastream v1.2.0/go.mod h1:i/uTP8/fZwgATHS/XFu0TcNUhuA0twZxxQ3EyCUQMwo=
cloud.google.com/go/datastream v1.3.0/go.mod h1:cqlOX8xlyYF/uxhiKn6Hbv6WjwPPuI9W2M9SAXwaLLQ=
cloud.google.com/go/datastream v1.4.0/go.mod h1:h9dpzScPhDTs5noEMQVWP8Wx8AFBRyS0s8KWPx/9r0g=
cloud.google.com/go/datastream v1.5.0/go.mod h1:6TZMMNPwjUqZHBKPQ1wwXpb0d5VDVPl2/XoS5yi88q4=
cloud.google.com/go/datastream v1.6.0/go.mod h1:6LQSuswqLa7S4rPAOZFVjHIG3wJIjZcZrw8JDEDJuIs=
cloud.google.com/go/datastream v1.7.0/go.mod h1:uxVRMm2elUSPuh65IbZpzJNMbuzkcvu5CjMqVIUHrww=
cloud.google.com/go/deploy v1.4.0/go.mod h1:5Xghikd4VrmMLNaF6FiRFDlHb59VM59YoDQnOUdsH/c=
cloud.google.com/go/deploy v1.5.0/go.mod h1:ffgdD0B89tToyW/U/D2eL0jN2+IEV/3EMuXHA0l4r+s=
cloud.google.com/go/deploy v1.6.0/go.mod h1:f9PTHehG/DjCom3QH0cntOVRm93uGBDt2vKzAPwpXQI=
cloud.google.com/go/deploy v1.8.0/go.mod h1:z3myEJnA/2wnB4sgjqdMfgxCA0EqC3RBTNcVPs93mtQ=
cloud.google.com/go/dialogflow v1.15.0/go.mod h1:HbHDWs33WOGJgn6rfzBW1Kv807BE3O1+xGbn59zZWI4=
cloud.google.com/go/dialogflow v1.16.1/go.mod h1:po6LlzGfK+smoSmTBnbkIZY2w8ffjz/RcGSS+sh1el0=
cloud.google.com/go/dialogflow v1.17.0/go.mod h1:YNP09C/kXA1aZdBgC/VtXX74G/TKn7XVCcVumTflA+8=
cloud.google.com/go/dialogflow v1.18.0/go.mod h1:trO7Zu5YdyEuR+BhSNOqJezyFQ3aUzz0njv7sMx/iek=
cloud.google.com/go/dialogflow v1.19.0/go.mod h1:JVmlG1TwykZDtxtTXujec4tQ+D8SBFMoosgy+6Gn0s0=
cloud.google.com/go/dialogflow v1.29.0/go.mod h1:b+2bzMe+k1s9V+F2jbJwpHPzrnIyHihAdRFMtn2WXuM=
cloud.google.com/go/dialogflow v1.31.0/go.mod h1:cuoUccuL1Z+HADhyIA7dci3N5zUssgpBJmCzI6fNRB4=
cloud.google.com/go/dialogflow v1.32.0/go.mod h1:jG9TRJl8CKrDhMEcvfcfFkkpp8ZhgPz3sBGmAUYJ2qE=
cloud.google.com/go/dlp v1.6.0/go.mod h1:9eyB2xIhpU0sVwUixfBubDoRwP+GjeUoxxeueZmqvmM=
cloud.google.com/go/dlp v1.7.0/go.mod h1:68ak9vCiMBjbasxeVD17hVPxDEck+ExiHavX8kiHG+Q=
cloud.google.com/go/dlp v1.9.0/go.mod h1:qdgmqgTyReTz5/YNSSuueR8pl7hO0o9bQ39ZhtgkWp4=
cloud.google.com/go/documentai v1.7.0/go.mod h1:lJvftZB5NRiFSX4moiye1SMxHx0Bc3x1+p9e/RfXYiU=
cloud.google.com/go/documentai v1.8.0/go.mod h1:xGHNEB7CtsnySCNrCFdCyyMz44RhFEEX2Q7UD0c5IhU=
cloud.google.com/go/documentai v1.9.0/go.mod h1:FS5485S8R00U10GhgBC0aNGrJxBP8ZVpEeJ7PQDZd6k=
cloud.google.com/go/documentai v1.10.0/go.mod h1:vod47hKQIPeCfN2QS/jULIvQTugbmdc0ZvxxfQY1bg4=
cloud.google.com/go/documentai v1.16.0/go.mod h1:o0o0DLTEZ+YnJZ+J4wNfTxmDVyrkzFvttBXXtYRMHkM=
cloud.google.com/go/documentai v1.18.0/go.mod h1:F6CK6iUH8J81FehpskRmhLq/3VlwQvb7TvwOceQ2tbs=
cloud.google.com/go/domains v0.6.0/go.mod h1:T9Rz3GasrpYk6mEGHh4rymIhjlnIuB4ofT1wTxDeT4Y=
cloud.google.com/go/domains v0.7.0/go.mod h1:PtZeqS1xjnXuRPKE/88Iru/LdfoRyEHYA9nFQf4UKpg=
cloud.google.com/go/domains v0.8.0/go.mod h1:M9i3MMDzGFXsydri9/vW+EWz9sWb4I6WyHqdlAk0idE=
cloud.google.com/go/edgecontainer v0.1.0/go.mod h1:WgkZ9tp10bFxqO8BLPqv2LlfmQF1X8lZqwW4r1BTajk=
cloud.google.com/go/edgecontainer v0.2.0/go.mod h1:RTmLijy+lGpQ7BXuTDa4C4ssxyXT34NIuHIgKuP4s5w=
cloud.google.com/go/edgecontainer v0.3.0/go.mod h1:FLDpP4nykgwwIfcLt6zInhprzw0lEi2P1fjO6Ie0qbc=
cloud.google.com/go/edgecontainer v1.0.0/go.mod h1:cttArqZpBB2q58W/upSG++ooo6EsblxDIolxa3jSjbY=
cloud.google.com/go/errorreporting v0.3.0/go.mod h1:xsP2yaAp+OAW4OIm60An2bbLpqIhKXdWR/tawvl7QzU=
cloud.google.com/go/essentialcontacts v1.3.0/go.mod h1:r+OnHa5jfj90qIfZDO/VztSFqbQan7HV75p8sA+mdGI=
cloud.google.com/go/essentialcontacts v1.4.0/go.mod h1:8tRldvHYsmnBCHdFpvU+GL75oWiBKl80BiqlFh9tp+8=
cloud.google.com/go/essentialcontacts v1.5.0/go.mod h1:ay29Z4zODTuwliK7SnX8E86aUF2CTzdNtvv42niCX0M=
cloud.google.com/go/eventarc v1.7.0/go.mod h1:6ctpF3zTnaQCxUjHUdcfgcA1A2T309+omHZth7gDfmc=
cloud.google.com/go/eventarc v1.8.0/go.mod h1:imbzxkyAU4ubfsaKYdQg04WS1NvncblHEup4kvF+4gw=
cloud.google.com/go/eventarc v1.10.0/go.mod h1:u3R35tmZ9HvswGRBnF48IlYgYeBcPUCjkr4BTdem2Kw=
cloud.google.com/go/eventarc v1.11.0/go.mod h1:PyUjsUKPWoRBCHeOxZd/lbOOjahV41icXyUY5kSTvVY=
cloud.google.com/go/filestore v1.3.0/go.mod h1:+qbvHGvXU1HaKX2nD0WEPo92TP/8AQuCVEBXNY9z0+w=
cloud.google.com/go/filestore v1.4.0/go.mod h1:PaG5oDfo9r224f8OYXURtAsY+Fbyq/bLYoINEK8XQAI=
cloud.google.com/go/filestore v1.5.0/go.mod h1:FqBXDWBp4YLHqRnVGveOkHDf8svj9r5+mUDLupOWEDs=
cloud.google.com/go/filestore v1.6.0/go.mod h1:di5unNuss/qfZTw2U9nhFqo8/ZDSc466dre85Kydllg=
cloud.google.com/go/firestore v1.9.0/go.mod h1:HMkjKHNTtRyZNiMzu7YAsLr9K3X2udY2AMwDaMEQiiE=
cloud.google.com/go/firestore v1.15.0 h1:/k8ppuWOtNuDHt2tsRV42yI21uaGnKDEQnRFeBpbFF8=
cloud.google.com/go/firestore v1.15.0/go.mod h1:GWOxFXcv8GZUtYpWHw/w6IuYNux/BtmeVTMmjrm4yhk=
cloud.google.com/go/functions v1.6.0/go.mod h1:3H1UA3qiIPRWD7PeZKLvHZ9SaQhR26XIJcC0A5GbvAk=
cloud.google.com/go/functions v1.7.0/go.mod h1:+d+QBcWM+RsrgZfV9xo6KfA1GlzJfxcfZcRPEhDDfzg=
cloud.google.com/go/functions v1.8.0/go.mod h1:RTZ4/HsQjIqIYP9a9YPbU+QFoQsAlYgrwOXJWHn1POY=
cloud.google.com/go/functions v1.9.0/go.mod h1:Y+Dz8yGguzO3PpIjhLTbnqV1CWmgQ5UwtlpzoyquQ08=
cloud.google.com/go/functions v1.10.0/go.mod h1:0D3hEOe3DbEvCXtYOZHQZmD+SzYsi1YbI7dGvHfldXw=
cloud.google.com/go/functions v1.12.0/go.mod h1:AXWGrF3e2C/5ehvwYo/GH6O5s09tOPksiKhz+hH8WkA=
cloud.google.com/go/functions v1.13.0/go.mod h1:EU4O007sQm6Ef/PwRsI8N2umygGqPBS/IZQKBQBcJ3c=
cloud.google.com/go/gaming v1.5.0/go.mod h1:ol7rGcxP/qHTRQE/RO4bxkXq+Fix0j6D4LFPzYTIrDM=
cloud.google.com/go/gaming v1.6.0/go.mod h1:YMU1GEvA39Qt3zWGyAVA9bpYz/yAhTvaQ1t2sK4KPUA=
cloud.google.com/go/gaming v1.7.0/go.mod h1:LrB8U7MHdGgFG851iHAfqUdLcKBdQ55hzXy9xBJz0+w=
cloud.google.com/go/gaming v1.8.0/go.mod h1:xAqjS8b7jAVW0KFYeRUxngo9My3f33kFmua++Pi+ggM=
cloud.google.com/go/gaming v1.9.0/go.mod h1:Fc7kEmCObylSWLO334NcO+O9QMDyz+TKC4v1D7X+Bc0=
cloud.google.com/go/gkebackup v0.2.0/go.mod h1:XKvv/4LfG829/B8B7xRkk8zRrOEbKtEam6yNfuQNH60=
cloud.google.com/go/gkebackup v0.3.0/go.mod h1:n/E671i1aOQvUxT541aTkCwExO/bTer2HDlj4TsBRAo=
cloud.google.com/go/gkebackup v0.4.0/go.mod h1:byAyBGUwYGEEww7xsbnUTBHIYcOPy/PgUWUtOeRm9Vg=
cloud.google.com/go/gkeconnect v0.5.0/go.mod h1:c5lsNAg5EwAy7fkqX/+goqFsU1Da/jQFqArp+wGNr/o=
cloud.google.com/go/gkeconnect v0.6.0/go.mod h1:Mln67KyU/sHJEBY8kFZ0xTeyPtzbq9StAVvEULYK16A=
cloud.google.com/go/gkeconnect v0.7.0/go.mod h1:SNfmVqPkaEi3bF/B3CNZOAYPYdg7sU+obZ+QTky2Myw=
cloud.google.com/go/gkehub v0.9.0/go.mod h1:WYHN6WG8w9bXU0hqNxt8rm5uxnk8IH+lPY9J2TV7BK0=
cloud.google.com/go/gkehub v0.10.0/go.mod h1:UIPwxI0DsrpsVoWpLB0stwKCP+WFVG9+y977wO+hBH0=
cloud.google.com/go/gkehub v0.11.0/go.mod h1:JOWHlmN+GHyIbuWQPl47/C2RFhnFKH38jH9Ascu3n0E=
cloud.google.com/go/gkehub v0.12.0/go.mod h1:djiIwwzTTBrF5NaXCGv3mf7klpEMcST17VBTVVDcuaw=
cloud.google.com/go/gkemulticloud v0.3.0/go.mod h1:7orzy7O0S+5kq95e4Hpn7RysVA7dPs8W/GgfUtsPbrA=
cloud.google.com/go/gkemulticloud v0.4.0/go.mod h1:E9gxVBnseLWCk24ch+P9+B2CoDFJZTyIgLKSalC7tuI=
cloud.google.com/go/gkemulticloud v0.5.0/go.mod h1:W0JDkiyi3Tqh0TJr//y19wyb1yf8llHVto2Htf2Ja3Y=
cloud.google.com/go/grafeas v0.2.0/go.mod h1:KhxgtF2hb0P191HlY5besjYm6MqTSTj3LSI+M+ByZHc=
cloud.google.com/go/gsuiteaddons v1.3.0/go.mod h1:EUNK/J1lZEZO8yPtykKxLXI6JSVN2rg9bN8SXOa0bgM=
cloud.google.com/go/gsuiteaddons v1.4.0/go.mod h1:rZK5I8hht7u7HxFQcFei0+AtfS9uSushomRlg+3ua1o=
cloud.google.com/go/gsuiteaddons v1.5.0/go.mod h1:TFCClYLd64Eaa12sFVmUyG62tk4mdIsI7pAnSXRkcFo=
cloud.google.com/go/iam v0.1.0/go.mod h1:vcUNEa0pEm0qRVpmWepWaFMIAI8/hjB9mO8rNCJtF6c=
cloud.google.com/go/iam v0.3.0/go.mod h1:XzJPvDayI+9zsASAFO68Hk07u3z+f+JrT2xXNdp4bnY=
cloud.google.com/go/iam v0.5.0/go.mod h1:wPU9Vt0P4UmCux7mqtRu6jcpPAb74cP1fh50J3QpkUc=
cloud.google.com/go/iam v0.6.0/go.mod h1:+1AH33ueBne5MzYccyMHtEKqLE4/kJOibtffMHDMFMc=
cloud.google.com/go/iam v0.7.0/go.mod h1:H5Br8wRaDGNc8XP3keLc4unfUUZeyH3Sfl9XpQEYOeg=
cloud.google.com/go/iam v0.8.0/go.mod h1:lga0/y3iH6CX7sYqypWJ33hf7kkfXJag67naqGESjkE=
cloud.google.com/go/iam v0.11.0/go.mod h1:9PiLDanza5D+oWFZiH1uG+RnRCfEGKoyl6yo4cgWZGY=
cloud.google.com/go/iam v0.12.0/go.mod h1:knyHGviacl11zrtZUoDuYpDgLjvr28sLQaG0YB2GYAY=
cloud.google.com/go/iam v0.13.0/go.mod h1:ljOg+rcNfzZ5d6f1nAUJ8ZIxOaZUVoS14bKCtaLZ/D0=
cloud.google.com/go/iam v1.1.10 h1:ZSAr64oEhQSClwBL670MsJAW5/RLiC6kfw3Bqmd5ZDI=
cloud.google.com/go/iam v1.1.10/go.mod h1:iEgMq62sg8zx446GCaijmA2Miwg5o3UbO+nI47WHJps=
cloud.google.com/go/iap v1.4.0/go.mod h1:RGFwRJdihTINIe4wZ2iCP0zF/qu18ZwyKxrhMhygBEc=
cloud.google.com/go/iap v1.5.0/go.mod h1:UH/CGgKd4KyohZL5Pt0jSKE4m3FR51qg6FKQ/z/Ix9A=
cloud.google.com/go/iap v1.6.0/go.mod h1:NSuvI9C/j7UdjGjIde7t7HBz+QTwBcapPE07+sSRcLk=
cloud.google.com/go/iap v1.7.0/go.mod h1:beqQx56T9O1G1yNPph+spKpNibDlYIiIixiqsQXxLIo=
cloud.google.com/go/iap v1.7.1/go.mod h1:WapEwPc7ZxGt2jFGB/C/bm+hP0Y6NXzOYGjpPnmMS74=
cloud.google.com/go/ids v1.1.0/go.mod h1:WIuwCaYVOzHIj2OhN9HAwvW+DBdmUAdcWlFxRl+KubM=
cloud.google.com/go/ids v1.2.0/go.mod h1:5WXvp4n25S0rA/mQWAg1YEEBBq6/s+7ml1RDCW1IrcY=
cloud.google.com/go/ids v1.3.0/go.mod h1:JBdTYwANikFKaDP6LtW5JAi4gubs57SVNQjemdt6xV4=
cloud.google.com/go/iot v1.3.0/go.mod h1:r7RGh2B61+B8oz0AGE+J72AhA0G7tdXItODWsaA2oLs=
cloud.google.com/go/iot v1.4.0/go.mod h1:dIDxPOn0UvNDUMD8Ger7FIaTuvMkj+aGk94RPP0iV+g=
cloud.google.com/go/iot v1.5.0/go.mod h1:mpz5259PDl3XJthEmh9+ap0affn/MqNSP4My77Qql9o=
cloud.google.com/go/iot v1.6.0/go.mod h1:IqdAsmE2cTYYNO1Fvjfzo9po179rAtJeVGUvkLN3rLE=
cloud.google.com/go/kms v1.4.0/go.mod h1:fajBHndQ+6ubNw6Ss2sSd+SWvjL26RNo/dr7uxsnnOA=
cloud.google.com/go/kms v1.5.0/go.mod h1:QJS2YY0eJGBg3mnDfuaCyLauWwBJiHRboYxJ++1xJNg=
cloud.google.com/go/kms v1.6.0/go.mod h1:Jjy850yySiasBUDi6KFUwUv2n1+o7QZFyuUJg6OgjA0=
cloud.google.com/go/kms v1.8.0/go.mod h1:4xFEhYFqvW+4VMELtZyxomGSYtSQKzM178ylFW4jMAg=
cloud.google.com/go/kms v1.9.0/go.mod h1:qb1tPTgfF9RQP8e1wq4cLFErVuTJv7UsSC915J8dh3w=
cloud.google.com/go/kms v1.10.0/go.mod h1:ng3KTUtQQU9bPX3+QGLsflZIHlkbn8amFAMY63m8d24=
cloud.google.com/go/kms v1.10.1/go.mod h1:rIWk/TryCkR59GMC3YtHtXeLzd634lBbKenvyySAyYI=
cloud.google.com/go/language v1.4.0/go.mod h1:F9dRpNFQmJbkaop6g0JhSBXCNlO90e1KWx5iDdxbWic=
cloud.google.com/go/language v1.6.0/go.mod h1:6dJ8t3B+lUYfStgls25GusK04NLh3eDLQnWM3mdEbhI=
cloud.google.com/go/language v1.7.0/go.mod h1:DJ6dYN/W+SQOjF8e1hLQXMF21AkH2w9wiPzPCJa2MIE=
cloud.google.com/go/language v1.8.0/go.mod h1:qYPVHf7SPoNNiCL2Dr0FfEFNil1qi3pQEyygwpgVKB8=
cloud.google.com/go/language v1.9.0/go.mod h1:Ns15WooPM5Ad/5no/0n81yUetis74g3zrbeJBE+ptUY=
cloud.google.com/go/lifesciences v0.5.0/go.mod h1:3oIKy8ycWGPUyZDR/8RNnTOYevhaMLqh5vLUXs9zvT8=
cloud.google.com/go/lifesciences v0.6.0/go.mod h1:ddj6tSX/7BOnhxCSd3ZcETvtNr8NZ6t/iPhY2Tyfu08=
cloud.google.com/go/lifesciences v0.8.0/go.mod h1:lFxiEOMqII6XggGbOnKiyZ7IBwoIqA84ClvoezaA/bo=
cloud.google.com/go/logging v1.6.1/go.mod h1:5ZO0mHHbvm8gEmeEUHrmDlTDSu5imF6MUP9OfilNXBw=
cloud.google.com/go/logging v1.7.0/go.mod h1:3xjP2CjkM3ZkO73aj4ASA5wRPGGCRrPIAeNqVNkzY8M=
cloud.google.com/go/longrunning v0.1.1/go.mod h1:UUFxuDWkv22EuY93jjmDMFT5GPQKeFVJBIF6QlTqdsE=
cloud.google.com/go/longrunning v0.3.0/go.mod h1:qth9Y41RRSUE69rDcOn6DdK3HfQfsUI0YSmW3iIlLJc=
cloud.google.com/go/longrunning v0.4.1/go.mod h1:4iWDqhBZ70CvZ6BfETbvam3T8FMvLK+eFj0E6AaRQTo=
cloud.google.com/go/longrunning v0.5.9 h1:haH9pAuXdPAMqHvzX0zlWQigXT7B0+CL4/2nXXdBo5k=
cloud.google.com/go/longrunning v0.5.9/go.mod h1:HD+0l9/OOW0za6UWdKJtXoFAX/BGg/3Wj8p10NeWF7c=
cloud.google.com/go/managedidentities v1.3.0/go.mod h1:UzlW3cBOiPrzucO5qWkNkh0w33KFtBJU281hacNvsdE=
cloud.google.com/go/managedidentities v1.4.0/go.mod h1:NWSBYbEMgqmbZsLIyKvxrYbtqOsxY1ZrGM+9RgDqInM=
cloud.google.com/go/managedidentities v1.5.0/go.mod h1:+dWcZ0JlUmpuxpIDfyP5pP5y0bLdRwOS4Lp7gMni/LA=
cloud.google.com/go/maps v0.1.0/go.mod h1:BQM97WGyfw9FWEmQMpZ5T6cpovXXSd1cGmFma94eubI=
cloud.google.com/go/maps v0.6.0/go.mod h1:o6DAMMfb+aINHz/p/jbcY+mYeXBoZoxTfdSQ8VAJaCw=
cloud.google.com/go/maps v0.7.0/go.mod h1:3GnvVl3cqeSvgMcpRlQidXsPYuDGQ8naBis7MVzpXsY=
cloud.google.com/go/mediatranslation v0.5.0/go.mod h1:jGPUhGTybqsPQn91pNXw0xVHfuJ3leR1wj37oU3y1f4=
cloud.google.com/go/mediatranslation v0.6.0/go.mod h1:hHdBCTYNigsBxshbznuIMFNe5QXEowAuNmmC7h8pu5w=
cloud.google.com/go/mediatranslation v0.7.0/go.mod h1:LCnB/gZr90ONOIQLgSXagp8XUW1ODs2UmUMvcgMfI2I=
cloud.google.com/go/memcache v1.4.0/go.mod h1:rTOfiGZtJX1AaFUrOgsMHX5kAzaTQ8azHiuDoTPzNsE=
cloud.google.com/go/memcache v1.5.0/go.mod h1:dk3fCK7dVo0cUU2c36jKb4VqKPS22BTkf81Xq617aWM=
cloud.google.com/go/memcache v1.6.0/go.mod h1:XS5xB0eQZdHtTuTF9Hf8eJkKtR3pVRCcvJwtm68T3rA=
cloud.google.com/go/memcache v1.7.0/go.mod h1:ywMKfjWhNtkQTxrWxCkCFkoPjLHPW6A7WOTVI8xy3LY=
cloud.google.com/go/memcache v1.9.0/go.mod h1:8oEyzXCu+zo9RzlEaEjHl4KkgjlNDaXbCQeQWlzNFJM=
cloud.google.com/go/metastore v1.5.0/go.mod h1:2ZNrDcQwghfdtCwJ33nM0+GrBGlVuh8rakL3vdPY3XY=
cloud.google.com/go/metastore v1.6.0/go.mod h1:6cyQTls8CWXzk45G55x57DVQ9gWg7RiH65+YgPsNh9s=
cloud.google.com/go/metastore v1.7.0/go.mod h1:s45D0B4IlsINu87/AsWiEVYbLaIMeUSoxlKKDqBGFS8=
cloud.google.com/go/metastore v1.8.0/go.mod h1:zHiMc4ZUpBiM7twCIFQmJ9JMEkDSyZS9U12uf7wHqSI=
cloud.google.com/go/metastore v1.10.0/go.mod h1:fPEnH3g4JJAk+gMRnrAnoqyv2lpUCqJPWOodSaf45Eo=
cloud.google.com/go/monitoring v1.7.0/go.mod h1:HpYse6kkGo//7p6sT0wsIC6IBDET0RhIsnmlA53dvEk=
cloud.google.com/go/monitoring v1.8.0/go.mod h1:E7PtoMJ1kQXWxPjB6mv2fhC5/15jInuulFdYYtlcvT4=
cloud.google.com/go/monitoring v1.12.0/go.mod h1:yx8Jj2fZNEkL/GYZyTLS4ZtZEZN8WtDEiEqG4kLK50w=
cloud.google.com/go/monitoring v1.13.0/go.mod h1:k2yMBAB1H9JT/QETjNkgdCGD9bPF712XiLTVr+cBrpw=
cloud.google.com/go/networkconnectivity v1.4.0/go.mod h1:nOl7YL8odKyAOtzNX73/M5/mGZgqqMeryi6UPZTk/rA=
cloud.google.com/go/networkconnectivity v1.5.0/go.mod h1:3GzqJx7uhtlM3kln0+x5wyFvuVH1pIBJjhCpjzSt75o=
cloud.google.com/go/networkconnectivity v1.6.0/go.mod h1:OJOoEXW+0LAxHh89nXd64uGG+FbQoeH8DtxCHVOMlaM=
cloud.google.com/go/networkconnectivity v1.7.0/go.mod h1:RMuSbkdbPwNMQjB5HBWD5MpTBnNm39iAVpC3TmsExt8=
cloud.google.com/go/networkconnectivity v1.10.0/go.mod h1:UP4O4sWXJG13AqrTdQCD9TnLGEbtNRqjuaaA7bNjF5E=
cloud.google.com/go/networkconnectivity v1.11.0/go.mod h1:iWmDD4QF16VCDLXUqvyspJjIEtBR/4zq5hwnY2X3scM=
cloud.google.com/go/networkmanagement v1.4.0/go.mod h1:Q9mdLLRn60AsOrPc8rs8iNV6OHXaGcDdsIQe1ohekq8=
cloud.google.com/go/networkmanagement v1.5.0/go.mod h1:ZnOeZ/evzUdUsnvRt792H0uYEnHQEMaz+REhhzJRcf4=
cloud.google.com/go/networkmanagement v1.6.0/go.mod h1:5pKPqyXjB/sgtvB5xqOemumoQNB7y95Q7S+4rjSOPYY=
cloud.google.com/go/networksecurity v0.5.0/go.mod h1:xS6fOCoqpVC5zx15Z/MqkfDwH4+m/61A3ODiDV1xmiQ=
cloud.google.com/go/networksecurity v0.6.0/go.mod h1:Q5fjhTr9WMI5mbpRYEbiexTzROf7ZbDzvzCrNl14nyU=
cloud.google.com/go/networksecurity v0.7.0/go.mod h1:mAnzoxx/8TBSyXEeESMy9OOYwo1v+gZ5eMRnsT5bC8k=
cloud.google.com/go/networksecurity v0.8.0/go.mod h1:B78DkqsxFG5zRSVuwYFRZ9Xz8IcQ5iECsNrPn74hKHU=
cloud.google.com/go/notebooks v1.2.0/go.mod h1:9+wtppMfVPUeJ8fIWPOq1UnATHISkGXGqTkxeieQ6UY=
cloud.google.com/go/notebooks v1.3.0/go.mod h1:bFR5lj07DtCPC7YAAJ//vHskFBxA5JzYlH68kXVdk34=
cloud.google.com/go/notebooks v1.4.0/go.mod h1:4QPMngcwmgb6uw7Po99B2xv5ufVoIQ7nOGDyL4P8AgA=
cloud.google.com/go/notebooks v1.5.0/go.mod h1:q8mwhnP9aR8Hpfnrc5iN5IBhrXUy8S2vuYs+kBJ/gu0=
cloud.google.com/go/notebooks v1.7.0/go.mod h1:PVlaDGfJgj1fl1S3dUwhFMXFgfYGhYQt2164xOMONmE=
cloud.google.com/go/notebooks v1.8.0/go.mod h1:Lq6dYKOYOWUCTvw5t2q1gp1lAp0zxAxRycayS0iJcqQ=
cloud.google.com/go/optimization v1.1.0/go.mod h1:5po+wfvX5AQlPznyVEZjGJTMr4+CAkJf2XSTQOOl9l4=
cloud.google.com/go/optimization v1.2.0/go.mod h1:Lr7SOHdRDENsh+WXVmQhQTrzdu9ybg0NecjHidBq6xs=
cloud.google.com/go/optimization v1.3.1/go.mod h1:IvUSefKiwd1a5p0RgHDbWCIbDFgKuEdB+fPPuP0IDLI=
cloud.google.com/go/orchestration v1.3.0/go.mod h1:Sj5tq/JpWiB//X/q3Ngwdl5K7B7Y0KZ7bfv0wL6fqVA=
cloud.google.com/go/orchestration v1.4.0/go.mod h1:6W5NLFWs2TlniBphAViZEVhrXRSMgUGDfW7vrWKvsBk=
cloud.google.com/go/orchestration v1.6.0/go.mod h1:M62Bevp7pkxStDfFfTuCOaXgaaqRAga1yKyoMtEoWPQ=
cloud.google.com/go/orgpolicy v1.4.0/go.mod h1:xrSLIV4RePWmP9P3tBl8S93lTmlAxjm06NSm2UTmKvE=
cloud.google.com/go/orgpolicy v1.5.0/go.mod h1:hZEc5q3wzwXJaKrsx5+Ewg0u1LxJ51nNFlext7Tanwc=
cloud.google.com/go/orgpolicy v1.10.0/go.mod h1:w1fo8b7rRqlXlIJbVhOMPrwVljyuW5mqssvBtU18ONc=
cloud.google.com/go/osconfig v1.7.0/go.mod h1:oVHeCeZELfJP7XLxcBGTMBvRO+1nQ5tFG9VQTmYS2Fs=
cloud.google.com/go/osconfig v1.8.0/go.mod h1:EQqZLu5w5XA7eKizepumcvWx+m8mJUhEwiPqWiZeEdg=
cloud.google.com/go/osconfig v1.9.0/go.mod h1:Yx+IeIZJ3bdWmzbQU4fxNl8xsZ4amB+dygAwFPlvnNo=
cloud.google.com/go/osconfig v1.10.0/go.mod h1:uMhCzqC5I8zfD9zDEAfvgVhDS8oIjySWh+l4WK6GnWw=
cloud.google.com/go/osconfig v1.11.0/go.mod h1:aDICxrur2ogRd9zY5ytBLV89KEgT2MKB2L/n6x1ooPw=
cloud.google.com/go/oslogin v1.4.0/go.mod h1:YdgMXWRaElXz/lDk1Na6Fh5orF7gvmJ0FGLIs9LId4E=
cloud.google.com/go/oslogin v1.5.0/go.mod h1:D260Qj11W2qx/HVF29zBg+0fd6YCSjSqLUkY/qEenQU=
cloud.google.com/go/oslogin v1.6.0/go.mod h1:zOJ1O3+dTU8WPlGEkFSh7qeHPPSoxrcMbbK1Nm2iX70=
cloud.google.com/go/oslogin v1.7.0/go.mod h1:e04SN0xO1UNJ1M5GP0vzVBFicIe4O53FOfcixIqTyXo=
cloud.google.com/go/oslogin v1.9.0/go.mod h1:HNavntnH8nzrn8JCTT5fj18FuJLFJc4NaZJtBnQtKFs=
cloud.google.com/go/phishingprotection v0.5.0/go.mod h1:Y3HZknsK9bc9dMi+oE8Bim0lczMU6hrX0UpADuMefr0=
cloud.google.com/go/phishingprotection v0.6.0/go.mod h1:9Y3LBLgy0kDTcYET8ZH3bq/7qni15yVUoAxiFxnlSUA=
cloud.google.com/go/phishingprotection v0.7.0/go.mod h1:8qJI4QKHoda/sb/7/YmMQ2omRLSLYSu9bU0EKCNI+Lk=
cloud.google.com/go/policytroubleshooter v1.3.0/go.mod h1:qy0+VwANja+kKrjlQuOzmlvscn4RNsAc0e15GGqfMxg=
cloud.google.com/go/policytroubleshooter v1.4.0/go.mod h1:DZT4BcRw3QoO8ota9xw/LKtPa8lKeCByYeKTIf/vxdE=
cloud.google.com/go/policytroubleshooter v1.5.0/go.mod h1:Rz1WfV+1oIpPdN2VvvuboLVRsB1Hclg3CKQ53j9l8vw=
cloud.google.com/go/policytroubleshooter v1.6.0/go.mod h1:zYqaPTsmfvpjm5ULxAyD/lINQxJ0DDsnWOP/GZ7xzBc=
cloud.google.com/go/privatecatalog v0.5.0/go.mod h1:XgosMUvvPyxDjAVNDYxJ7wBW8//hLDDYmnsNcMGq1K0=
cloud.google.com/go/privatecatalog v0.6.0/go.mod h1:i/fbkZR0hLN29eEWiiwue8Pb+GforiEIBnV9yrRUOKI=
cloud.google.com/go/privatecatalog v0.7.0/go.mod h1:2s5ssIFO69F5csTXcwBP7NPFTZvps26xGzvQ2PQaBYg=
cloud.google.com/go/privatecatalog v0.8.0/go.mod h1:nQ6pfaegeDAq/Q5lrfCQzQLhubPiZhSaNhIgfJlnIXs=
cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=
cloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=
cloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=
cloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=
cloud.google.com/go/pubsub v1.26.0/go.mod h1:QgBH3U/jdJy/ftjPhTkyXNj543Tin1pRYcdcPRnFIRI=
cloud.google.com/go/pubsub v1.27.1/go.mod h1:hQN39ymbV9geqBnfQq6Xf63yNhUAhv9CZhzp5O6qsW0=
cloud.google.com/go/pubsub v1.28.0/go.mod h1:vuXFpwaVoIPQMGXqRyUQigu/AX1S3IWugR9xznmcXX8=
cloud.google.com/go/pubsub v1.30.0/go.mod h1:qWi1OPS0B+b5L+Sg6Gmc9zD1Y+HaM0MdUr7LsupY1P4=
cloud.google.com/go/pubsub v1.40.0 h1:0LdP+zj5XaPAGtWr2V6r88VXJlmtaB/+fde1q3TU8M0=
cloud.google.com/go/pubsub v1.40.0/go.mod h1:BVJI4sI2FyXp36KFKvFwcfDRDfR8MiLT8mMhmIhdAeA=
cloud.google.com/go/pubsublite v1.5.0/go.mod h1:xapqNQ1CuLfGi23Yda/9l4bBCKz/wC3KIJ5gKcxveZg=
cloud.google.com/go/pubsublite v1.6.0/go.mod h1:1eFCS0U11xlOuMFV/0iBqw3zP12kddMeCbj/F3FSj9k=
cloud.google.com/go/pubsublite v1.7.0/go.mod h1:8hVMwRXfDfvGm3fahVbtDbiLePT3gpoiJYJY+vxWxVM=
cloud.google.com/go/recaptchaenterprise v1.3.1/go.mod h1:OdD+q+y4XGeAlxRaMn1Y7/GveP6zmq76byL6tjPE7d4=
cloud.google.com/go/recaptchaenterprise/v2 v2.1.0/go.mod h1:w9yVqajwroDNTfGuhmOjPDN//rZGySaf6PtFVcSCa7o=
cloud.google.com/go/recaptchaenterprise/v2 v2.2.0/go.mod h1:/Zu5jisWGeERrd5HnlS3EUGb/D335f9k51B/FVil0jk=
cloud.google.com/go/recaptchaenterprise/v2 v2.3.0/go.mod h1:O9LwGCjrhGHBQET5CA7dd5NwwNQUErSgEDit1DLNTdo=
cloud.google.com/go/recaptchaenterprise/v2 v2.4.0/go.mod h1:Am3LHfOuBstrLrNCBrlI5sbwx9LBg3te2N6hGvHn2mE=
cloud.google.com/go/recaptchaenterprise/v2 v2.5.0/go.mod h1:O8LzcHXN3rz0j+LBC91jrwI3R+1ZSZEWrfL7XHgNo9U=
cloud.google.com/go/recaptchaenterprise/v2 v2.6.0/go.mod h1:RPauz9jeLtB3JVzg6nCbe12qNoaa8pXc4d/YukAmcnA=
cloud.google.com/go/recaptchaenterprise/v2 v2.7.0/go.mod h1:19wVj/fs5RtYtynAPJdDTb69oW0vNHYDBTbB4NvMD9c=
cloud.google.com/go/recommendationengine v0.5.0/go.mod h1:E5756pJcVFeVgaQv3WNpImkFP8a+RptV6dDLGPILjvg=
cloud.google.com/go/recommendationengine v0.6.0/go.mod h1:08mq2umu9oIqc7tDy8sx+MNJdLG0fUi3vaSVbztHgJ4=
cloud.google.com/go/recommendationengine v0.7.0/go.mod h1:1reUcE3GIu6MeBz/h5xZJqNLuuVjNg1lmWMPyjatzac=
cloud.google.com/go/recommender v1.5.0/go.mod h1:jdoeiBIVrJe9gQjwd759ecLJbxCDED4A6p+mqoqDvTg=
cloud.google.com/go/recommender v1.6.0/go.mod h1:+yETpm25mcoiECKh9DEScGzIRyDKpZ0cEhWGo+8bo+c=
cloud.google.com/go/recommender v1.7.0/go.mod h1:XLHs/W+T8olwlGOgfQenXBTbIseGclClff6lhFVe9Bs=
cloud.google.com/go/recommender v1.8.0/go.mod h1:PkjXrTT05BFKwxaUxQmtIlrtj0kph108r02ZZQ5FE70=
cloud.google.com/go/recommender v1.9.0/go.mod h1:PnSsnZY7q+VL1uax2JWkt/UegHssxjUVVCrX52CuEmQ=
cloud.google.com/go/redis v1.7.0/go.mod h1:V3x5Jq1jzUcg+UNsRvdmsfuFnit1cfe3Z/PGyq/lm4Y=
cloud.google.com/go/redis v1.8.0/go.mod h1:Fm2szCDavWzBk2cDKxrkmWBqoCiL1+Ctwq7EyqBCA/A=
cloud.google.com/go/redis v1.9.0/go.mod h1:HMYQuajvb2D0LvMgZmLDZW8V5aOC/WxstZHiy4g8OiA=
cloud.google.com/go/redis v1.10.0/go.mod h1:ThJf3mMBQtW18JzGgh41/Wld6vnDDc/F/F35UolRZPM=
cloud.google.com/go/redis v1.11.0/go.mod h1:/X6eicana+BWcUda5PpwZC48o37SiFVTFSs0fWAJ7uQ=
cloud.google.com/go/resourcemanager v1.3.0/go.mod h1:bAtrTjZQFJkiWTPDb1WBjzvc6/kifjj4QBYuKCCoqKA=
cloud.google.com/go/resourcemanager v1.4.0/go.mod h1:MwxuzkumyTX7/a3n37gmsT3py7LIXwrShilPh3P1tR0=
cloud.google.com/go/resourcemanager v1.5.0/go.mod h1:eQoXNAiAvCf5PXxWxXjhKQoTMaUSNrEfg+6qdf/wots=
cloud.google.com/go/resourcemanager v1.6.0/go.mod h1:YcpXGRs8fDzcUl1Xw8uOVmI8JEadvhRIkoXXUNVYcVo=
cloud.google.com/go/resourcemanager v1.7.0/go.mod h1:HlD3m6+bwhzj9XCouqmeiGuni95NTrExfhoSrkC/3EI=
cloud.google.com/go/resourcesettings v1.3.0/go.mod h1:lzew8VfESA5DQ8gdlHwMrqZs1S9V87v3oCnKCWoOuQU=
cloud.google.com/go/resourcesettings v1.4.0/go.mod h1:ldiH9IJpcrlC3VSuCGvjR5of/ezRrOxFtpJoJo5SmXg=
cloud.google.com/go/resourcesettings v1.5.0/go.mod h1:+xJF7QSG6undsQDfsCJyqWXyBwUoJLhetkRMDRnIoXA=
cloud.google.com/go/retail v1.8.0/go.mod h1:QblKS8waDmNUhghY2TI9O3JLlFk8jybHeV4BF19FrE4=
cloud.google.com/go/retail v1.9.0/go.mod h1:g6jb6mKuCS1QKnH/dpu7isX253absFl6iE92nHwlBUY=
cloud.google.com/go/retail v1.10.0/go.mod h1:2gDk9HsL4HMS4oZwz6daui2/jmKvqShXKQuB2RZ+cCc=
cloud.google.com/go/retail v1.11.0/go.mod h1:MBLk1NaWPmh6iVFSz9MeKG/Psyd7TAgm6y/9L2B4x9Y=
cloud.google.com/go/retail v1.12.0/go.mod h1:UMkelN/0Z8XvKymXFbD4EhFJlYKRx1FGhQkVPU5kF14=
cloud.google.com/go/run v0.2.0/go.mod h1:CNtKsTA1sDcnqqIFR3Pb5Tq0usWxJJvsWOCPldRU3Do=
cloud.google.com/go/run v0.3.0/go.mod h1:TuyY1+taHxTjrD0ZFk2iAR+xyOXEA0ztb7U3UNA0zBo=
cloud.google.com/go/run v0.8.0/go.mod h1:VniEnuBwqjigv0A7ONfQUaEItaiCRVujlMqerPPiktM=
cloud.google.com/go/run v0.9.0/go.mod h1:Wwu+/vvg8Y+JUApMwEDfVfhetv30hCG4ZwDR/IXl2Qg=
cloud.google.com/go/scheduler v1.4.0/go.mod h1:drcJBmxF3aqZJRhmkHQ9b3uSSpQoltBPGPxGAWROx6s=
cloud.google.com/go/scheduler v1.5.0/go.mod h1:ri073ym49NW3AfT6DZi21vLZrG07GXr5p3H1KxN5QlI=
cloud.google.com/go/scheduler v1.6.0/go.mod h1:SgeKVM7MIwPn3BqtcBntpLyrIJftQISRrYB5ZtT+KOk=
cloud.google.com/go/scheduler v1.7.0/go.mod h1:jyCiBqWW956uBjjPMMuX09n3x37mtyPJegEWKxRsn44=
cloud.google.com/go/scheduler v1.8.0/go.mod h1:TCET+Y5Gp1YgHT8py4nlg2Sew8nUHMqcpousDgXJVQc=
cloud.google.com/go/scheduler v1.9.0/go.mod h1:yexg5t+KSmqu+njTIh3b7oYPheFtBWGcbVUYF1GGMIc=
cloud.google.com/go/secretmanager v1.6.0/go.mod h1:awVa/OXF6IiyaU1wQ34inzQNc4ISIDIrId8qE5QGgKA=
cloud.google.com/go/secretmanager v1.8.0/go.mod h1:hnVgi/bN5MYHd3Gt0SPuTPPp5ENina1/LxM+2W9U9J4=
cloud.google.com/go/secretmanager v1.9.0/go.mod h1:b71qH2l1yHmWQHt9LC80akm86mX8AL6X1MA01dW8ht4=
cloud.google.com/go/secretmanager v1.10.0/go.mod h1:MfnrdvKMPNra9aZtQFvBcvRU54hbPD8/HayQdlUgJpU=
cloud.google.com/go/security v1.5.0/go.mod h1:lgxGdyOKKjHL4YG3/YwIL2zLqMFCKs0UbQwgyZmfJl4=
cloud.google.com/go/security v1.7.0/go.mod h1:mZklORHl6Bg7CNnnjLH//0UlAlaXqiG7Lb9PsPXLfD0=
cloud.google.com/go/security v1.8.0/go.mod h1:hAQOwgmaHhztFhiQ41CjDODdWP0+AE1B3sX4OFlq+GU=
cloud.google.com/go/security v1.9.0/go.mod h1:6Ta1bO8LXI89nZnmnsZGp9lVoVWXqsVbIq/t9dzI+2Q=
cloud.google.com/go/security v1.10.0/go.mod h1:QtOMZByJVlibUT2h9afNDWRZ1G96gVywH8T5GUSb9IA=
cloud.google.com/go/security v1.12.0/go.mod h1:rV6EhrpbNHrrxqlvW0BWAIawFWq3X90SduMJdFwtLB8=
cloud.google.com/go/security v1.13.0/go.mod h1:Q1Nvxl1PAgmeW0y3HTt54JYIvUdtcpYKVfIB8AOMZ+0=
cloud.google.com/go/securitycenter v1.13.0/go.mod h1:cv5qNAqjY84FCN6Y9z28WlkKXyWsgLO832YiWwkCWcU=
cloud.google.com/go/securitycenter v1.14.0/go.mod h1:gZLAhtyKv85n52XYWt6RmeBdydyxfPeTrpToDPw4Auc=
cloud.google.com/go/securitycenter v1.15.0/go.mod h1:PeKJ0t8MoFmmXLXWm41JidyzI3PJjd8sXWaVqg43WWk=
cloud.google.com/go/securitycenter v1.16.0/go.mod h1:Q9GMaLQFUD+5ZTabrbujNWLtSLZIZF7SAR0wWECrjdk=
cloud.google.com/go/securitycenter v1.18.1/go.mod h1:0/25gAzCM/9OL9vVx4ChPeM/+DlfGQJDwBy/UC8AKK0=
cloud.google.com/go/securitycenter v1.19.0/go.mod h1:LVLmSg8ZkkyaNy4u7HCIshAngSQ8EcIRREP3xBnyfag=
cloud.google.com/go/servicecontrol v1.4.0/go.mod h1:o0hUSJ1TXJAmi/7fLJAedOovnujSEvjKCAFNXPQ1RaU=
cloud.google.com/go/servicecontrol v1.5.0/go.mod h1:qM0CnXHhyqKVuiZnGKrIurvVImCs8gmqWsDoqe9sU1s=
cloud.google.com/go/servicecontrol v1.10.0/go.mod h1:pQvyvSRh7YzUF2efw7H87V92mxU8FnFDawMClGCNuAA=
cloud.google.com/go/servicecontrol v1.11.0/go.mod h1:kFmTzYzTUIuZs0ycVqRHNaNhgR+UMUpw9n02l/pY+mc=
cloud.google.com/go/servicecontrol v1.11.1/go.mod h1:aSnNNlwEFBY+PWGQ2DoM0JJ/QUXqV5/ZD9DOLB7SnUk=
cloud.google.com/go/servicedirectory v1.4.0/go.mod h1:gH1MUaZCgtP7qQiI+F+A+OpeKF/HQWgtAddhTbhL2bs=
cloud.google.com/go/servicedirectory v1.5.0/go.mod h1:QMKFL0NUySbpZJ1UZs3oFAmdvVxhhxB6eJ/Vlp73dfg=
cloud.google.com/go/servicedirectory v1.6.0/go.mod h1:pUlbnWsLH9c13yGkxCmfumWEPjsRs1RlmJ4pqiNjVL4=
cloud.google.com/go/servicedirectory v1.7.0/go.mod h1:5p/U5oyvgYGYejufvxhgwjL8UVXjkuw7q5XcG10wx1U=
cloud.google.com/go/servicedirectory v1.8.0/go.mod h1:srXodfhY1GFIPvltunswqXpVxFPpZjf8nkKQT7XcXaY=
cloud.google.com/go/servicedirectory v1.9.0/go.mod h1:29je5JjiygNYlmsGz8k6o+OZ8vd4f//bQLtvzkPPT/s=
cloud.google.com/go/servicemanagement v1.4.0/go.mod h1:d8t8MDbezI7Z2R1O/wu8oTggo3BI2GKYbdG4y/SJTco=
cloud.google.com/go/servicemanagement v1.5.0/go.mod h1:XGaCRe57kfqu4+lRxaFEAuqmjzF0r+gWHjWqKqBvKFo=
cloud.google.com/go/servicemanagement v1.6.0/go.mod h1:aWns7EeeCOtGEX4OvZUWCCJONRZeFKiptqKf1D0l/Jc=
cloud.google.com/go/servicemanagement v1.8.0/go.mod h1:MSS2TDlIEQD/fzsSGfCdJItQveu9NXnUniTrq/L8LK4=
cloud.google.com/go/serviceusage v1.3.0/go.mod h1:Hya1cozXM4SeSKTAgGXgj97GlqUvF5JaoXacR1JTP/E=
cloud.google.com/go/serviceusage v1.4.0/go.mod h1:SB4yxXSaYVuUBYUml6qklyONXNLt83U0Rb+CXyhjEeU=
cloud.google.com/go/serviceusage v1.5.0/go.mod h1:w8U1JvqUqwJNPEOTQjrMHkw3IaIFLoLsPLvsE3xueec=
cloud.google.com/go/serviceusage v1.6.0/go.mod h1:R5wwQcbOWsyuOfbP9tGdAnCAc6B9DRwPG1xtWMDeuPA=
cloud.google.com/go/shell v1.3.0/go.mod h1:VZ9HmRjZBsjLGXusm7K5Q5lzzByZmJHf1d0IWHEN5X4=
cloud.google.com/go/shell v1.4.0/go.mod h1:HDxPzZf3GkDdhExzD/gs8Grqk+dmYcEjGShZgYa9URw=
cloud.google.com/go/shell v1.6.0/go.mod h1:oHO8QACS90luWgxP3N9iZVuEiSF84zNyLytb+qE2f9A=
cloud.google.com/go/spanner v1.41.0/go.mod h1:MLYDBJR/dY4Wt7ZaMIQ7rXOTLjYrmxLE/5ve9vFfWos=
cloud.google.com/go/spanner v1.44.0/go.mod h1:G8XIgYdOK+Fbcpbs7p2fiprDw4CaZX63whnSMLVBxjk=
cloud.google.com/go/spanner v1.45.0/go.mod h1:FIws5LowYz8YAE1J8fOS7DJup8ff7xJeetWEo5REA2M=
cloud.google.com/go/spanner v1.64.0 h1:ltyPbHA/nRAtAhU/o742dXBCI1eNHPeaRY09Ja8B+hM=
cloud.google.com/go/spanner v1.64.0/go.mod h1:TOFx3pb2UwPsDGlE1gTehW+y6YlU4IFk+VdDHSGQS/M=
cloud.google.com/go/speech v1.6.0/go.mod h1:79tcr4FHCimOp56lwC01xnt/WPJZc4v3gzyT7FoBkCM=
cloud.google.com/go/speech v1.7.0/go.mod h1:KptqL+BAQIhMsj1kOP2la5DSEEerPDuOP/2mmkhHhZQ=
cloud.google.com/go/speech v1.8.0/go.mod h1:9bYIl1/tjsAnMgKGHKmBZzXKEkGgtU+MpdDPTE9f7y0=
cloud.google.com/go/speech v1.9.0/go.mod h1:xQ0jTcmnRFFM2RfX/U+rk6FQNUF6DQlydUSyoooSpco=
cloud.google.com/go/speech v1.14.1/go.mod h1:gEosVRPJ9waG7zqqnsHpYTOoAS4KouMRLDFMekpJ0J0=
cloud.google.com/go/speech v1.15.0/go.mod h1:y6oH7GhqCaZANH7+Oe0BhgIogsNInLlz542tg3VqeYI=
cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=
cloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=
cloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=
cloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=
cloud.google.com/go/storage v1.10.0/go.mod h1:FLPqc6j+Ki4BU591ie1oL6qBQGu2Bl/tZ9ullr3+Kg0=
cloud.google.com/go/storage v1.14.0/go.mod h1:GrKmX003DSIwi9o29oFT7YDnHYwZoctc3fOKtUw0Xmo=
cloud.google.com/go/storage v1.22.1/go.mod h1:S8N1cAStu7BOeFfE8KAQzmyyLkK8p/vmRq6kuBTW58Y=
cloud.google.com/go/storage v1.23.0/go.mod h1:vOEEDNFnciUMhBeT6hsJIn3ieU5cFRmzeLgDvXzfIXc=
cloud.google.com/go/storage v1.27.0/go.mod h1:x9DOL8TK/ygDUMieqwfhdpQryTeEkhGKMi80i/iqR2s=
cloud.google.com/go/storage v1.28.1/go.mod h1:Qnisd4CqDdo6BGs2AD5LLnEsmSQ80wQ5ogcBBKhU86Y=
cloud.google.com/go/storage v1.29.0/go.mod h1:4puEjyTKnku6gfKoTfNOU/W+a9JyuVNxjpS5GBrB8h4=
cloud.google.com/go/storage v1.41.0 h1:RusiwatSu6lHeEXe3kglxakAmAbfV+rhtPqA6i8RBx0=
cloud.google.com/go/storage v1.41.0/go.mod h1:J1WCa/Z2FcgdEDuPUY8DxT5I+d9mFKsCepp5vR6Sq80=
cloud.google.com/go/storagetransfer v1.5.0/go.mod h1:dxNzUopWy7RQevYFHewchb29POFv3/AaBgnhqzqiK0w=
cloud.google.com/go/storagetransfer v1.6.0/go.mod h1:y77xm4CQV/ZhFZH75PLEXY0ROiS7Gh6pSKrM8dJyg6I=
cloud.google.com/go/storagetransfer v1.7.0/go.mod h1:8Giuj1QNb1kfLAiWM1bN6dHzfdlDAVC9rv9abHot2W4=
cloud.google.com/go/storagetransfer v1.8.0/go.mod h1:JpegsHHU1eXg7lMHkvf+KE5XDJ7EQu0GwNJbbVGanEw=
cloud.google.com/go/talent v1.1.0/go.mod h1:Vl4pt9jiHKvOgF9KoZo6Kob9oV4lwd/ZD5Cto54zDRw=
cloud.google.com/go/talent v1.2.0/go.mod h1:MoNF9bhFQbiJ6eFD3uSsg0uBALw4n4gaCaEjBw9zo8g=
cloud.google.com/go/talent v1.3.0/go.mod h1:CmcxwJ/PKfRgd1pBjQgU6W3YBwiewmUzQYH5HHmSCmM=
cloud.google.com/go/talent v1.4.0/go.mod h1:ezFtAgVuRf8jRsvyE6EwmbTK5LKciD4KVnHuDEFmOOA=
cloud.google.com/go/talent v1.5.0/go.mod h1:G+ODMj9bsasAEJkQSzO2uHQWXHHXUomArjWQQYkqK6c=
cloud.google.com/go/texttospeech v1.4.0/go.mod h1:FX8HQHA6sEpJ7rCMSfXuzBcysDAuWusNNNvN9FELDd8=
cloud.google.com/go/texttospeech v1.5.0/go.mod h1:oKPLhR4n4ZdQqWKURdwxMy0uiTS1xU161C8W57Wkea4=
cloud.google.com/go/texttospeech v1.6.0/go.mod h1:YmwmFT8pj1aBblQOI3TfKmwibnsfvhIBzPXcW4EBovc=
cloud.google.com/go/tpu v1.3.0/go.mod h1:aJIManG0o20tfDQlRIej44FcwGGl/cD0oiRyMKG19IQ=
cloud.google.com/go/tpu v1.4.0/go.mod h1:mjZaX8p0VBgllCzF6wcU2ovUXN9TONFLd7iz227X2Xg=
cloud.google.com/go/tpu v1.5.0/go.mod h1:8zVo1rYDFuW2l4yZVY0R0fb/v44xLh3llq7RuV61fPM=
cloud.google.com/go/trace v1.3.0/go.mod h1:FFUE83d9Ca57C+K8rDl/Ih8LwOzWIV1krKgxg6N0G28=
cloud.google.com/go/trace v1.4.0/go.mod h1:UG0v8UBqzusp+z63o7FK74SdFE+AXpCLdFb1rshXG+Y=
cloud.google.com/go/trace v1.8.0/go.mod h1:zH7vcsbAhklH8hWFig58HvxcxyQbaIqMarMg9hn5ECA=
cloud.google.com/go/trace v1.9.0/go.mod h1:lOQqpE5IaWY0Ixg7/r2SjixMuc6lfTFeO4QGM4dQWOk=
cloud.google.com/go/translate v1.3.0/go.mod h1:gzMUwRjvOqj5i69y/LYLd8RrNQk+hOmIXTi9+nb3Djs=
cloud.google.com/go/translate v1.4.0/go.mod h1:06Dn/ppvLD6WvA5Rhdp029IX2Mi3Mn7fpMRLPvXT5Wg=
cloud.google.com/go/translate v1.5.0/go.mod h1:29YDSYveqqpA1CQFD7NQuP49xymq17RXNaUDdc0mNu0=
cloud.google.com/go/translate v1.6.0/go.mod h1:lMGRudH1pu7I3n3PETiOB2507gf3HnfLV8qlkHZEyos=
cloud.google.com/go/translate v1.7.0/go.mod h1:lMGRudH1pu7I3n3PETiOB2507gf3HnfLV8qlkHZEyos=
cloud.google.com/go/video v1.8.0/go.mod h1:sTzKFc0bUSByE8Yoh8X0mn8bMymItVGPfTuUBUyRgxk=
cloud.google.com/go/video v1.9.0/go.mod h1:0RhNKFRF5v92f8dQt0yhaHrEuH95m068JYOvLZYnJSw=
cloud.google.com/go/video v1.12.0/go.mod h1:MLQew95eTuaNDEGriQdcYn0dTwf9oWiA4uYebxM5kdg=
cloud.google.com/go/video v1.13.0/go.mod h1:ulzkYlYgCp15N2AokzKjy7MQ9ejuynOJdf1tR5lGthk=
cloud.google.com/go/video v1.14.0/go.mod h1:SkgaXwT+lIIAKqWAJfktHT/RbgjSuY6DobxEp0C5yTQ=
cloud.google.com/go/video v1.15.0/go.mod h1:SkgaXwT+lIIAKqWAJfktHT/RbgjSuY6DobxEp0C5yTQ=
cloud.google.com/go/videointelligence v1.6.0/go.mod h1:w0DIDlVRKtwPCn/C4iwZIJdvC69yInhW0cfi+p546uU=
cloud.google.com/go/videointelligence v1.7.0/go.mod h1:k8pI/1wAhjznARtVT9U1llUaFNPh7muw8QyOUpavru4=
cloud.google.com/go/videointelligence v1.8.0/go.mod h1:dIcCn4gVDdS7yte/w+koiXn5dWVplOZkE+xwG9FgK+M=
cloud.google.com/go/videointelligence v1.9.0/go.mod h1:29lVRMPDYHikk3v8EdPSaL8Ku+eMzDljjuvRs105XoU=
cloud.google.com/go/videointelligence v1.10.0/go.mod h1:LHZngX1liVtUhZvi2uNS0VQuOzNi2TkY1OakiuoUOjU=
cloud.google.com/go/vision v1.2.0/go.mod h1:SmNwgObm5DpFBme2xpyOyasvBc1aPdjvMk2bBk0tKD0=
cloud.google.com/go/vision/v2 v2.2.0/go.mod h1:uCdV4PpN1S0jyCyq8sIM42v2Y6zOLkZs+4R9LrGYwFo=
cloud.google.com/go/vision/v2 v2.3.0/go.mod h1:UO61abBx9QRMFkNBbf1D8B1LXdS2cGiiCRx0vSpZoUo=
cloud.google.com/go/vision/v2 v2.4.0/go.mod h1:VtI579ll9RpVTrdKdkMzckdnwMyX2JILb+MhPqRbPsY=
cloud.google.com/go/vision/v2 v2.5.0/go.mod h1:MmaezXOOE+IWa+cS7OhRRLK2cNv1ZL98zhqFFZaaH2E=
cloud.google.com/go/vision/v2 v2.6.0/go.mod h1:158Hes0MvOS9Z/bDMSFpjwsUrZ5fPrdwuyyvKSGAGMY=
cloud.google.com/go/vision/v2 v2.7.0/go.mod h1:H89VysHy21avemp6xcf9b9JvZHVehWbET0uT/bcuY/0=
cloud.google.com/go/vmmigration v1.2.0/go.mod h1:IRf0o7myyWFSmVR1ItrBSFLFD/rJkfDCUTO4vLlJvsE=
cloud.google.com/go/vmmigration v1.3.0/go.mod h1:oGJ6ZgGPQOFdjHuocGcLqX4lc98YQ7Ygq8YQwHh9A7g=
cloud.google.com/go/vmmigration v1.5.0/go.mod h1:E4YQ8q7/4W9gobHjQg4JJSgXXSgY21nA5r8swQV+Xxc=
cloud.google.com/go/vmmigration v1.6.0/go.mod h1:bopQ/g4z+8qXzichC7GW1w2MjbErL54rk3/C843CjfY=
cloud.google.com/go/vmwareengine v0.1.0/go.mod h1:RsdNEf/8UDvKllXhMz5J40XxDrNJNN4sagiox+OI208=
cloud.google.com/go/vmwareengine v0.2.2/go.mod h1:sKdctNJxb3KLZkE/6Oui94iw/xs9PRNC2wnNLXsHvH8=
cloud.google.com/go/vmwareengine v0.3.0/go.mod h1:wvoyMvNWdIzxMYSpH/R7y2h5h3WFkx6d+1TIsP39WGY=
cloud.google.com/go/vpcaccess v1.4.0/go.mod h1:aQHVbTWDYUR1EbTApSVvMq1EnT57ppDmQzZ3imqIk4w=
cloud.google.com/go/vpcaccess v1.5.0/go.mod h1:drmg4HLk9NkZpGfCmZ3Tz0Bwnm2+DKqViEpeEpOq0m8=
cloud.google.com/go/vpcaccess v1.6.0/go.mod h1:wX2ILaNhe7TlVa4vC5xce1bCnqE3AeH27RV31lnmZes=
cloud.google.com/go/webrisk v1.4.0/go.mod h1:Hn8X6Zr+ziE2aNd8SliSDWpEnSS1u4R9+xXZmFiHmGE=
cloud.google.com/go/webrisk v1.5.0/go.mod h1:iPG6fr52Tv7sGk0H6qUFzmL3HHZev1htXuWDEEsqMTg=
cloud.google.com/go/webrisk v1.6.0/go.mod h1:65sW9V9rOosnc9ZY7A7jsy1zoHS5W9IAXv6dGqhMQMc=
cloud.google.com/go/webrisk v1.7.0/go.mod h1:mVMHgEYH0r337nmt1JyLthzMr6YxwN1aAIEc2fTcq7A=
cloud.google.com/go/webrisk v1.8.0/go.mod h1:oJPDuamzHXgUc+b8SiHRcVInZQuybnvEW72PqTc7sSg=
cloud.google.com/go/websecurityscanner v1.3.0/go.mod h1:uImdKm2wyeXQevQJXeh8Uun/Ym1VqworNDlBXQevGMo=
cloud.google.com/go/websecurityscanner v1.4.0/go.mod h1:ebit/Fp0a+FWu5j4JOmJEV8S8CzdTkAS77oDsiSqYWQ=
cloud.google.com/go/websecurityscanner v1.5.0/go.mod h1:Y6xdCPy81yi0SQnDY1xdNTNpfY1oAgXUlcfN3B3eSng=
cloud.google.com/go/workflows v1.6.0/go.mod h1:6t9F5h/unJz41YqfBmqSASJSXccBLtD1Vwf+KmJENM0=
cloud.google.com/go/workflows v1.7.0/go.mod h1:JhSrZuVZWuiDfKEFxU0/F1PQjmpnpcoISEXH2bcHC3M=
cloud.google.com/go/workflows v1.8.0/go.mod h1:ysGhmEajwZxGn1OhGOGKsTXc5PyxOc0vfKf5Af+to4M=
cloud.google.com/go/workflows v1.9.0/go.mod h1:ZGkj1aFIOd9c8Gerkjjq7OW7I5+l6cSvT3ujaO/WwSA=
cloud.google.com/go/workflows v1.10.0/go.mod h1:fZ8LmRmZQWacon9UCX1r/g/DfAXx5VcPALq2CxzdePw=
dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=
dario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=
dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=
gioui.org v0.0.0-20210308172011-57750fc8a0a6/go.mod h1:RSH6KIUZ0p2xy5zHDxgAM4zumjgTw83q2ge/PI+yyw8=
git.sr.ht/~sbinet/gg v0.3.1/go.mod h1:KGYtlADtqsqANL9ueOFkWymvzUvLMQllU5Ixo+8v3pc=
github.com/AdaLogics/go-fuzz-headers v0.0.0-20230811130428-ced1acdcaa24 h1:bvDV9vkmnHYOMsOr4WLk+Vo07yKIzd94sVoIqshQ4bU=
github.com/AdaLogics/go-fuzz-headers v0.0.0-20230811130428-ced1acdcaa24/go.mod h1:8o94RPi1/7XTJvwPpRSzSUedZrtlirdB3r9Z20bi2f8=
github.com/Azure/azure-sdk-for-go/sdk/azcore v1.9.1 h1:lGlwhPtrX6EVml1hO0ivjkUxsSyl4dsiw9qcA1k/3IQ=
github.com/Azure/azure-sdk-for-go/sdk/azcore v1.9.1/go.mod h1:RKUqNu35KJYcVG/fqTRqmuXJZYNhYkBrnC/hX7yGbTA=
github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.5.1 h1:sO0/P7g68FrryJzljemN+6GTssUXdANk6aJ7T1ZxnsQ=
github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.5.1/go.mod h1:h8hyGFDsU5HMivxiS2iYFZsgDbU9OnnJ163x5UGVKYo=
github.com/Azure/azure-sdk-for-go/sdk/internal v1.5.1 h1:6oNBlSdi1QqM1PNW7FPA6xOGA5UNsXnkaYZz9vdPGhA=
github.com/Azure/azure-sdk-for-go/sdk/internal v1.5.1/go.mod h1:s4kgfzA0covAXNicZHDMN58jExvcng2mC/DepXiF1EI=
github.com/Azure/azure-sdk-for-go/sdk/security/keyvault/azkeys v1.0.1 h1:MyVTgWR8qd/Jw1Le0NZebGBUCLbtak3bJ3z1OlqZBpw=
github.com/Azure/azure-sdk-for-go/sdk/security/keyvault/azkeys v1.0.1/go.mod h1:GpPjLhVR9dnUoJMyHWSPy71xY9/lcmpzIPZXmF0FCVY=
github.com/Azure/azure-sdk-for-go/sdk/security/keyvault/internal v1.0.0 h1:D3occbWoio4EBLkbkevetNMAVX197GkzbUMtqjGWn80=
github.com/Azure/azure-sdk-for-go/sdk/security/keyvault/internal v1.0.0/go.mod h1:bTSOgj05NGRuHHhQwAdPnYr9TOdNmKlZTgGLL6nyAdI=
github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=
github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
github.com/AzureAD/microsoft-authentication-library-for-go v1.2.1 h1:DzHpqpoJVaCgOUdVHxE8QB52S6NiVdDQvGlny1qvPqA=
github.com/AzureAD/microsoft-authentication-library-for-go v1.2.1/go.mod h1:wP83P5OoQ5p6ip3ScPr0BAq0BvuPAvacpEuSzyouqAI=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
github.com/ClickHouse/ch-go v0.61.3 h1:MmBwUhXrAOBZK7n/sWBzq6FdIQ01cuF2SaaO8KlDRzI=
github.com/ClickHouse/ch-go v0.61.3/go.mod h1:1PqXjMz/7S1ZUaKvwPA3i35W2bz2mAMFeCi6DIXgGwQ=
github.com/ClickHouse/clickhouse-go/v2 v2.20.0 h1:bvlLQ31XJfl7MxIqAq2l1G6JhHYzqEXdvfpMeU6bkKc=
github.com/ClickHouse/clickhouse-go/v2 v2.20.0/go.mod h1:VQfyA+tCwCRw2G7ogfY8V0fq/r0yJWzy8UDrjiP/Lbs=
github.com/DATA-DOG/go-sqlmock v1.5.2 h1:OcvFkGmslmlZibjAjaHm3L//6LiuBgolP7OputlJIzU=
github.com/DATA-DOG/go-sqlmock v1.5.2/go.mod h1:88MAG/4G7SMwSE3CeA0ZKzrT5CiOU3OJ+JlNzwDqpNU=
github.com/GoogleCloudPlatform/grpc-gcp-go/grpcgcp v1.5.2 h1:DBjmt6/otSdULyJdVg2BlG0qGZO5tKL4VzOs0jpvw5Q=
github.com/GoogleCloudPlatform/grpc-gcp-go/grpcgcp v1.5.2/go.mod h1:dppbR7CwXD4pgtV9t3wD1812RaLDcBjtblcDF5f1vI0=
github.com/JohnCGriffin/overflow v0.0.0-20211019200055-46fa312c352c h1:RGWPOewvKIROun94nF7v2cua9qP+thov/7M50KEoeSU=
github.com/JohnCGriffin/overflow v0.0.0-20211019200055-46fa312c352c/go.mod h1:X0CRv0ky0k6m906ixxpzmDRLvX58TFUKS2eePweuyxk=
github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
github.com/ajstarks/deck v0.0.0-20200831202436-30c9fc6549a9/go.mod h1:JynElWSGnm/4RlzPXRlREEwqTHAN3T56Bv2ITsFT3gY=
github.com/ajstarks/deck/generate v0.0.0-20210309230005-c3f852c02e19/go.mod h1:T13YZdzov6OU0A1+RfKZiZN9ca6VeKdBdyDV+BY97Tk=
github.com/ajstarks/svgo v0.0.0-20180226025133-644b8db467af/go.mod h1:K08gAheRH3/J6wwsYMMT4xOr94bZjxIelGM0+d/wbFw=
github.com/ajstarks/svgo v0.0.0-20211024235047-1546f124cd8b/go.mod h1:1KcenG0jGWcpt8ov532z81sp/kMMUG485J2InIOyADM=
github.com/andybalholm/brotli v1.0.4/go.mod h1:fO7iG3H7G2nSZ7m0zPUDn85XEX2GTukHGRSepvi9Eig=
github.com/andybalholm/brotli v1.1.0 h1:eLKJA0d02Lf0mVpIDgYnqXcUn0GqVmEFny3VuID1U3M=
github.com/andybalholm/brotli v1.1.0/go.mod h1:sms7XGricyQI9K10gOSf56VKKWS4oLer58Q+mhRPtnY=
github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=
github.com/apache/arrow/go/v10 v10.0.1/go.mod h1:YvhnlEePVnBS4+0z3fhPfUy7W1Ikj0Ih0vcRo/gZ1M0=
github.com/apache/arrow/go/v11 v11.0.0/go.mod h1:Eg5OsL5H+e299f7u5ssuXsuHQVEGC4xei5aX110hRiI=
github.com/apache/arrow/go/v12 v12.0.1 h1:JsR2+hzYYjgSUkBSaahpqCetqZMr76djX80fF/DiJbg=
github.com/apache/arrow/go/v12 v12.0.1/go.mod h1:weuTY7JvTG/HDPtMQxEUp7pU73vkLWMLpY67QwZ/WWw=
github.com/apache/arrow/go/v14 v14.0.2 h1:N8OkaJEOfI3mEZt07BIkvo4sC6XDbL+48MBPWO5IONw=
github.com/apache/arrow/go/v14 v14.0.2/go.mod h1:u3fgh3EdgN/YQ8cVQRguVW3R+seMybFg8QBQ5LU+eBY=
github.com/apache/arrow/go/v15 v15.0.2 h1:60IliRbiyTWCWjERBCkO1W4Qun9svcYoZrSLcyOsMLE=
github.com/apache/arrow/go/v15 v15.0.2/go.mod h1:DGXsR3ajT524njufqf95822i+KTh+yea1jass9YXgjA=
github.com/apache/thrift v0.16.0/go.mod h1:PHK3hniurgQaNMZYaCLEqXKsYK8upmhPbmdP2FXSqgU=
github.com/apache/thrift v0.17.0 h1:cMd2aj52n+8VoAtvSvLn4kDC3aZ6IAkBuqWQ2IDu7wo=
github.com/apache/thrift v0.17.0/go.mod h1:OLxhMRJxomX+1I/KUw03qoV3mMz16BwaKI+d4fPBx7Q=
github.com/boombuler/barcode v1.0.0/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=
github.com/boombuler/barcode v1.0.1/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=
github.com/bsm/ginkgo/v2 v2.5.0 h1:aOAnND1T40wEdAtkGSkvSICWeQ8L3UASX7YVCqQx+eQ=
github.com/bsm/ginkgo/v2 v2.5.0/go.mod h1:AiKlXPm7ItEHNc/2+OkrNG4E0ITzojb9/xWzvQ9XZ9w=
github.com/bsm/gomega v1.20.0 h1:JhAwLmtRzXFTx2AkALSLa8ijZafntmhSoU63Ok18Uq8=
github.com/bsm/gomega v1.20.0/go.mod h1:JifAceMQ4crZIWYUKrlGcmbN3bqHogVTADMD2ATsbwk=
github.com/cenkalti/backoff/v4 v4.2.1 h1:y4OZtCnogmCPw98Zjyt5a6+QwPLGkiQsYW5oUqylYbM=
github.com/cenkalti/backoff/v4 v4.2.1/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/census-instrumentation/opencensus-proto v0.3.0/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/census-instrumentation/opencensus-proto v0.4.1 h1:iKLQ0xPNFxR/2hzXZMrBo8f1j86j5WHzznCCQxV/b8g=
github.com/census-instrumentation/opencensus-proto v0.4.1/go.mod h1:4T9NM4+4Vw91VeyqjLS6ao50K5bOcLKN6Q42XnYaRYw=
github.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=
github.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=
github.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=
github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=
github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/cncf/udpa/go v0.0.0-20200629203442-efcf912fb354/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=
github.com/cncf/udpa/go v0.0.0-20220112060539-c52dc94e7fbe/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=
github.com/cncf/xds/go v0.0.0-20210312221358-fbca930ec8ed/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20210805033703-aa0b78936158/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20211001041855-01bcc9b48dfe/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20220314180256-7f1daf1720fc/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20230105202645-06c439db220b/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20230607035331-e9ce68804cb4/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20240318125728-8a4994d93e50 h1:DBmgJDC9dTfkVyGgipamEh2BpGYxScCH1TOF1LL1cXc=
github.com/cncf/xds/go v0.0.0-20240318125728-8a4994d93e50/go.mod h1:5e1+Vvlzido69INQaVO6d87Qn543Xr6nooe9Kz7oBFM=
github.com/containerd/containerd v1.7.18 h1:jqjZTQNfXGoEaZdW1WwPU0RqSn1Bm2Ay/KJPUuO8nao=
github.com/containerd/containerd v1.7.18/go.mod h1:IYEk9/IO6wAPUz2bCMVUbsfXjzw5UNP5fLz4PsUygQ4=
github.com/containerd/log v0.1.0 h1:TCJt7ioM2cr/tfR8GPbGf9/VRAX8D2B4PjzCpfX540I=
github.com/containerd/log v0.1.0/go.mod h1:VRRf09a7mHDIRezVKTRCrOq78v577GXq3bSa3EhrzVo=
github.com/containerd/platforms v0.2.1 h1:zvwtM3rz2YHPQsF2CHYM8+KtB5dvhISiXh5ZpSBQv6A=
github.com/containerd/platforms v0.2.1/go.mod h1:XHCb+2/hzowdiut9rkudds9bE5yJ7npe7dG/wG+uFPw=
github.com/coreos/go-oidc/v3 v3.5.0 h1:VxKtbccHZxs8juq7RdJntSqtXFtde9YpNpGn0yqgEHw=
github.com/coreos/go-oidc/v3 v3.5.0/go.mod h1:ecXRtV4romGPeO6ieExAsUK9cb/3fp9hXNz1tlv8PIM=
github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=
github.com/cpuguy83/dockercfg v0.3.2 h1:DlJTyZGBDlXqUZ2Dk2Q3xHs/FtnooJJVaad2S9GKorA=
github.com/cpuguy83/dockercfg v0.3.2/go.mod h1:sugsbF4//dDlL/i+S+rtpIWp+5h0BHJHfjj5/jFyUJc=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/creack/pty v1.1.18 h1:n56/Zwd5o6whRC5PMGretI4IdRLlmBXYNjScPaBgsbY=
github.com/creack/pty v1.1.18/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=
github.com/databricks/databricks-sql-go v1.5.3 h1:A8pe8azPkGM/1lD2wWf1G6sW5PDuLM9qBfSIbLuWzvw=
github.com/databricks/databricks-sql-go v1.5.3/go.mod h1:8aNP4vhhfBJZhc4n7LcSAvtJsZ+Dc25Q6mGxM1/8WaY=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=
github.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=
github.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=
github.com/dnephin/pflag v1.0.7 h1:oxONGlWxhmUct0YzKTgrpQv9AUA1wtPBn7zuSjJqptk=
github.com/dnephin/pflag v1.0.7/go.mod h1:uxE91IoWURlOiTUIA8Mq5ZZkAv3dPUfZNaT80Zm7OQE=
github.com/docker/docker v27.1.1+incompatible h1:hO/M4MtV36kzKldqnA37IWhebRA+LnqqcqDja6kVaKY=
github.com/docker/docker v27.1.1+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=
github.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=
github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/docopt/docopt-go v0.0.0-20180111231733-ee0de3bc6815/go.mod h1:WwZ+bS3ebgob9U8Nd0kOddGdZWjyMGR8Wziv+TBNwSE=
github.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/go-control-plane v0.9.7/go.mod h1:cwu0lG7PUMfa9snN8LXBig5ynNVH9qI8YYLbd1fK2po=
github.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/go-control-plane v0.9.9-0.20210217033140-668b12f5399d/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/go-control-plane v0.9.9-0.20210512163311-63b5d3c536b0/go.mod h1:hliV/p42l8fGbc6Y9bQ70uLwIvmJyVE5k4iMKlh8wCQ=
github.com/envoyproxy/go-control-plane v0.9.10-0.20210907150352-cf90f659a021/go.mod h1:AFq3mo9L8Lqqiid3OhADV3RfLJnjiw63cSpi+fDTRC0=
github.com/envoyproxy/go-control-plane v0.10.2-0.20220325020618-49ff273808a1/go.mod h1:KJwIaB5Mv44NWtYuAOFCVOjcI94vtpEz2JU/D2v6IjE=
github.com/envoyproxy/go-control-plane v0.10.3/go.mod h1:fJJn/j26vwOu972OllsvAgJJM//w9BV6Fxbg2LuVd34=
github.com/envoyproxy/go-control-plane v0.11.1-0.20230524094728-9239064ad72f/go.mod h1:sfYdkwUW4BA3PbKjySwjJy+O4Pu0h62rlqCMHNk+K+Q=
github.com/envoyproxy/go-control-plane v0.12.0 h1:4X+VP1GHd1Mhj6IB5mMeGbLCleqxjletLK6K0rbxyZI=
github.com/envoyproxy/go-control-plane v0.12.0/go.mod h1:ZBTaoJ23lqITozF0M6G4/IragXCQKCnYbmlmtHvwRG0=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/envoyproxy/protoc-gen-validate v0.6.7/go.mod h1:dyJXwwfPK2VSqiB9Klm1J6romD608Ba7Hij42vrOBCo=
github.com/envoyproxy/protoc-gen-validate v0.9.1/go.mod h1:OKNgG7TCp5pF4d6XftA0++PMirau2/yoOwVac3AbF2w=
github.com/envoyproxy/protoc-gen-validate v0.10.1/go.mod h1:DRjgyB0I43LtJapqN6NiRwroiAU2PaFuvk/vjgh61ss=
github.com/envoyproxy/protoc-gen-validate v1.0.4 h1:gVPz/FMfvh57HdSJQyvBtF00j8JU4zdyUgIUNhlgg0A=
github.com/envoyproxy/protoc-gen-validate v1.0.4/go.mod h1:qys6tmnRsYrQqIhm2bvKZH4Blx/1gTIZ2UKVY1M+Yew=
github.com/fatih/color v1.13.0/go.mod h1:kLAiJbzzSOZDVNGyDpeOxJ47H46qBXwg5ILebYFFOfk=
github.com/fatih/color v1.15.0 h1:kOqh6YHBtK8aywxGerMG2Eq3H6Qgoqeo13Bk2Mv/nBs=
github.com/fatih/color v1.15.0/go.mod h1:0h5ZqXfHYED7Bhv2ZJamyIOUej9KtShiJESRwBDUSsw=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/fogleman/gg v1.2.1-0.20190220221249-0403632d5b90/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=
github.com/fogleman/gg v1.3.0/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=
github.com/fsnotify/fsnotify v1.5.4/go.mod h1:OVB6XrOHzAwXMpEM7uPOzcehqUV2UqJxmVXmkdnm1bU=
github.com/fsnotify/fsnotify v1.6.0 h1:n+5WquG0fcWoWp6xPWfHdbskMCQaFnG6PfBrh1Ky4HY=
github.com/fsnotify/fsnotify v1.6.0/go.mod h1:sl3t1tCWJFWoRz9R8WJCbQihKKwmorjAbSClcnxKAGw=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-faster/city v1.0.1 h1:4WAxSZ3V2Ws4QRDrscLEDcibJY8uf41H6AhXDrNDcGw=
github.com/go-faster/city v1.0.1/go.mod h1:jKcUJId49qdW3L1qKHH/3wPeUstCVpVSXTM6vO3VcTw=
github.com/go-faster/errors v0.7.1 h1:MkJTnDoEdi9pDabt1dpWf7AA8/BaSYZqibYyhZ20AYg=
github.com/go-faster/errors v0.7.1/go.mod h1:5ySTjWFiphBs07IKuiL69nxdfd5+fzh1u7FPGZP2quo=
github.com/go-fonts/dejavu v0.1.0/go.mod h1:4Wt4I4OU2Nq9asgDCteaAaWZOV24E+0/Pwo0gppep4g=
github.com/go-fonts/latin-modern v0.2.0/go.mod h1:rQVLdDMK+mK1xscDwsqM5J8U2jrRa3T0ecnM9pNujks=
github.com/go-fonts/liberation v0.1.1/go.mod h1:K6qoJYypsmfVjWg8KOVDQhLc8UDgIK2HYqyqAO9z7GY=
github.com/go-fonts/liberation v0.2.0/go.mod h1:K6qoJYypsmfVjWg8KOVDQhLc8UDgIK2HYqyqAO9z7GY=
github.com/go-fonts/stix v0.1.0/go.mod h1:w/c1f0ldAUlJmLBvlbkvVXLAD+tAMqobIIQpmnUIzUY=
github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
github.com/go-jose/go-jose/v3 v3.0.0/go.mod h1:RNkWWRld676jZEYoV3+XK8L2ZnNSvIsxFMht0mSX+u8=
github.com/go-jose/go-jose/v3 v3.0.3 h1:fFKWeig/irsp7XD2zBxvnmA/XaRWp5V3CBsZXJF7G7k=
github.com/go-jose/go-jose/v3 v3.0.3/go.mod h1:5b+7YgP7ZICgJDBdfjZaIt+H/9L9T/YQrVfLAMboGkQ=
github.com/go-latex/latex v0.0.0-20210118124228-b3d85cf34e07/go.mod h1:CO1AlKB2CSIqUrmQPqA0gdRIlnLEY0gK5JGjh37zN5U=
github.com/go-latex/latex v0.0.0-20210823091927-c0d11ff05a81/go.mod h1:SX0U8uGpxhq9o2S/CELCSUxEWWAuoCUcVCQWv7G2OCk=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-ole/go-ole v1.2.6 h1:/Fpf6oFPoeFik9ty7siob0G6Ke8QvQEuVcuChpwXzpY=
github.com/go-ole/go-ole v1.2.6/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
github.com/go-pdf/fpdf v0.5.0/go.mod h1:HzcnA+A23uwogo0tp9yU+l3V+KXhiESpt1PMayhOh5M=
github.com/go-pdf/fpdf v0.6.0/go.mod h1:HzcnA+A23uwogo0tp9yU+l3V+KXhiESpt1PMayhOh5M=
github.com/go-sql-driver/mysql v1.7.1 h1:lUIinVbN1DY0xBg0eMOzmmtGoHwWBbvnWubQUrtU8EI=
github.com/go-sql-driver/mysql v1.7.1/go.mod h1:OXbVy3sEdcQ2Doequ6Z5BW6fXNQTmx+9S1MCJN5yJMI=
github.com/goccy/go-json v0.9.11/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=
github.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=
github.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=
github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/golang-jwt/jwt/v5 v5.2.0 h1:d/ix8ftRUorsN+5eMIlF4T6J8CAt9rch3My2winC1Jw=
github.com/golang-jwt/jwt/v5 v5.2.0/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 h1:au07oEsX2xN0ktxqI+Sida1w446QrXBRJ0nee3SNZlA=
github.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9/go.mod h1:8vg3r2VgvsThLBIFL93Qb5yWzgyZWhEmBwUJWevAkK0=
github.com/golang-sql/sqlexp v0.1.0 h1:ZCD6MBpcuOVfGVqsEmY5/4FtYiKz6tSyUv9LPEDei6A=
github.com/golang-sql/sqlexp v0.1.0/go.mod h1:J4ad9Vo8ZCWQ2GMrC4UCQy1JpCbwU9m3EOqtpKwwwHI=
github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/glog v1.0.0/go.mod h1:EWib/APOK0SL3dFbYqvxE3UYd8E6s1ouQ7iEp/0LWV4=
github.com/golang/glog v1.1.0/go.mod h1:pfYeQZ3JWZoXTV5sFc986z3HTpwQs9At6P4ImfuP3NQ=
github.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=
github.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=
github.com/golang/mock v1.5.0/go.mod h1:CWnOUgYIOo4TcNZ0wHX3YZCqsaM1I1Jvs6v3mP3KVu8=
github.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
github.com/golang/protobuf v1.5.1/go.mod h1:DopwsBzvsk0Fs44TXzsVbJyPhcCPeIwnvohx4u74HPM=
github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=
github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=
github.com/golang/snappy v0.0.1/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=
github.com/golang/snappy v0.0.3/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=
github.com/golang/snappy v0.0.4 h1:yAGX7huGHXlcLOEtBnF4w7FQwA26wojNCwOYAEhLjQM=
github.com/golang/snappy v0.0.4/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=
github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/flatbuffers v2.0.8+incompatible/go.mod h1:1AeVuKshWv4vARoZatz6mlQ0JxURH0Kv5+zNeJKJCa8=
github.com/google/flatbuffers v23.5.26+incompatible h1:M9dgRyhJemaM4Sw8+66GHBu8ioaQmyPLg1b8VwK5WJg=
github.com/google/flatbuffers v23.5.26+incompatible/go.mod h1:1AeVuKshWv4vARoZatz6mlQ0JxURH0Kv5+zNeJKJCa8=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.7/go.mod h1:n+brtR0CgQNWTVd5ZUFpTBC8YFBDLK/h/bpaJ8/DtOE=
github.com/google/go-cmp v0.5.8/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/martian v2.1.0+incompatible h1:/CP5g8u/VJHijgedC/Legn3BAbAaWPgecwXBIDzw5no=
github.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=
github.com/google/martian/v3 v3.0.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=
github.com/google/martian/v3 v3.1.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=
github.com/google/martian/v3 v3.2.1/go.mod h1:oBOf6HBosgwRXnUGWUB05QECsc6uvmMiJ3+6W4l/CUk=
github.com/google/martian/v3 v3.3.2/go.mod h1:oBOf6HBosgwRXnUGWUB05QECsc6uvmMiJ3+6W4l/CUk=
github.com/google/martian/v3 v3.3.3 h1:DIhPTQrbPkgs2yJYdXU/eNACCG5DVQjySNRNlflZ9Fc=
github.com/google/martian/v3 v3.3.3/go.mod h1:iEPrYcgCF7jA9OtScMFQyAlZZ4YXTKEtJ1E6RWzmBA0=
github.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
github.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
github.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200708004538-1a94d8640e99/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20201023163331-3e6fc7fc9c4c/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20201218002935-b9804c9f04c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20210122040257-d980be63207e/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20210226084205-cbba55b83ad5/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20210601050228-01bbb1931b22/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20210609004039-a478d1d731e9/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20210720184732-4bb14d4b1be1/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20221118152302-e6195bd50e26 h1:Xim43kblpZXfIBQsbuBVKCudVG457BR2GZFIz3uw3hQ=
github.com/google/pprof v0.0.0-20221118152302-e6195bd50e26/go.mod h1:dDKJzRmX4S37WGHujM7tX//fmj1uioxKzKxz3lo4HJo=
github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
github.com/google/s2a-go v0.1.7 h1:60BLSyTrOV4/haCDW4zb1guZItoSq8foHCXrAnjBo/o=
github.com/google/s2a-go v0.1.7/go.mod h1:50CgR4k1jNlWBu4UfS4AcfhVe1r6pdZPygJ3R8F0Qdw=
github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 h1:El6M4kTTCOh6aBiKaUGG7oYTSPP8MxqL4YI3kZKwcP4=
github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510/go.mod h1:pupxD2MaaD3pAXIBCelhxNneeOaAeabZDe5s4K6zSpQ=
github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/googleapis/enterprise-certificate-proxy v0.0.0-20220520183353-fd19c99a87aa/go.mod h1:17drOmN3MwGY7t0e+Ei9b45FFGA3fBs3x36SsCg1hq8=
github.com/googleapis/enterprise-certificate-proxy v0.1.0/go.mod h1:17drOmN3MwGY7t0e+Ei9b45FFGA3fBs3x36SsCg1hq8=
github.com/googleapis/enterprise-certificate-proxy v0.2.0/go.mod h1:8C0jb7/mgJe/9KK8Lm7X9ctZC2t60YyIpYEI16jx0Qg=
github.com/googleapis/enterprise-certificate-proxy v0.2.1/go.mod h1:AwSRAtLfXpU5Nm3pW+v7rGDHp09LsPtGY9MduiEsR9k=
github.com/googleapis/enterprise-certificate-proxy v0.2.3/go.mod h1:AwSRAtLfXpU5Nm3pW+v7rGDHp09LsPtGY9MduiEsR9k=
github.com/googleapis/enterprise-certificate-proxy v0.3.2 h1:Vie5ybvEvT75RniqhfFxPRy3Bf7vr3h0cechB90XaQs=
github.com/googleapis/enterprise-certificate-proxy v0.3.2/go.mod h1:VLSiSSBs/ksPL8kq3OBOQ6WRI2QnaFynd1DCjZ62+V0=
github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=
github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=
github.com/googleapis/gax-go/v2 v2.1.0/go.mod h1:Q3nei7sK6ybPYH7twZdmQpAd1MKb7pfu6SK+H1/DsU0=
github.com/googleapis/gax-go/v2 v2.1.1/go.mod h1:hddJymUZASv3XPyGkUpKj8pPO47Rmb0eJc8R6ouapiM=
github.com/googleapis/gax-go/v2 v2.2.0/go.mod h1:as02EH8zWkzwUoLbBaFeQ+arQaj/OthfcblKl4IGNaM=
github.com/googleapis/gax-go/v2 v2.3.0/go.mod h1:b8LNqSzNabLiUpXKkY7HAR5jr6bIT99EXz9pXxye9YM=
github.com/googleapis/gax-go/v2 v2.4.0/go.mod h1:XOTVJ59hdnfJLIP/dh8n5CGryZR2LxK9wbMD5+iXC6c=
github.com/googleapis/gax-go/v2 v2.5.1/go.mod h1:h6B0KMMFNtI2ddbGJn3T3ZbwkeT6yqEF02fYlzkUCyo=
github.com/googleapis/gax-go/v2 v2.6.0/go.mod h1:1mjbznJAPHFpesgE5ucqfYEscaz5kMdcIDwU/6+DDoY=
github.com/googleapis/gax-go/v2 v2.7.0/go.mod h1:TEop28CZZQ2y+c0VxMUmu1lV+fQx57QpBWsYpwqHJx8=
github.com/googleapis/gax-go/v2 v2.7.1/go.mod h1:4orTrqY6hXxxaUL4LHIPl6lGo8vAE38/qKbhSAKP6QI=
github.com/googleapis/gax-go/v2 v2.12.5 h1:8gw9KZK8TiVKB6q3zHY3SBzLnrGp6HQjyfYBYGmXdxA=
github.com/googleapis/gax-go/v2 v2.12.5/go.mod h1:BUDKcWo+RaKq5SC9vVYL0wLADa3VcfswbOMMRmB9H3E=
github.com/googleapis/go-type-adapters v1.0.0/go.mod h1:zHW75FOG2aur7gAO2B+MLby+cLsWGBF62rFAi7WjWO4=
github.com/googleapis/google-cloud-go-testing v0.0.0-20200911160855-bcd43fbb19e8/go.mod h1:dvDLG8qkwmyD9a/MJJN3XJcT3xFxOKAvTZGvuZmac9g=
github.com/gorilla/securecookie v1.1.1 h1:miw7JPhV+b/lAHSXz4qd/nN9jRiAFV5FwjeKyCS8BvQ=
github.com/gorilla/securecookie v1.1.1/go.mod h1:ra0sb63/xPlUeL+yeDciTfxMRAA+MP+HVt/4epWDjd4=
github.com/gorilla/sessions v1.2.1 h1:DHd3rPN5lE3Ts3D8rKkQ8x/0kqfeNmBAaiSi+o7FsgI=
github.com/gorilla/sessions v1.2.1/go.mod h1:dk2InVEVJ0sfLlnXv9EAgkf6ecYs/i80K/zI+bUmuGM=
github.com/grpc-ecosystem/grpc-gateway v1.16.0 h1:gmcG1KaJ57LophUzW0Hy8NmPhnMZb4M0+kPpLofRdBo=
github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.7.0/go.mod h1:hgWBS7lorOAVIJEQMi4ZsPv9hVvWI6+ch50m39Pf2Ks=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.11.3/go.mod h1:o//XUCC/F+yRGJoPO/VU0GSB0f8Nhgmxx0VIRUvaC0w=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0 h1:YBftPWNWd4WwGqtY2yeZL2ef8rHAxPBD8KFhJpmcqms=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0/go.mod h1:YN5jB8ie0yfIUg6VvR9Kz84aCaG7AsGZnLjhHbUqwPg=
github.com/hashicorp/go-cleanhttp v0.5.1 h1:dH3aiDG9Jvb5r5+bYHsikaOUIpcM0xvgMXVoDkXMzJM=
github.com/hashicorp/go-cleanhttp v0.5.1/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=
github.com/hashicorp/go-hclog v0.9.2 h1:CG6TE5H9/JXsFWJCfoIVpKFIkFe6ysEuHirp4DxCsHI=
github.com/hashicorp/go-hclog v0.9.2/go.mod h1:5CU+agLiy3J7N7QjHK5d05KxGsuXiQLrjA0H7acj2lQ=
github.com/hashicorp/go-retryablehttp v0.7.1 h1:sUiuQAnLlbvmExtFQs72iFW/HXeUn8Z1aJLQ4LJJbTQ=
github.com/hashicorp/go-retryablehttp v0.7.1/go.mod h1:vAew36LZh98gCBJNLH42IQ1ER/9wtLZZ8meHqQvEYWY=
github.com/hashicorp/go-uuid v1.0.2/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=
github.com/hashicorp/go-uuid v1.0.3 h1:2gKiV6YVmrJ1i2CKKa9obLvRieoRGviZFL26PcT/Co8=
github.com/hashicorp/go-uuid v1.0.3/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=
github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/iancoleman/strcase v0.2.0/go.mod h1:iwCmte+B7n89clKwxIoIXy/HfoL7AsD47ZCWhYzw7ho=
github.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
github.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=
github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.5.4 h1:Xp2aQS8uXButQdnCMWNmvx6UysWQQC+u1EoizjguY+8=
github.com/jackc/pgx/v5 v5.5.4/go.mod h1:ez9gk+OAat140fv9ErkZDYFWmXLfV+++K0uAOiwgm1A=
github.com/jackc/puddle/v2 v2.2.1 h1:RhxXJtFG022u4ibrCSMSiu5aOq1i77R3OHKNJj77OAk=
github.com/jackc/puddle/v2 v2.2.1/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/jcmturner/aescts/v2 v2.0.0 h1:9YKLH6ey7H4eDBXW8khjYslgyqG2xZikXP0EQFKrle8=
github.com/jcmturner/aescts/v2 v2.0.0/go.mod h1:AiaICIRyfYg35RUkr8yESTqvSy7csK90qZ5xfvvsoNs=
github.com/jcmturner/dnsutils/v2 v2.0.0 h1:lltnkeZGL0wILNvrNiVCR6Ro5PGU/SeBvVO/8c/iPbo=
github.com/jcmturner/dnsutils/v2 v2.0.0/go.mod h1:b0TnjGOvI/n42bZa+hmXL+kFJZsFT7G4t3HTlQ184QM=
github.com/jcmturner/gofork v1.7.6 h1:QH0l3hzAU1tfT3rZCnW5zXl+orbkNMMRGJfdJjHVETg=
github.com/jcmturner/gofork v1.7.6/go.mod h1:1622LH6i/EZqLloHfE7IeZ0uEJwMSUyQ/nDd82IeqRo=
github.com/jcmturner/goidentity/v6 v6.0.1 h1:VKnZd2oEIMorCTsFBnJWbExfNN7yZr3EhJAxwOkZg6o=
github.com/jcmturner/goidentity/v6 v6.0.1/go.mod h1:X1YW3bgtvwAXju7V3LCIMpY0Gbxyjn/mY9zx4tFonSg=
github.com/jcmturner/gokrb5/v8 v8.4.4 h1:x1Sv4HaTpepFkXbt2IkL29DXRf8sOfZXo8eRKh687T8=
github.com/jcmturner/gokrb5/v8 v8.4.4/go.mod h1:1btQEpgT6k+unzCwX1KdWMEwPPkkgBtP+F6aCACiMrs=
github.com/jcmturner/rpc/v2 v2.0.3 h1:7FXXj8Ti1IaVFpSAziCZWNzbNuZmnvw/i6CqLNdWfZY=
github.com/jcmturner/rpc/v2 v2.0.3/go.mod h1:VUJYCIDm3PVOEHw8sgt091/20OJjskO/YJki3ELg/Hc=
github.com/jedib0t/go-pretty/v6 v6.5.8 h1:8BCzJdSvUbaDuRba4YVh+SKMGcAAKdkcF3SVFbrHAtQ=
github.com/jedib0t/go-pretty/v6 v6.5.8/go.mod h1:zbn98qrYlh95FIhwwsbIip0LYpwSG8SUOScs+v9/t0E=
github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
github.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=
github.com/jung-kurt/gofpdf v1.0.0/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=
github.com/jung-kurt/gofpdf v1.0.3-0.20190309125859-24315acbbda5/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=
github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=
github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=
github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/kisielk/sqlstruct v0.0.0-20201105191214-5f3e10d3ab46/go.mod h1:yyMNCyc/Ib3bDTKd379tNMpB/7/H5TjM2Y9QJ5THLbE=
github.com/klauspost/asmfmt v1.3.2 h1:4Ri7ox3EwapiOjCki+hw14RyKk201CN4rzyCJRFLpK4=
github.com/klauspost/asmfmt v1.3.2/go.mod h1:AG8TuvYojzulgDAMCnYn50l/5QV3Bs/tp6j0HLHbNSE=
github.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
github.com/klauspost/compress v1.15.9/go.mod h1:PhcZ0MbTNciWF3rruxRgKxI5NkcHHrHUDtV4Yw2GlzU=
github.com/klauspost/compress v1.17.7 h1:ehO88t2UGzQK66LMdE8tibEd1ErmzZjNEqWkjLAKQQg=
github.com/klauspost/compress v1.17.7/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=
github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
github.com/klauspost/cpuid/v2 v2.2.5 h1:0E5MSMDEoAulmXNFquVs//DdoomxaoTY1kUhbc/qbZg=
github.com/klauspost/cpuid/v2 v2.2.5/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=
github.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=
github.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 h1:6E+4a0GO5zZEnZ81pIr0yLvtUWk2if982qA3F3QD6H4=
github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0/go.mod h1:zJYVVT2jmtg6P3p1VtQj7WsuWi/y4VnjVBn7F8KPB3I=
github.com/lyft/protoc-gen-star v0.6.0/go.mod h1:TGAoBVkt8w7MPG72TrKIu85MIdXwDuzJYeZuUPFPNwA=
github.com/lyft/protoc-gen-star v0.6.1/go.mod h1:TGAoBVkt8w7MPG72TrKIu85MIdXwDuzJYeZuUPFPNwA=
github.com/lyft/protoc-gen-star/v2 v2.0.1/go.mod h1:RcCdONR2ScXaYnQC5tUzxzlpA3WVYF7/opLeUgcQs/o=
github.com/magiconair/properties v1.8.7 h1:IeQXZAiQcpL9mgcAe1Nu6cX9LLw6ExEHKjN0VQdvPDY=
github.com/magiconair/properties v1.8.7/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=
github.com/marcboeker/go-duckdb v1.7.0 h1:c9DrS13ta+gqVgg9DiEW8I+PZBE85nBMLL/YMooYoUY=
github.com/marcboeker/go-duckdb v1.7.0/go.mod h1:WtWeqqhZoTke/Nbd7V9lnBx7I2/A/q0SAq/urGzPCMs=
github.com/mattn/go-colorable v0.1.9/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=
github.com/mattn/go-colorable v0.1.12/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=
github.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.19 h1:JITubQf0MOLdlGRuRq+jtsDlekdYPia9ZFsB8h/APPA=
github.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=
github.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mattn/go-sqlite3 v1.14.14/go.mod h1:NyWgC/yNuGj7Q9rpYnZvas74GogHl5/Z4A/KQRfk6bU=
github.com/mattn/go-sqlite3 v1.14.16 h1:yOQRA0RpS5PFz/oikGwBEqvAWhWg5ufRz4ETLjwpU1Y=
github.com/mattn/go-sqlite3 v1.14.16/go.mod h1:2eHXhiwb8IkHr+BDWZGa96P6+rkvnG63S2DGjv9HUNg=
github.com/mdelapenya/tlscert v0.1.0 h1:YTpF579PYUX475eOL+6zyEO3ngLTOUWck78NBuJVXaM=
github.com/mdelapenya/tlscert v0.1.0/go.mod h1:wrbyM/DwbFCeCeqdPX/8c6hNOqQgbf0rUDErE1uD+64=
github.com/microsoft/go-mssqldb v1.7.0 h1:sgMPW0HA6Ihd37Yx0MzHyKD726C2kY/8KJsQtXHNaAs=
github.com/microsoft/go-mssqldb v1.7.0/go.mod h1:kOvZKUdrhhFQmxLZqbwUV0rHkNkZpthMITIb2Ko1IoA=
github.com/minio/asm2plan9s v0.0.0-20200509001527-cdd76441f9d8 h1:AMFGa4R4MiIpspGNG7Z948v4n35fFGB3RR3G/ry4FWs=
github.com/minio/asm2plan9s v0.0.0-20200509001527-cdd76441f9d8/go.mod h1:mC1jAcsrzbxHt8iiaC+zU4b1ylILSosueou12R++wfY=
github.com/minio/c2goasm v0.0.0-20190812172519-36a3d3bbc4f3 h1:+n/aFZefKZp7spd8DFdX7uMikMLXX4oubIzJF4kv/wI=
github.com/minio/c2goasm v0.0.0-20190812172519-36a3d3bbc4f3/go.mod h1:RagcQ7I8IeTMnF8JTXieKnO4Z6JCsikNEzj0DwauVzE=
github.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=
github.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=
github.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=
github.com/moby/patternmatcher v0.6.0 h1:GmP9lR19aU5GqSSFko+5pRqHi+Ohk1O69aFiKkVGiPk=
github.com/moby/patternmatcher v0.6.0/go.mod h1:hDPoyOpDY7OrrMDLaYoY3hf52gNCR/YOUYxkhApJIxc=
github.com/moby/sys/sequential v0.5.0 h1:OPvI35Lzn9K04PBbCLW0g4LcFAJgHsvXsRyewg5lXtc=
github.com/moby/sys/sequential v0.5.0/go.mod h1:tH2cOOs5V9MlPiXcQzRC+eEyab644PWKGRYaaV5ZZlo=
github.com/moby/sys/user v0.1.0 h1:WmZ93f5Ux6het5iituh9x2zAG7NFY9Aqi49jjE1PaQg=
github.com/moby/sys/user v0.1.0/go.mod h1:fKJhFOnsCN6xZ5gSfbM6zaHGgDJMrqt9/reuj4T7MmU=
github.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=
github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
github.com/montanaflynn/stats v0.0.0-20171201202039-1bf9dbcd8cbe/go.mod h1:wL8QJuTMNUDYhXwkmfOly8iTdp5TEcJFWZD2D7SIkUc=
github.com/montanaflynn/stats v0.6.6 h1:Duep6KMIDpY4Yo11iFsvyqJDyfzLF9+sndUKT+v64GQ=
github.com/montanaflynn/stats v0.6.6/go.mod h1:etXPPgVO6n31NxCd9KQUMvCM+ve0ruNzt6R8Bnaayow=
github.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=
github.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=
github.com/neovim/go-client v1.2.1 h1:kl3PgYgbnBfvaIoGYi3ojyXH0ouY6dJY/rYUCssZKqI=
github.com/neovim/go-client v1.2.1/go.mod h1:EeqCP3z1vJd70JTaH/KXz9RMZ/nIgEFveX83hYnh/7c=
github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
github.com/paulmach/orb v0.11.1 h1:3koVegMC4X/WeiXYz9iswopaTwMem53NzTJuTF20JzU=
github.com/paulmach/orb v0.11.1/go.mod h1:5mULz1xQfs3bmQm63QEJA6lNGujuRafwA5S/EnuLaLU=
github.com/paulmach/protoscan v0.2.1/go.mod h1:SpcSwydNLrxUGSDvXvO0P7g7AuhJ7lcKfDlhJCDw2gY=
github.com/phpdave11/gofpdf v1.4.2/go.mod h1:zpO6xFn9yxo3YLyMvW8HcKWVdbNqgIfOOp2dXMnm1mY=
github.com/phpdave11/gofpdi v1.0.12/go.mod h1:vBmVV0Do6hSBHC8uKUQ71JGW+ZGQq74llk/7bXwjDoI=
github.com/phpdave11/gofpdi v1.0.13/go.mod h1:vBmVV0Do6hSBHC8uKUQ71JGW+ZGQq74llk/7bXwjDoI=
github.com/pierrec/lz4/v4 v4.1.15/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=
github.com/pierrec/lz4/v4 v4.1.21 h1:yOVMLb6qSIDP67pl/5F7RepeKYu/VmTyEXvuMI5d9mQ=
github.com/pierrec/lz4/v4 v4.1.21/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c h1:+mdjkGKdHQG3305AYmdv1U2eRNDiU2ErMBj1gwrq8eQ=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c/go.mod h1:7rwL4CYBLnjLxUqIJNnCWiEdr3bn6IUYi15bNlnbCCU=
github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=
github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/sftp v1.10.1/go.mod h1:lYOWFsE0bwd1+KfKJaKeuokY15vzFx25BLbzYYoAxZI=
github.com/pkg/sftp v1.13.1/go.mod h1:3HaPG6Dq1ILlpPZRO0HVMrsydcdLt6HRDccSgb87qRg=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c h1:ncq/mPwQF4JjgDlrVEn3C11VoGHZN7m8qihwgMEtzYw=
github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/client_model v0.3.0/go.mod h1:LDGWKZIo7rky3hgvBe+caln+Dr3dPggB5dvjtD7w9+w=
github.com/redis/go-redis/v9 v9.0.2 h1:BA426Zqe/7r56kCcvxYLWe1mkaz71LKF77GwgFzSxfE=
github.com/redis/go-redis/v9 v9.0.2/go.mod h1:/xDTe9EF1LM61hek62Poq2nzQSGj0xSrEtEHbBQevps=
github.com/remyoudompheng/bigfft v0.0.0-20200410134404-eec4a21b6bb0/go.mod h1:qqbHyh8v60DhA7CoWK5oRCqLrMHRGoxYCSS9EjAz6Eo=
github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec h1:W09IVJc94icq4NjY3clb7Lk8O1qJ8BdBEF8z0ibU0rE=
github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec/go.mod h1:qqbHyh8v60DhA7CoWK5oRCqLrMHRGoxYCSS9EjAz6Eo=
github.com/rivo/uniseg v0.2.0 h1:S1pD9weZBuJdFmowNwbpi7BJ8TNftyUImj/0WQi72jY=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=
github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
github.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/rogpeppe/go-internal v1.10.0 h1:TMyTOH3F/DB16zRVcYyreMH6GnZZrwQVAoYjRBZyWFQ=
github.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=
github.com/rs/xid v1.5.0/go.mod h1:trrq9SKmegXys3aeAKXMUTdJsYXVwGY3RLcfgqegfbg=
github.com/rs/zerolog v1.32.0 h1:keLypqrlIjaFsbmJOBdB/qvyF8KEtCWHwobLp5l/mQ0=
github.com/rs/zerolog v1.32.0/go.mod h1:/7mN4D5sKwJLZQ2b/znpjC3/GQWY/xaDXUM0kKWRHss=
github.com/ruudk/golang-pdf417 v0.0.0-20181029194003-1af4ab5afa58/go.mod h1:6lfFZQK844Gfx8o5WFuvpxWRwnSoipWe/p622j1v06w=
github.com/ruudk/golang-pdf417 v0.0.0-20201230142125-a7e3863a1245/go.mod h1:pQAZKsJ8yyVxGRWYNEm9oFB8ieLgKFnamEyDmSA0BRk=
github.com/segmentio/asm v1.2.0 h1:9BQrFxC+YOHJlTlHGkTrFWf59nbL3XnCoFLTwDCI7ys=
github.com/segmentio/asm v1.2.0/go.mod h1:BqMnlJP91P8d+4ibuonYZw9mfnzI9HfxselHZr5aAcs=
github.com/shirou/gopsutil/v3 v3.23.12 h1:z90NtUkp3bMtmICZKpC4+WaknU1eXtp5vtbQ11DgpE4=
github.com/shirou/gopsutil/v3 v3.23.12/go.mod h1:1FrWgea594Jp7qmjHUUPlJDTPgcsb9mGnXDxavtikzM=
github.com/shoenig/go-m1cpu v0.1.6 h1:nxdKQNcEB6vzgA2E2bvzKIYRuNj7XNJ4S/aRSwKzFtM=
github.com/shoenig/go-m1cpu v0.1.6/go.mod h1:1JJMcUBvfNwpq05QDQVAnx3gUHr9IYF7GNg9SUEw2VQ=
github.com/shoenig/test v0.6.4 h1:kVTaSd7WLz5WZ2IaoM0RSzRsUD+m8wRR+5qvntpn4LU=
github.com/shoenig/test v0.6.4/go.mod h1:byHiCGXqrVaflBLAMq/srcZIHynQPQgeyvkvXnjqq0k=
github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8=
github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
github.com/sijms/go-ora/v2 v2.7.6 h1:QyR1CKFxG+VVk2+LdHoHF4NxDSvcQ3deBXtZCrahSq4=
github.com/sijms/go-ora/v2 v2.7.6/go.mod h1:EHxlY6x7y9HAsdfumurRfTd+v8NrEOTR3Xl4FWlH6xk=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=
github.com/spf13/afero v1.3.3/go.mod h1:5KUK8ByomD5Ti5Artl0RtHeI5pTF7MIDuXL3yY520V4=
github.com/spf13/afero v1.6.0/go.mod h1:Ai8FlHk4v/PARR026UzYexafAt9roJ7LcLMAmO6Z93I=
github.com/spf13/afero v1.9.2/go.mod h1:iUV7ddyEEZPO5gA3zD4fJt6iStLlL+Lg4m2cihcDf8Y=
github.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.8.3/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/testcontainers/testcontainers-go v0.35.0 h1:uADsZpTKFAtp8SLK+hMwSaa+X+JiERHtd4sQAFmXeMo=
github.com/testcontainers/testcontainers-go v0.35.0/go.mod h1:oEVBj5zrfJTrgjwONs1SsRbnBtH9OKl+IGl3UMcr2B4=
github.com/testcontainers/testcontainers-go/modules/clickhouse v0.35.0 h1:A4NESGwof4RK+i/pjL0lAVu0JxNZIvLR35ZFB9DKgYQ=
github.com/testcontainers/testcontainers-go/modules/clickhouse v0.35.0/go.mod h1:nT0LQ4rqTljX5Ub0Q3GdFrVXRYSrjK6p7RuJPpUE4wg=
github.com/testcontainers/testcontainers-go/modules/gcloud v0.35.0 h1:8tdSCu4ey2ye3pXjo4I0GPcnYZb66dJN3qN6Ebqpjcg=
github.com/testcontainers/testcontainers-go/modules/gcloud v0.35.0/go.mod h1:jtvudSR4XxV/NTRHfhD5/wf2xlF5OPuiQmNSB0PM6XM=
github.com/testcontainers/testcontainers-go/modules/mysql v0.35.0 h1:9voGAf+1KxC0ck/XtrC/AUrkr74SSGpQRBp0O851B3Y=
github.com/testcontainers/testcontainers-go/modules/mysql v0.35.0/go.mod h1:rxKSkFpc5XZtG00prjqPfobuMgt5EpFEOrzZgYdOX0c=
github.com/testcontainers/testcontainers-go/modules/mssql v0.35.0 h1:TNyqxHauRH1p15HSD8G2clhkJXnsRFHX3jcCyS6omd4=
github.com/testcontainers/testcontainers-go/modules/mssql v0.35.0/go.mod h1:nlWjcJ0Jw4XuuDd95v1qbAFnwpeaYRloF0BPS6AW1RQ=
github.com/testcontainers/testcontainers-go/modules/postgres v0.35.0 h1:eEGx9kYzZb2cNhRbBrNOCL/YPOM7+RMJiy3bB+ie0/I=
github.com/testcontainers/testcontainers-go/modules/postgres v0.35.0/go.mod h1:hfH71Mia/WWLBgMD2YctYcMlfsbnT0hflweL1dy8Q4s=
github.com/tidwall/pretty v1.0.0/go.mod h1:XNkn88O1ChpSDQmQeStsy+sBenx6DDtFZJxhVysOjyk=
github.com/tidwall/pretty v1.2.0 h1:RWIZEg2iJ8/g6fDDYzMpobmaoGh5OLl4AXtGUGPcqCs=
github.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
github.com/tklauser/go-sysconf v0.3.12 h1:0QaGUFOdQaIVdPgfITYzaTegZvdCjmYO52cSFAEVmqU=
github.com/tklauser/go-sysconf v0.3.12/go.mod h1:Ho14jnntGE1fpdOqQEEaiKRpvIavV0hSfmBq8nJbHYI=
github.com/tklauser/numcpus v0.6.1 h1:ng9scYS7az0Bk4OZLvrNXNSAO2Pxr1XXRAPyjhIx+Fk=
github.com/tklauser/numcpus v0.6.1/go.mod h1:1XfjsgE2zo8GVw7POkMbHENHzVg3GzmoZ9fESEdAacY=
github.com/xdg-go/pbkdf2 v1.0.0 h1:Su7DPu48wXMwC3bs7MCNG+z4FhcyEuz5dlvchbq0B0c=
github.com/xdg-go/pbkdf2 v1.0.0/go.mod h1:jrpuAogTd400dnrH08LKmI/xc1MbPOebTwRqcT5RDeI=
github.com/xdg-go/scram v1.1.1 h1:VOMT+81stJgXW3CpHyqHN3AXDYIMsx56mEFrB37Mb/E=
github.com/xdg-go/scram v1.1.1/go.mod h1:RaEWvsqvNKKvBPvcKeFjrG2cJqOkHTiyTpzz23ni57g=
github.com/xdg-go/stringprep v1.0.3 h1:kdwGpVNwPFtjs98xCGkHjQtGKh86rDcRZN17QEMCOIs=
github.com/xdg-go/stringprep v1.0.3/go.mod h1:W3f5j4i+9rC0kuIEJL0ky1VpHXQU3ocBgklLGvcBnW8=
github.com/youmark/pkcs8 v0.0.0-20181117223130-1be2e3e5546d h1:splanxYIlg+5LfHAM6xpdFEAYOk8iySO56hMFq6uLyA=
github.com/youmark/pkcs8 v0.0.0-20181117223130-1be2e3e5546d/go.mod h1:rHwXgn7JulP+udvsHwJoVG1YGAP6VLg4y9I5dyZdqmA=
github.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=
github.com/yuin/goldmark v1.4.1/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
github.com/yusufpapurcu/wmi v1.2.3 h1:E1ctvB7uKFMOJw3fdOW32DwGE9I7t++CRUEMKvFoFiw=
github.com/yusufpapurcu/wmi v1.2.3/go.mod h1:SBZ9tNy3G9/m5Oi98Zks0QjeHVDvuK0qfxQmPyzfmi0=
github.com/zeebo/assert v1.3.0 h1:g7C04CbJuIDKNPFHmsk4hwZDO5O+kntRxzaUoNXj+IQ=
github.com/zeebo/assert v1.3.0/go.mod h1:Pq9JiuJQpG8JLJdtkwrJESF0Foym2/D9XMU5ciN/wJ0=
github.com/zeebo/xxh3 v1.0.2 h1:xZmwmqxHZA8AI603jOQ0tMqmBr9lPeFwGg6d+xy9DC0=
github.com/zeebo/xxh3 v1.0.2/go.mod h1:5NWz9Sef7zIDm2JHfFlcQvNekmcEl9ekUZQQKCYaDcA=
go.mongodb.org/mongo-driver v1.11.4/go.mod h1:PTSz5yu21bkT/wXpkS7WR5f0ddqw5quethTUn9WM+2g=
go.mongodb.org/mongo-driver v1.11.6 h1:XM7G6PjiGAO5betLF13BIa5TlLUUE3uJ/2Ox3Lz1K+o=
go.mongodb.org/mongo-driver v1.11.6/go.mod h1:G9TgswdsWjX4tmDA5zfs2+6AEPpYJwqblyjsfuh8oXY=
go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
go.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=
go.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=
go.opencensus.io v0.23.0/go.mod h1:XItmlyltB5F7CS4xOC1DcqMoFqwtC6OG2xF7mCv7P7E=
go.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=
go.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 h1:4Pp6oUg3+e/6M4C0A/3kJ2VYa++dsWVTtGgLVj5xtHg=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0/go.mod h1:Mjt1i1INqiaoZOMGR1RIUJN+i3ChKoFRqzrRQhlkbs0=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 h1:jq9TW8u3so/bN+JPT166wjOI6/vQPF6Xe7nMNIltagk=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0/go.mod h1:p8pYQP+m5XfbZm9fxtSKAbM6oIllS7s2AfxrChvc7iw=
go.opentelemetry.io/otel v1.24.0 h1:0LAOdjNmQeSTzGBzduGe/rU4tZhMwL5rWgtp9Ku5Jfo=
go.opentelemetry.io/otel v1.24.0/go.mod h1:W7b9Ozg4nkF5tWI5zsXkaKKDjdVjpD4oAt9Qi/MArHo=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.19.0 h1:Mne5On7VWdx7omSrSSZvM4Kw7cS7NQkOOmLcgscI51U=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.19.0/go.mod h1:IPtUMKL4O3tH5y+iXVyAXqpAwMuzC1IrxVS81rummfE=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.19.0 h1:IeMeyr1aBvBiPVYihXIaeIZba6b8E1bYp7lbdxK8CQg=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.19.0/go.mod h1:oVdCUtjq9MK9BlS7TtucsQwUcXcymNiEDjgDD2jMtZU=
go.opentelemetry.io/otel/metric v1.24.0 h1:6EhoGWWK28x1fbpA4tYTOWBkPefTDQnb8WSGXlc88kI=
go.opentelemetry.io/otel/metric v1.24.0/go.mod h1:VYhLe1rFfxuTXLgj4CBiyz+9WYBA8pNGJgDcSFRKBco=
go.opentelemetry.io/otel/sdk v1.24.0 h1:YMPPDNymmQN3ZgczicBY3B6sf9n62Dlj9pWD3ucgoDw=
go.opentelemetry.io/otel/sdk v1.24.0/go.mod h1:KVrIYw6tEubO9E96HQpcmpTKDVn9gdv35HoYiQWGDFg=
go.opentelemetry.io/otel/trace v1.24.0 h1:CsKnnL4dUAr/0llH9FKuc698G04IrpWV0MQA/Y1YELI=
go.opentelemetry.io/otel/trace v1.24.0/go.mod h1:HPc3Xr/cOApsBI154IU0OI0HJexz+aw5uPdbs3UCjNU=
go.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=
go.opentelemetry.io/proto/otlp v0.15.0/go.mod h1:H7XAot3MsfNsj7EXtrA2q5xSNQ10UqI405h3+duxN4U=
go.opentelemetry.io/proto/otlp v0.19.0/go.mod h1:H7XAot3MsfNsj7EXtrA2q5xSNQ10UqI405h3+duxN4U=
go.opentelemetry.io/proto/otlp v1.0.0 h1:T0TX0tmXU8a3CbNXzEKGeU5mIVOdf0oykP+u2lIVU/I=
go.opentelemetry.io/proto/otlp v1.0.0/go.mod h1:Sy6pihPLfYHkr3NkUbEhGHFhINUSI/v80hjKIs5JXpM=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190911031432-227b76d455e7/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.0.0-20211108221036-ceb1ce70b4fa/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/crypto v0.6.0/go.mod h1:OFC/31mSvZgRz0V1QTNCzfAI1aIRzbiufJtkMIlEp58=
golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
golang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=
golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
golang.org/x/exp v0.0.0-20180321215751-8460e604b9de/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20180807140117-3d87b88a115f/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190125153040-c74c464bbbf2/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
golang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=
golang.org/x/exp v0.0.0-20191002040644-a1355ae1e2c3/go.mod h1:NOZ3BPKG0ec/BKJQgnvsSFpcKLM5xXVWnvZS97DWHgE=
golang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=
golang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=
golang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=
golang.org/x/exp v0.0.0-20220827204233-334a2380cb91/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=
golang.org/x/image v0.0.0-20180708004352-c73c2afc3b81/go.mod h1:ux5Hcp/YLpHSI86hEcLt0YII63i6oz57MZXIpbrjZUs=
golang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=
golang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/image v0.0.0-20190910094157-69e4b8554b2a/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/image v0.0.0-20200119044424-58c23975cae1/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/image v0.0.0-20200430140353-33d19683fad8/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/image v0.0.0-20200618115811-c13761719519/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/image v0.0.0-20201208152932-35266b937fa6/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/image v0.0.0-20210216034530-4410531fe030/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/image v0.0.0-20210607152325-775e3b0c77b9/go.mod h1:023OzeP/+EPmXeapQh35lcL3II3LrY8Ic+EFFKVhULM=
golang.org/x/image v0.0.0-20210628002857-a66eb6448b8d/go.mod h1:023OzeP/+EPmXeapQh35lcL3II3LrY8Ic+EFFKVhULM=
golang.org/x/image v0.0.0-20211028202545-6944b10bf410/go.mod h1:023OzeP/+EPmXeapQh35lcL3II3LrY8Ic+EFFKVhULM=
golang.org/x/image v0.0.0-20220302094943-723b81ca9867/go.mod h1:023OzeP/+EPmXeapQh35lcL3II3LrY8Ic+EFFKVhULM=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=
golang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/lint v0.0.0-20201208152925-83fdc39ff7b5/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/lint v0.0.0-20210508222113-6edffad5e616/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=
golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=
golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.5.0/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=
golang.org/x/mod v0.5.1/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/mod v0.7.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.9.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=
golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201031054903-ff519b6c9102/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201209123823-ac852fbbde11/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20201224014010-6772e930b67b/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20210119194325-5f4716e94777/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20210316092652-d523dce5a7f4/go.mod h1:RBQZq4jEuRlivfhVLdyRGr576XBO4/greRjx4P4O3yc=
golang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=
golang.org/x/net v0.0.0-20210503060351-7fd8e65b6420/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20210813160813-60bc85c4be6d/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20211015210444-4f30a5c0130f/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
golang.org/x/net v0.0.0-20220225172249-27dd8689420f/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
golang.org/x/net v0.0.0-20220325170049-de3da57026de/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
golang.org/x/net v0.0.0-20220412020605-290c469a71a5/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
golang.org/x/net v0.0.0-20220425223048-2871e0cb64e4/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
golang.org/x/net v0.0.0-20220607020251-c690dde0001d/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.0.0-20220617184016-355a448f1bc9/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.0.0-20220624214902-1bab6f366d9e/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.0.0-20220909164309-bea034e7d591/go.mod h1:YDH+HFinaLZZlnHAfSS6ZXJJ9M9t4Dl22yv3iI2vPwk=
golang.org/x/net v0.0.0-20221012135044-0b7e1fb9d458/go.mod h1:YDH+HFinaLZZlnHAfSS6ZXJJ9M9t4Dl22yv3iI2vPwk=
golang.org/x/net v0.0.0-20221014081412-f15817d10f9b/go.mod h1:YDH+HFinaLZZlnHAfSS6ZXJJ9M9t4Dl22yv3iI2vPwk=
golang.org/x/net v0.2.0/go.mod h1:KqCZLdyyvdV855qA2rE3GC2aiw5xGR5TEjj8smXukLY=
golang.org/x/net v0.3.0/go.mod h1:MBQ8lrhLObU/6UmLb4fmbmk5OcyYmqtbGd/9yIeKjEE=
golang.org/x/net v0.4.0/go.mod h1:MBQ8lrhLObU/6UmLb4fmbmk5OcyYmqtbGd/9yIeKjEE=
golang.org/x/net v0.5.0/go.mod h1:DivGGAXEgPSlEBzxGzZI+ZLohi+xUj054jfeKui00ws=
golang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.7.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.8.0/go.mod h1:QVkue5JL9kW//ek3r6jTKnTFis1tRmNAW2P1shuFdJc=
golang.org/x/net v0.9.0/go.mod h1:d48xBJpPfHeWQsugry2m+kC02ZBRGRgulfHnEXEuWns=
golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=
golang.org/x/net v0.27.0 h1:5K3Njcw06/l2y9vpGCSdcxWOYHOUk3dVNGDXN+FvAys=
golang.org/x/net v0.27.0/go.mod h1:dDi0PyhWNoiUOrAS8uXv/vnScO4wnHQO4mj9fn/RytE=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20200902213428-5d25da1a8d43/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20201109201403-9fd604954f58/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20201208152858-08078c50e5b5/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210218202405-ba52d332ba99/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210220000619-9bb904979d93/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210313182246-cd4f82c27b84/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210514164344-f6687ab2804c/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210628180205-a41e5a781914/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210805134026-6f1e6394065a/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210819190943-2bc19b11175f/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20211104180415-d3ed0bb246c8/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20220223155221-ee480838109b/go.mod h1:DAh4E804XQdzx2j+YRIaUnCqCV2RuMz24cGBJ5QYIrc=
golang.org/x/oauth2 v0.0.0-20220309155454-6242fa91716a/go.mod h1:DAh4E804XQdzx2j+YRIaUnCqCV2RuMz24cGBJ5QYIrc=
golang.org/x/oauth2 v0.0.0-20220411215720-9780585627b5/go.mod h1:DAh4E804XQdzx2j+YRIaUnCqCV2RuMz24cGBJ5QYIrc=
golang.org/x/oauth2 v0.0.0-20220608161450-d0670ef3b1eb/go.mod h1:jaDAt6Dkxork7LmZnYtzbRWj0W47D86a3TGe0YHBvmE=
golang.org/x/oauth2 v0.0.0-20220622183110-fd043fe589d2/go.mod h1:jaDAt6Dkxork7LmZnYtzbRWj0W47D86a3TGe0YHBvmE=
golang.org/x/oauth2 v0.0.0-20220822191816-0ebed06d0094/go.mod h1:h4gKUeWbJ4rQPri7E0u6Gs4e9Ri2zaLxzw5DI5XGrYg=
golang.org/x/oauth2 v0.0.0-20220909003341-f21342109be1/go.mod h1:h4gKUeWbJ4rQPri7E0u6Gs4e9Ri2zaLxzw5DI5XGrYg=
golang.org/x/oauth2 v0.0.0-20221006150949-b44042a4b9c1/go.mod h1:h4gKUeWbJ4rQPri7E0u6Gs4e9Ri2zaLxzw5DI5XGrYg=
golang.org/x/oauth2 v0.0.0-20221014153046-6fdb5e3db783/go.mod h1:h4gKUeWbJ4rQPri7E0u6Gs4e9Ri2zaLxzw5DI5XGrYg=
golang.org/x/oauth2 v0.3.0/go.mod h1:rQrIauxkUhJ6CuwEXwymO2/eh4xz2ZWF1nBkcxS+tGk=
golang.org/x/oauth2 v0.4.0/go.mod h1:RznEsdpjGAINPTOF0UH/t+xJ75L18YO3Ho6Pyn+uRec=
golang.org/x/oauth2 v0.5.0/go.mod h1:9/XBHVqLaWO3/BRHs5jbpYCnOZVjj5V0ndyaAM7KB4I=
golang.org/x/oauth2 v0.6.0/go.mod h1:ycmewcwgD4Rpr3eZJLSB4Kyyljb3qDh40vJ8STE5HKw=
golang.org/x/oauth2 v0.7.0/go.mod h1:hPLQkd9LyjfXTiRohC/41GhcFqxisoUQ99sCUOHO9x4=
golang.org/x/oauth2 v0.21.0 h1:tsimM75w1tF/uws5rbeHzIWxEqElMehnc+iW793zsZs=
golang.org/x/oauth2 v0.21.0/go.mod h1:XYTD2NtWslqkgxebSiOHnXEap4TF09sJSc7H1sXbhtI=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220601150217-0de741cfad7f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220819030929-7fc1605a5dde/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220929204114-8fcdb60fdcc0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=
golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200803210538-64077c9b5642/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200905004654-be1d3432aa8f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201201145000-ef89a241ccb3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201204225414-ed752295db88/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210104204734-6f8348627aad/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210220050731-9a76102bfb43/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210225134936-a50acf3fe073/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210304124612-50617c2ba197/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210305230114-8fe3ee5dd75b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210315160823-c6e025ad8005/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423185535-09eb48e85fd7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210514084401-e8d321eab015/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210603125802-9665404d3644/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210806184541-e5e7981a1069/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210816183151-1e6c022a8912/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210823070655-63515b42dcdf/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210908233432-aa78b53d3365/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211007075335-d3039528d8ac/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211019181941-9d821ace8654/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211124211545-fe61309f8881/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211210111614-af8b64212486/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220128215802-99c3d69c2c27/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220209214540-3681064d5158/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220227234510-4e6760a101f9/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220328115105-d36c6a25d886/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220412211240-33da011f77ad/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220502124256-b6088ccd6cba/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220503163025-988cb79eb6c6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220610221304-9f5ed59c137d/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220615213510-4f61da869c0c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220624220833-87e55d714810/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220728004956-3c1f35247d10/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220829200755-d48e67d00261/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220908164124-27713097b956/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.3.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.7.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.15.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=
golang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.0.0-20220526004731-065cf7ba2467/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.2.0/go.mod h1:TVmDHMZPmdnySmBfhjOoOdhjzdE1h4u1VwSiw2l1Nuc=
golang.org/x/term v0.3.0/go.mod h1:q750SLmJuPmVoN1blW3UFBPREJfb1KmY3vwxfr+nFDA=
golang.org/x/term v0.4.0/go.mod h1:9P2UbLfCdcvo3p/nzKvsmas4TnlujnuoV9hGgYzW1lQ=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/term v0.6.0/go.mod h1:m6U89DPEgQRMq3DNkDClhWw02AUbt2daBVO4cn4Hv9U=
golang.org/x/term v0.7.0/go.mod h1:P32HKFT3hSsZrRxla30E9HqToFYAQPCMs/zFMBUFqPY=
golang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=
golang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=
golang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=
golang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.5.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.6.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.8.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=
golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20220922220347-f3bd1da661af/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.1.0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.3.0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=
golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
golang.org/x/tools v0.0.0-20180525024113-a5b4c53f6e8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190206041539-40960b6deb8e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20190927191325-030b2cf1153e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
golang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
golang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=
golang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200618134242-20370b0cb4b2/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82ur9kSqwfTHTeVxaDqrfMjpcNT6bE=
golang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20201124115921-2c860bdd6e78/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210105154028-b0ab187a4818/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210108195828-e2f9c7f1fc8e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=
golang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/tools v0.1.2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/tools v0.1.3/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/tools v0.1.4/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/tools v0.1.9/go.mod h1:nABZi5QlRsZVlzPpHl034qft6wpY4eDcsTt5AaioBiU=
golang.org/x/tools v0.1.11/go.mod h1:SgwaegtQh8clINPpECJMqnxLv9I09HLqnW3RMqW0CA4=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.3.0/go.mod h1:/rWhSS2+zyEVwoJf8YAX6L2f0ntZ7Kn/mGgAWcipA5k=
golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
golang.org/x/tools v0.7.0/go.mod h1:4pg6aUX35JBAogB10C9AtvVL+qowtN4pT3CGSQex14s=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20220411194840-2f41105eb62f/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20220517211312-f3a8303e98df/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=
golang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=
golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=
golang.org/x/xerrors v0.0.0-20231012003039-104605ab7028 h1:+cNy6SZtPcJQH3LJVLOSmiC7MMxXNOb3PU/VUEz+EhU=
golang.org/x/xerrors v0.0.0-20231012003039-104605ab7028/go.mod h1:NDW/Ps6MPRej6fsCIbMTohpP40sJ/P/vI1MoTEGwX90=
gonum.org/v1/gonum v0.0.0-20180816165407-929014505bf4/go.mod h1:Y+Yx5eoAFn32cQvJDxZx5Dpnq+c3wtXuadVZAcxbbBo=
gonum.org/v1/gonum v0.8.2/go.mod h1:oe/vMfY3deqTw+1EZJhuvEW2iwGF1bW9wwu7XCu0+v0=
gonum.org/v1/gonum v0.9.3/go.mod h1:TZumC3NeyVQskjXqmyWt4S3bINhy7B4eYwW69EbyX+0=
gonum.org/v1/gonum v0.11.0/go.mod h1:fSG4YDCxxUZQJ7rKsQrj0gMOg00Il0Z96/qMA4bVQhA=
gonum.org/v1/gonum v0.12.0 h1:xKuo6hzt+gMav00meVPUlXwSdoEJP46BR+wdxQEFK2o=
gonum.org/v1/gonum v0.12.0/go.mod h1:73TDxJfAAHeA8Mk9mf8NlIppyhQNo5GLTcYeqgo2lvY=
gonum.org/v1/netlib v0.0.0-20190313105609-8cb42192e0e0/go.mod h1:wa6Ws7BG/ESfp6dHfk7C6KdzKA7wR7u/rKwOGE66zvw=
gonum.org/v1/plot v0.0.0-20190515093506-e2840ee46a6b/go.mod h1:Wt8AAjI+ypCyYX3nZBvf6cAIx93T+c/OS2HFAYskSZc=
gonum.org/v1/plot v0.9.0/go.mod h1:3Pcqqmp6RHvJI72kgb8fThyUnav364FOsdDo2aGW5lY=
gonum.org/v1/plot v0.10.1/go.mod h1:VZW5OlhkL1mysU9vaqNHnsy86inf6Ot+jB3r+BczCEo=
google.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=
google.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=
google.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
google.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
google.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
google.golang.org/api v0.28.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
google.golang.org/api v0.29.0/go.mod h1:Lcubydp8VUV7KeIHD9z2Bys/sm/vGKnG1UHuDBSrHWM=
google.golang.org/api v0.30.0/go.mod h1:QGmEvQ87FHZNiUVJkT14jQNYJ4ZJjdRF23ZXz5138Fc=
google.golang.org/api v0.35.0/go.mod h1:/XrVsuzM0rZmrsbjJutiuftIzeuTQcEeaYcSk/mQ1dg=
google.golang.org/api v0.36.0/go.mod h1:+z5ficQTmoYpPn8LCUNVpK5I7hwkpjbcgqA7I34qYtE=
google.golang.org/api v0.40.0/go.mod h1:fYKFpnQN0DsDSKRVRcQSDQNtqWPfM9i+zNPxepjRCQ8=
google.golang.org/api v0.41.0/go.mod h1:RkxM5lITDfTzmyKFPt+wGrCJbVfniCr2ool8kTBzRTU=
google.golang.org/api v0.43.0/go.mod h1:nQsDGjRXMo4lvh5hP0TKqF244gqhGcr/YSIykhUk/94=
google.golang.org/api v0.47.0/go.mod h1:Wbvgpq1HddcWVtzsVLyfLp8lDg6AA241LmgIL59tHXo=
google.golang.org/api v0.48.0/go.mod h1:71Pr1vy+TAZRPkPs/xlCf5SsU8WjuAWv1Pfjbtukyy4=
google.golang.org/api v0.50.0/go.mod h1:4bNT5pAuq5ji4SRZm+5QIkjny9JAyVD/3gaSihNefaw=
google.golang.org/api v0.51.0/go.mod h1:t4HdrdoNgyN5cbEfm7Lum0lcLDLiise1F8qDKX00sOU=
google.golang.org/api v0.54.0/go.mod h1:7C4bFFOvVDGXjfDTAsgGwDgAxRDeQ4X8NvUedIt6z3k=
google.golang.org/api v0.55.0/go.mod h1:38yMfeP1kfjsl8isn0tliTjIb1rJXcQi4UXlbqivdVE=
google.golang.org/api v0.56.0/go.mod h1:38yMfeP1kfjsl8isn0tliTjIb1rJXcQi4UXlbqivdVE=
google.golang.org/api v0.57.0/go.mod h1:dVPlbZyBo2/OjBpmvNdpn2GRm6rPy75jyU7bmhdrMgI=
google.golang.org/api v0.61.0/go.mod h1:xQRti5UdCmoCEqFxcz93fTl338AVqDgyaDRuOZ3hg9I=
google.golang.org/api v0.63.0/go.mod h1:gs4ij2ffTRXwuzzgJl/56BdwJaA194ijkfn++9tDuPo=
google.golang.org/api v0.67.0/go.mod h1:ShHKP8E60yPsKNw/w8w+VYaj9H6buA5UqDp8dhbQZ6g=
google.golang.org/api v0.70.0/go.mod h1:Bs4ZM2HGifEvXwd50TtW70ovgJffJYw2oRCOFU/SkfA=
google.golang.org/api v0.71.0/go.mod h1:4PyU6e6JogV1f9eA4voyrTY2batOLdgZ5qZ5HOCc4j8=
google.golang.org/api v0.74.0/go.mod h1:ZpfMZOVRMywNyvJFeqL9HRWBgAuRfSjJFpe9QtRRyDs=
google.golang.org/api v0.75.0/go.mod h1:pU9QmyHLnzlpar1Mjt4IbapUCy8J+6HD6GeELN69ljA=
google.golang.org/api v0.77.0/go.mod h1:pU9QmyHLnzlpar1Mjt4IbapUCy8J+6HD6GeELN69ljA=
google.golang.org/api v0.78.0/go.mod h1:1Sg78yoMLOhlQTeF+ARBoytAcH1NNyyl390YMy6rKmw=
google.golang.org/api v0.80.0/go.mod h1:xY3nI94gbvBrE0J6NHXhxOmW97HG7Khjkku6AFB3Hyg=
google.golang.org/api v0.84.0/go.mod h1:NTsGnUFJMYROtiquksZHBWtHfeMC7iYthki7Eq3pa8o=
google.golang.org/api v0.85.0/go.mod h1:AqZf8Ep9uZ2pyTvgL+x0D3Zt0eoT9b5E8fmzfu6FO2g=
google.golang.org/api v0.90.0/go.mod h1:+Sem1dnrKlrXMR/X0bPnMWyluQe4RsNoYfmNLhOIkzw=
google.golang.org/api v0.93.0/go.mod h1:+Sem1dnrKlrXMR/X0bPnMWyluQe4RsNoYfmNLhOIkzw=
google.golang.org/api v0.95.0/go.mod h1:eADj+UBuxkh5zlrSntJghuNeg8HwQ1w5lTKkuqaETEI=
google.golang.org/api v0.96.0/go.mod h1:w7wJQLTM+wvQpNf5JyEcBoxK0RH7EDrh/L4qfsuJ13s=
google.golang.org/api v0.97.0/go.mod h1:w7wJQLTM+wvQpNf5JyEcBoxK0RH7EDrh/L4qfsuJ13s=
google.golang.org/api v0.98.0/go.mod h1:w7wJQLTM+wvQpNf5JyEcBoxK0RH7EDrh/L4qfsuJ13s=
google.golang.org/api v0.99.0/go.mod h1:1YOf74vkVndF7pG6hIHuINsM7eWwpVTAfNMNiL91A08=
google.golang.org/api v0.100.0/go.mod h1:ZE3Z2+ZOr87Rx7dqFsdRQkRBk36kDtp/h+QpHbB7a70=
google.golang.org/api v0.102.0/go.mod h1:3VFl6/fzoA+qNuS1N1/VfXY4LjoXN/wzeIp7TweWwGo=
google.golang.org/api v0.103.0/go.mod h1:hGtW6nK1AC+d9si/UBhw8Xli+QMOf6xyNAyJw4qU9w0=
google.golang.org/api v0.106.0/go.mod h1:2Ts0XTHNVWxypznxWOYUeI4g3WdP9Pk2Qk58+a/O9MY=
google.golang.org/api v0.107.0/go.mod h1:2Ts0XTHNVWxypznxWOYUeI4g3WdP9Pk2Qk58+a/O9MY=
google.golang.org/api v0.108.0/go.mod h1:2Ts0XTHNVWxypznxWOYUeI4g3WdP9Pk2Qk58+a/O9MY=
google.golang.org/api v0.110.0/go.mod h1:7FC4Vvx1Mooxh8C5HWjzZHcavuS2f6pmJpZx60ca7iI=
google.golang.org/api v0.111.0/go.mod h1:qtFHvU9mhgTJegR31csQ+rwxyUTHOKFqCKWp1J0fdw0=
google.golang.org/api v0.114.0/go.mod h1:ifYI2ZsFK6/uGddGfAD5BMxlnkBqCmqHSDUVi45N5Yg=
google.golang.org/api v0.189.0 h1:equMo30LypAkdkLMBqfeIqtyAnlyig1JSZArl4XPwdI=
google.golang.org/api v0.189.0/go.mod h1:FLWGJKb0hb+pU2j+rJqwbnsF+ym+fQs73rbJ+KAUgy8=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=
google.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=
google.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=
google.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=
google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
google.golang.org/genproto v0.0.0-20200618031413-b414f8b61790/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
google.golang.org/genproto v0.0.0-20200729003335-053ba62fc06f/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200804131852-c06518451d9c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200825200019-8632dd797987/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200904004341-0bd0a958aa1d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201109203340-2640f1f9cdfb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201201144952-b05cb90ed32e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201210142538-e3217bee35cc/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201214200347-8c77b98c765d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210108203827-ffc7fda8c3d7/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210222152913-aa3ee6e6a81c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210226172003-ab064af71705/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210303154014-9728d6b83eeb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210310155132-4ce2db91004e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210319143718-93e7006c17a6/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210329143202-679c6ae281ee/go.mod h1:9lPAdzaEmUacj36I+k7YKbEc5CXzPIeORRgDAUOu28A=
google.golang.org/genproto v0.0.0-20210402141018-6c239bbf2bb1/go.mod h1:9lPAdzaEmUacj36I+k7YKbEc5CXzPIeORRgDAUOu28A=
google.golang.org/genproto v0.0.0-20210513213006-bf773b8c8384/go.mod h1:P3QM42oQyzQSnHPnZ/vqoCdDmzH28fzWByN9asMeM8A=
google.golang.org/genproto v0.0.0-20210602131652-f16073e35f0c/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=
google.golang.org/genproto v0.0.0-20210604141403-392c879c8b08/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=
google.golang.org/genproto v0.0.0-20210608205507-b6d2f5bf0d7d/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=
google.golang.org/genproto v0.0.0-20210624195500-8bfb893ecb84/go.mod h1:SzzZ/N+nwJDaO1kznhnlzqS8ocJICar6hYhVyhi++24=
google.golang.org/genproto v0.0.0-20210713002101-d411969a0d9a/go.mod h1:AxrInvYm1dci+enl5hChSFPOmmUF1+uAa/UsgNRWd7k=
google.golang.org/genproto v0.0.0-20210716133855-ce7ef5c701ea/go.mod h1:AxrInvYm1dci+enl5hChSFPOmmUF1+uAa/UsgNRWd7k=
google.golang.org/genproto v0.0.0-20210728212813-7823e685a01f/go.mod h1:ob2IJxKrgPT52GcgX759i1sleT07tiKowYBGbczaW48=
google.golang.org/genproto v0.0.0-20210805201207-89edb61ffb67/go.mod h1:ob2IJxKrgPT52GcgX759i1sleT07tiKowYBGbczaW48=
google.golang.org/genproto v0.0.0-20210813162853-db860fec028c/go.mod h1:cFeNkxwySK631ADgubI+/XFU/xp8FD5KIVV4rj8UC5w=
google.golang.org/genproto v0.0.0-20210821163610-241b8fcbd6c8/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=
google.golang.org/genproto v0.0.0-20210828152312-66f60bf46e71/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=
google.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=
google.golang.org/genproto v0.0.0-20210903162649-d08c68adba83/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=
google.golang.org/genproto v0.0.0-20210909211513-a8c4777a87af/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=
google.golang.org/genproto v0.0.0-20210924002016-3dee208752a0/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
google.golang.org/genproto v0.0.0-20211118181313-81c1377c94b1/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
google.golang.org/genproto v0.0.0-20211206160659-862468c7d6e0/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
google.golang.org/genproto v0.0.0-20211208223120-3a66f561d7aa/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
google.golang.org/genproto v0.0.0-20211221195035-429b39de9b1c/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
google.golang.org/genproto v0.0.0-20220126215142-9970aeb2e350/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
google.golang.org/genproto v0.0.0-20220207164111-0872dc986b00/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
google.golang.org/genproto v0.0.0-20220218161850-94dd64e39d7c/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=
google.golang.org/genproto v0.0.0-20220222213610-43724f9ea8cf/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=
google.golang.org/genproto v0.0.0-20220304144024-325a89244dc8/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=
google.golang.org/genproto v0.0.0-20220310185008-1973136f34c6/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=
google.golang.org/genproto v0.0.0-20220324131243-acbaeb5b85eb/go.mod h1:hAL49I2IFola2sVEjAn7MEwsja0xp51I0tlGAf9hz4E=
google.golang.org/genproto v0.0.0-20220329172620-7be39ac1afc7/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=
google.golang.org/genproto v0.0.0-20220407144326-9054f6ed7bac/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=
google.golang.org/genproto v0.0.0-20220413183235-5e96e2839df9/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=
google.golang.org/genproto v0.0.0-20220414192740-2d67ff6cf2b4/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=
google.golang.org/genproto v0.0.0-20220421151946-72621c1f0bd3/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=
google.golang.org/genproto v0.0.0-20220429170224-98d788798c3e/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=
google.golang.org/genproto v0.0.0-20220502173005-c8bf987b8c21/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=
google.golang.org/genproto v0.0.0-20220505152158-f39f71e6c8f3/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=
google.golang.org/genproto v0.0.0-20220518221133-4f43b3371335/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=
google.golang.org/genproto v0.0.0-20220523171625-347a074981d8/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=
google.golang.org/genproto v0.0.0-20220608133413-ed9918b62aac/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=
google.golang.org/genproto v0.0.0-20220616135557-88e70c0c3a90/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=
google.golang.org/genproto v0.0.0-20220617124728-180714bec0ad/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=
google.golang.org/genproto v0.0.0-20220624142145-8cd45d7dbd1f/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=
google.golang.org/genproto v0.0.0-20220628213854-d9e0b6570c03/go.mod h1:KEWEmljWE5zPzLBa/oHl6DaEt9LmfH6WtH1OHIvleBA=
google.golang.org/genproto v0.0.0-20220722212130-b98a9ff5e252/go.mod h1:GkXuJDJ6aQ7lnJcRF+SJVgFdQhypqgl3LB1C9vabdRE=
google.golang.org/genproto v0.0.0-20220801145646-83ce21fca29f/go.mod h1:iHe1svFLAZg9VWz891+QbRMwUv9O/1Ww+/mngYeThbc=
google.golang.org/genproto v0.0.0-20220815135757-37a418bb8959/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=
google.golang.org/genproto v0.0.0-20220817144833-d7fd3f11b9b1/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=
google.golang.org/genproto v0.0.0-20220822174746-9e6da59bd2fc/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=
google.golang.org/genproto v0.0.0-20220829144015-23454907ede3/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=
google.golang.org/genproto v0.0.0-20220829175752-36a9c930ecbf/go.mod h1:dbqgFATTzChvnt+ujMdZwITVAJHFtfyN1qUhDqEiIlk=
google.golang.org/genproto v0.0.0-20220913154956-18f8339a66a5/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=
google.golang.org/genproto v0.0.0-20220914142337-ca0e39ece12f/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=
google.golang.org/genproto v0.0.0-20220915135415-7fd63a7952de/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=
google.golang.org/genproto v0.0.0-20220916172020-2692e8806bfa/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=
google.golang.org/genproto v0.0.0-20220919141832-68c03719ef51/go.mod h1:0Nb8Qy+Sk5eDzHnzlStwW3itdNaWoZA5XeSG+R3JHSo=
google.golang.org/genproto v0.0.0-20220920201722-2b89144ce006/go.mod h1:ht8XFiar2npT/g4vkk7O0WYS1sHOHbdujxbEp7CJWbw=
google.golang.org/genproto v0.0.0-20220926165614-551eb538f295/go.mod h1:woMGP53BroOrRY3xTxlbr8Y3eB/nzAvvFM83q7kG2OI=
google.golang.org/genproto v0.0.0-20220926220553-6981cbe3cfce/go.mod h1:woMGP53BroOrRY3xTxlbr8Y3eB/nzAvvFM83q7kG2OI=
google.golang.org/genproto v0.0.0-20221010155953-15ba04fc1c0e/go.mod h1:3526vdqwhZAwq4wsRUaVG555sVgsNmIjRtO7t/JH29U=
google.golang.org/genproto v0.0.0-20221014173430-6e2ab493f96b/go.mod h1:1vXfmgAz9N9Jx0QA82PqRVauvCz1SGSz739p0f183jM=
google.golang.org/genproto v0.0.0-20221014213838-99cd37c6964a/go.mod h1:1vXfmgAz9N9Jx0QA82PqRVauvCz1SGSz739p0f183jM=
google.golang.org/genproto v0.0.0-20221024153911-1573dae28c9c/go.mod h1:9qHF0xnpdSfF6knlcsnpzUu5y+rpwgbvsyGAZPBMg4s=
google.golang.org/genproto v0.0.0-20221024183307-1bc688fe9f3e/go.mod h1:9qHF0xnpdSfF6knlcsnpzUu5y+rpwgbvsyGAZPBMg4s=
google.golang.org/genproto v0.0.0-20221027153422-115e99e71e1c/go.mod h1:CGI5F/G+E5bKwmfYo09AXuVN4dD894kIKUFmVbP2/Fo=
google.golang.org/genproto v0.0.0-20221109142239-94d6d90a7d66/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=
google.golang.org/genproto v0.0.0-20221114212237-e4508ebdbee1/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=
google.golang.org/genproto v0.0.0-20221117204609-8f9c96812029/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=
google.golang.org/genproto v0.0.0-20221118155620-16455021b5e6/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=
google.golang.org/genproto v0.0.0-20221201164419-0e50fba7f41c/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=
google.golang.org/genproto v0.0.0-20221201204527-e3fa12d562f3/go.mod h1:rZS5c/ZVYMaOGBfO68GWtjOw/eLaZM1X6iVtgjZ+EWg=
google.golang.org/genproto v0.0.0-20221202195650-67e5cbc046fd/go.mod h1:cTsE614GARnxrLsqKREzmNYJACSWWpAWdNMwnD7c2BE=
google.golang.org/genproto v0.0.0-20221227171554-f9683d7f8bef/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230110181048-76db0878b65f/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230112194545-e10362b5ecf9/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230113154510-dbe35b8444a5/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230123190316-2c411cf9d197/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230124163310-31e0e69b6fc2/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230125152338-dcaf20b6aeaa/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230127162408-596548ed4efa/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230209215440-0dfe4f8abfcc/go.mod h1:RGgjbofJ8xD9Sq1VVhDM1Vok1vRONV+rg+CjzG4SZKM=
google.golang.org/genproto v0.0.0-20230216225411-c8e22ba71e44/go.mod h1:8B0gmkoRebU8ukX6HP+4wrVQUY1+6PkQ44BSyIlflHA=
google.golang.org/genproto v0.0.0-20230222225845-10f96fb3dbec/go.mod h1:3Dl5ZL0q0isWJt+FVcfpQyirqemEuLAK/iFvg1UP1Hw=
google.golang.org/genproto v0.0.0-20230223222841-637eb2293923/go.mod h1:3Dl5ZL0q0isWJt+FVcfpQyirqemEuLAK/iFvg1UP1Hw=
google.golang.org/genproto v0.0.0-20230303212802-e74f57abe488/go.mod h1:TvhZT5f700eVlTNwND1xoEZQeWTB2RY/65kplwl/bFA=
google.golang.org/genproto v0.0.0-20230306155012-7f2fa6fef1f4/go.mod h1:NWraEVixdDnqcqQ30jipen1STv2r/n24Wb7twVTGR4s=
google.golang.org/genproto v0.0.0-20230320184635-7606e756e683/go.mod h1:NWraEVixdDnqcqQ30jipen1STv2r/n24Wb7twVTGR4s=
google.golang.org/genproto v0.0.0-20230323212658-478b75c54725/go.mod h1:UUQDJDOlWu4KYeJZffbWgBkS1YFobzKbLVfK69pe0Ak=
google.golang.org/genproto v0.0.0-20230330154414-c0448cd141ea/go.mod h1:UUQDJDOlWu4KYeJZffbWgBkS1YFobzKbLVfK69pe0Ak=
google.golang.org/genproto v0.0.0-20230331144136-dcfb400f0633/go.mod h1:UUQDJDOlWu4KYeJZffbWgBkS1YFobzKbLVfK69pe0Ak=
google.golang.org/genproto v0.0.0-20230410155749-daa745c078e1/go.mod h1:nKE/iIaLqn2bQwXBg8f1g2Ylh6r5MN5CmZvuzZCgsCU=
google.golang.org/genproto v0.0.0-20240722135656-d784300faade h1:lKFsS7wpngDgSCeFn7MoLy+wBDQZ1UQIJD4UNM1Qvkg=
google.golang.org/genproto v0.0.0-20240722135656-d784300faade/go.mod h1:FfBgJBJg9GcpPvKIuHSZ/aE1g2ecGL74upMzGZjiGEY=
google.golang.org/genproto/googleapis/api v0.0.0-20240701130421-f6361c86f094 h1:0+ozOGcrp+Y8Aq8TLNN2Aliibms5LEzsq99ZZmAGYm0=
google.golang.org/genproto/googleapis/api v0.0.0-20240701130421-f6361c86f094/go.mod h1:fJ/e3If/Q67Mj99hin0hMhiNyCRmt6BQ2aWIJshUSJw=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240722135656-d784300faade h1:oCRSWfwGXQsqlVdErcyTt4A93Y8fo0/9D4b1gnI++qo=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240722135656-d784300faade/go.mod h1:Ue6ibwXGpU+dqIcODieyLOcgj7z8+IcskoNIgZxtrFY=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
google.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=
google.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=
google.golang.org/grpc v1.30.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.31.1/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTpR3n0=
google.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=
google.golang.org/grpc v1.34.0/go.mod h1:WotjhfgOW/POjDeRt8vscBtXq+2VjORFy659qA51WJ8=
google.golang.org/grpc v1.35.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/grpc v1.36.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/grpc v1.36.1/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/grpc v1.37.0/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=
google.golang.org/grpc v1.37.1/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=
google.golang.org/grpc v1.38.0/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=
google.golang.org/grpc v1.39.0/go.mod h1:PImNr+rS9TWYb2O4/emRugxiyHZ5JyHW5F+RPnDzfrE=
google.golang.org/grpc v1.39.1/go.mod h1:PImNr+rS9TWYb2O4/emRugxiyHZ5JyHW5F+RPnDzfrE=
google.golang.org/grpc v1.40.0/go.mod h1:ogyxbiOoUXAkP+4+xa6PZSE9DZgIHtSpzjDTB9KAK34=
google.golang.org/grpc v1.40.1/go.mod h1:ogyxbiOoUXAkP+4+xa6PZSE9DZgIHtSpzjDTB9KAK34=
google.golang.org/grpc v1.42.0/go.mod h1:k+4IHHFw41K8+bbowsex27ge2rCb65oeWqe4jJ590SU=
google.golang.org/grpc v1.44.0/go.mod h1:k+4IHHFw41K8+bbowsex27ge2rCb65oeWqe4jJ590SU=
google.golang.org/grpc v1.45.0/go.mod h1:lN7owxKUQEqMfSyQikvvk5tf/6zMPsrK+ONuO11+0rQ=
google.golang.org/grpc v1.46.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.46.2/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.47.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.48.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.49.0/go.mod h1:ZgQEeidpAuNRZ8iRrlBKXZQP1ghovWIVhdJRyCDK+GI=
google.golang.org/grpc v1.50.0/go.mod h1:ZgQEeidpAuNRZ8iRrlBKXZQP1ghovWIVhdJRyCDK+GI=
google.golang.org/grpc v1.50.1/go.mod h1:ZgQEeidpAuNRZ8iRrlBKXZQP1ghovWIVhdJRyCDK+GI=
google.golang.org/grpc v1.51.0/go.mod h1:wgNDFcnuBGmxLKI/qn4T+m5BtEBYXJPvibbUPsAIPww=
google.golang.org/grpc v1.52.3/go.mod h1:pu6fVzoFb+NBYNAvQL08ic+lvB2IojljRYuun5vorUY=
google.golang.org/grpc v1.53.0/go.mod h1:OnIrk0ipVdj4N5d9IUoFUx72/VlD7+jUsHwZgwSMQpw=
google.golang.org/grpc v1.54.0/go.mod h1:PUSEXI6iWghWaB6lXM4knEgpJNu2qUcKfDtNci3EC2g=
google.golang.org/grpc v1.56.3/go.mod h1:I9bI3vqKfayGqPUAwGdOSu7kt6oIJLixfffKrpXqQ9s=
google.golang.org/grpc v1.64.1 h1:LKtvyfbX3UGVPFcGqJ9ItpVWW6oN/2XqTxfAnwRRXiA=
google.golang.org/grpc v1.64.1/go.mod h1:hiQF4LFZelK2WKaP6W0L92zGHtiQdZxk8CrSdvyjeP0=
google.golang.org/grpc/cmd/protoc-gen-go-grpc v1.1.0/go.mod h1:6Kw0yEErY5E/yWrBtf03jp27GLLJujG4z/JK95pnjjw=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=
google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.28.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
google.golang.org/protobuf v1.28.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
google.golang.org/protobuf v1.29.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
google.golang.org/protobuf v1.30.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
google.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=
google.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gotest.tools/gotestsum v1.8.2 h1:szU3TaSz8wMx/uG+w/A2+4JUPwH903YYaMI9yOOYAyI=
gotest.tools/gotestsum v1.8.2/go.mod h1:6JHCiN6TEjA7Kaz23q1bH0e2Dc3YJjDUZ0DmctFZf+w=
gotest.tools/v3 v3.3.0/go.mod h1:Mcr9QNxkg0uMvy/YElmo4SpXgJKWgQvYrT7Kw5RzJ1A=
gotest.tools/v3 v3.5.1 h1:EENdUnS3pdur5nybKYIh2Vfgc8IUNBjxDPSjtiJcOzU=
gotest.tools/v3 v3.5.1/go.mod h1:isy3WKz7GK6uNw/sbHzfKBLvlvXwUyV06n6brMxxopU=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
honnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
honnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
honnef.co/go/tools v0.1.3/go.mod h1:NgwopIslSNH47DimFoV78dnkksY2EFtX0ajyb3K/las=
lukechampine.com/uint128 v1.1.1/go.mod h1:c4eWIwlEGaxC/+H1VguhU4PHXNWDCDMUlWdIWl2j1gk=
lukechampine.com/uint128 v1.2.0/go.mod h1:c4eWIwlEGaxC/+H1VguhU4PHXNWDCDMUlWdIWl2j1gk=
lukechampine.com/uint128 v1.3.0 h1:cDdUVfRwDUDovz610ABgFD17nXD4/uDgVHl2sC3+sbo=
lukechampine.com/uint128 v1.3.0/go.mod h1:c4eWIwlEGaxC/+H1VguhU4PHXNWDCDMUlWdIWl2j1gk=
modernc.org/cc/v3 v3.36.0/go.mod h1:NFUHyPn4ekoC/JHeZFfZurN6ixxawE1BnVonP/oahEI=
modernc.org/cc/v3 v3.36.2/go.mod h1:NFUHyPn4ekoC/JHeZFfZurN6ixxawE1BnVonP/oahEI=
modernc.org/cc/v3 v3.36.3/go.mod h1:NFUHyPn4ekoC/JHeZFfZurN6ixxawE1BnVonP/oahEI=
modernc.org/cc/v3 v3.40.0 h1:P3g79IUS/93SYhtoeaHW+kRCIrYaxJ27MFPv+7kaTOw=
modernc.org/cc/v3 v3.40.0/go.mod h1:/bTg4dnWkSXowUO6ssQKnOV0yMVxDYNIsIrzqTFDGH0=
modernc.org/ccgo/v3 v3.0.0-20220428102840-41399a37e894/go.mod h1:eI31LL8EwEBKPpNpA4bU1/i+sKOwOrQy8D87zWUcRZc=
modernc.org/ccgo/v3 v3.0.0-20220430103911-bc99d88307be/go.mod h1:bwdAnOoaIt8Ax9YdWGjxWsdkPcZyRPHqrOvJxaKAKGw=
modernc.org/ccgo/v3 v3.16.4/go.mod h1:tGtX0gE9Jn7hdZFeU88slbTh1UtCYKusWOoCJuvkWsQ=
modernc.org/ccgo/v3 v3.16.6/go.mod h1:tGtX0gE9Jn7hdZFeU88slbTh1UtCYKusWOoCJuvkWsQ=
modernc.org/ccgo/v3 v3.16.8/go.mod h1:zNjwkizS+fIFDrDjIAgBSCLkWbJuHF+ar3QRn+Z9aws=
modernc.org/ccgo/v3 v3.16.9/go.mod h1:zNMzC9A9xeNUepy6KuZBbugn3c0Mc9TeiJO4lgvkJDo=
modernc.org/ccgo/v3 v3.16.13 h1:Mkgdzl46i5F/CNR/Kj80Ri59hC8TKAhZrYSaqvkwzUw=
modernc.org/ccgo/v3 v3.16.13/go.mod h1:2Quk+5YgpImhPjv2Qsob1DnZ/4som1lJTodubIcoUkY=
modernc.org/ccorpus v1.11.6 h1:J16RXiiqiCgua6+ZvQot4yUuUy8zxgqbqEEUuGPlISk=
modernc.org/ccorpus v1.11.6/go.mod h1:2gEUTrWqdpH2pXsmTM1ZkjeSrUWDpjMu2T6m29L/ErQ=
modernc.org/httpfs v1.0.6 h1:AAgIpFZRXuYnkjftxTAZwMIiwEqAfk8aVB2/oA6nAeM=
modernc.org/httpfs v1.0.6/go.mod h1:7dosgurJGp0sPaRanU53W4xZYKh14wfzX420oZADeHM=
modernc.org/libc v0.0.0-20220428101251-2d5f3daf273b/go.mod h1:p7Mg4+koNjc8jkqwcoFBJx7tXkpj00G77X7A72jXPXA=
modernc.org/libc v1.16.0/go.mod h1:N4LD6DBE9cf+Dzf9buBlzVJndKr/iJHG97vGLHYnb5A=
modernc.org/libc v1.16.1/go.mod h1:JjJE0eu4yeK7tab2n4S1w8tlWd9MxXLRzheaRnAKymU=
modernc.org/libc v1.16.17/go.mod h1:hYIV5VZczAmGZAnG15Vdngn5HSF5cSkbvfz2B7GRuVU=
modernc.org/libc v1.16.19/go.mod h1:p7Mg4+koNjc8jkqwcoFBJx7tXkpj00G77X7A72jXPXA=
modernc.org/libc v1.17.0/go.mod h1:XsgLldpP4aWlPlsjqKRdHPqCxCjISdHfM/yeWC5GyW0=
modernc.org/libc v1.17.1/go.mod h1:FZ23b+8LjxZs7XtFMbSzL/EhPxNbfZbErxEHc7cbD9s=
modernc.org/libc v1.22.4 h1:wymSbZb0AlrjdAVX3cjreCHTPCpPARbQXNz6BHPzdwQ=
modernc.org/libc v1.22.4/go.mod h1:jj+Z7dTNX8fBScMVNRAYZ/jF91K8fdT2hYMThc3YjBY=
modernc.org/mathutil v1.2.2/go.mod h1:mZW8CKdRPY1v87qxC/wUdX5O1qDzXMP5TH3wjfpga6E=
modernc.org/mathutil v1.4.1/go.mod h1:mZW8CKdRPY1v87qxC/wUdX5O1qDzXMP5TH3wjfpga6E=
modernc.org/mathutil v1.5.0 h1:rV0Ko/6SfM+8G+yKiyI830l3Wuz1zRutdslNoQ0kfiQ=
modernc.org/mathutil v1.5.0/go.mod h1:mZW8CKdRPY1v87qxC/wUdX5O1qDzXMP5TH3wjfpga6E=
modernc.org/memory v1.1.1/go.mod h1:/0wo5ibyrQiaoUoH7f9D8dnglAmILJ5/cxZlRECf+Nw=
modernc.org/memory v1.2.0/go.mod h1:/0wo5ibyrQiaoUoH7f9D8dnglAmILJ5/cxZlRECf+Nw=
modernc.org/memory v1.2.1/go.mod h1:PkUhL0Mugw21sHPeskwZW4D6VscE/GQJOnIpCnW6pSU=
modernc.org/memory v1.5.0 h1:N+/8c5rE6EqugZwHii4IFsaJ7MUhoWX07J5tC/iI5Ds=
modernc.org/memory v1.5.0/go.mod h1:PkUhL0Mugw21sHPeskwZW4D6VscE/GQJOnIpCnW6pSU=
modernc.org/opt v0.1.1/go.mod h1:WdSiB5evDcignE70guQKxYUl14mgWtbClRi5wmkkTX0=
modernc.org/opt v0.1.3 h1:3XOZf2yznlhC+ibLltsDGzABUGVx8J6pnFMS3E4dcq4=
modernc.org/opt v0.1.3/go.mod h1:WdSiB5evDcignE70guQKxYUl14mgWtbClRi5wmkkTX0=
modernc.org/sqlite v1.18.1/go.mod h1:6ho+Gow7oX5V+OiOQ6Tr4xeqbx13UZ6t+Fw9IRUG4d4=
modernc.org/sqlite v1.21.2 h1:ixuUG0QS413Vfzyx6FWx6PYTmHaOegTY+hjzhn7L+a0=
modernc.org/sqlite v1.21.2/go.mod h1:cxbLkB5WS32DnQqeH4h4o1B0eMr8W/y8/RGuxQ3JsC0=
modernc.org/strutil v1.1.1/go.mod h1:DE+MQQ/hjKBZS2zNInV5hhcipt5rLPWkmpbGeW5mmdw=
modernc.org/strutil v1.1.3 h1:fNMm+oJklMGYfU9Ylcywl0CO5O6nTfaowNsh2wpPjzY=
modernc.org/strutil v1.1.3/go.mod h1:MEHNA7PdEnEwLvspRMtWTNnp2nnyvMfkimT1NKNAGbw=
modernc.org/tcl v1.13.1/go.mod h1:XOLfOwzhkljL4itZkK6T72ckMgvj0BDsnKNdZVUOecw=
modernc.org/tcl v1.15.1 h1:mOQwiEK4p7HruMZcwKTZPw/aqtGM4aY00uzWhlKKYws=
modernc.org/tcl v1.15.1/go.mod h1:aEjeGJX2gz1oWKOLDVZ2tnEWLUrIn8H+GFu+akoDhqs=
modernc.org/token v1.0.0/go.mod h1:UGzOrNV1mAFSEB63lOFHIpNRUVMvYTc6yu1SMY/XTDM=
modernc.org/token v1.1.0 h1:Xl7Ap9dKaEs5kLoOQeQmPWevfnk/DM5qcLcYlA8ys6Y=
modernc.org/token v1.1.0/go.mod h1:UGzOrNV1mAFSEB63lOFHIpNRUVMvYTc6yu1SMY/XTDM=
modernc.org/z v1.5.1/go.mod h1:eWFB510QWW5Th9YGZT81s+LwvaAs3Q2yr4sP0rmLkv8=
modernc.org/z v1.7.0 h1:xkDw/KepgEjeizO2sNco+hqYkU12taxQFqPEmgm1GWE=
modernc.org/z v1.7.0/go.mod h1:hVdgNMh8ggTuRG1rGU8x+xGRFfiQUIAw0ZqlPy8+HyQ=
rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=
rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=
rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=



================================================
FILE: dbee/main.go
================================================
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"runtime/debug"

	"github.com/neovim/go-client/nvim"

	"github.com/kndndrj/nvim-dbee/dbee/handler"
	"github.com/kndndrj/nvim-dbee/dbee/plugin"
)

func main() {
	generateManifest := flag.String("manifest", "", "Generate manifest to file (filename of manifest).")
	getVersion := flag.Bool("version", false, "Get version and exit.")
	flag.Parse()

	// get version info
	if *getVersion {
		info, ok := debug.ReadBuildInfo()
		if !ok {
			fmt.Println("unknown")
			os.Exit(1)
		}
		for _, inf := range info.Settings {
			if inf.Key == "vcs.revision" {
				fmt.Println(inf.Value)
				return
			}
		}
		fmt.Println("unknown")
		os.Exit(1)
	}

	stdout := os.Stdout
	os.Stdout = os.Stderr
	log.SetFlags(0)

	v, err := nvim.New(os.Stdin, stdout, stdout, log.Printf)
	if err != nil {
		log.Fatal(err)
	}

	logger := plugin.NewLogger(v)

	p := plugin.New(v, logger)

	h := handler.New(v, logger)
	defer h.Close()

	// configure "endpoints" from handler
	mountEndpoints(p, h)

	// generate manifest
	if *generateManifest != "" {
		err := p.Manifest("nvim_dbee", "dbee", *generateManifest)
		if err != nil {
			log.Fatal(err)
		}
		log.Println("generated manifest to " + *generateManifest)
		return
	}

	// start server
	if err := v.Serve(); err != nil {
		log.Fatal(err)
	}
}



================================================
FILE: dbee/adapters/adapters.go
================================================
package adapters

import (
	"bytes"
	"errors"
	"fmt"
	"text/template"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

var (
	errNoValidTypeAliases   = errors.New("no valid type aliases provided")
	ErrUnsupportedTypeAlias = errors.New("no driver registered for provided type alias")
)

var _ core.Adapter = (*wrappedAdapter)(nil)

// wrappedAdapter is returned from Mux and adds extra helpers to internal adapter.
type wrappedAdapter struct {
	adapter      core.Adapter
	extraHelpers map[string]*template.Template
}

// registeredAdapters holds implemented adapters - specific adapters register themselves in their init functions.
// The main reason is to be able to compile the binary without unsupported os/arch of specific drivers.
var registeredAdapters = make(map[string]*wrappedAdapter)

// register registers a new adapter for specific database
func register(adapter core.Adapter, aliases ...string) error {
	if len(aliases) < 1 {
		return errNoValidTypeAliases
	}

	value := &wrappedAdapter{
		adapter: adapter,
	}

	invalidCount := 0
	for _, alias := range aliases {
		if alias == "" {
			invalidCount++
			continue
		}
		registeredAdapters[alias] = value
	}

	if invalidCount == len(aliases) {
		return errNoValidTypeAliases
	}

	return nil
}

// Mux is an interface to all internal adapters.
type Mux struct{}

func (*Mux) GetAdapter(typ string) (core.Adapter, error) {
	value, ok := registeredAdapters[typ]
	if !ok {
		return nil, ErrUnsupportedTypeAlias
	}

	return value, nil
}

func (*Mux) AddAdapter(typ string, adapter core.Adapter) error {
	return register(adapter, typ)
}

func (*Mux) AddHelpers(typ string, helpers map[string]string) error {
	value, ok := registeredAdapters[typ]
	if !ok {
		return ErrUnsupportedTypeAlias
	}

	if value.extraHelpers == nil {
		value.extraHelpers = make(map[string]*template.Template)
	}

	// new helpers have priority
	for k, v := range helpers {
		tmpl, err := template.New("helpers").Parse(v)
		if err != nil {
			return fmt.Errorf("template.New.Parse: %w", err)
		}

		value.extraHelpers[k] = tmpl
	}

	return nil
}

func (wa *wrappedAdapter) Connect(url string) (core.Driver, error) {
	return wa.adapter.Connect(url)
}

func (wa *wrappedAdapter) GetHelpers(opts *core.TableOptions) map[string]string {
	helpers := wa.adapter.GetHelpers(opts)
	if helpers == nil {
		helpers = make(map[string]string)
	}

	// extra helpers have priority
	for k, tmpl := range wa.extraHelpers {
		var out bytes.Buffer
		err := tmpl.Execute(&out, opts)
		if err != nil {
			continue
		}

		helpers[k] = out.String()
	}

	return helpers
}

// NewConnection is a wrapper around core.NewConnection that uses the internal mux for
// adapter registration.
func NewConnection(params *core.ConnectionParams) (*core.Connection, error) {
	adapter, err := new(Mux).GetAdapter(params.Expand().Type)
	if err != nil {
		return nil, fmt.Errorf("Mux.GetAdapters: %w", err)
	}

	c, err := core.NewConnection(params, adapter)
	if err != nil {
		return nil, fmt.Errorf("core.NewConnection: %w", err)
	}

	return c, nil
}



================================================
FILE: dbee/adapters/bigquery.go
================================================
package adapters

import (
	"context"
	"fmt"
	"net/url"

	"cloud.google.com/go/bigquery"
	"google.golang.org/api/option"
	"google.golang.org/api/option/internaloption"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

// Register client
func init() {
	_ = register(&BigQuery{}, "bigquery")
}

var _ core.Adapter = (*BigQuery)(nil)

type BigQuery struct{}

// Connect creates a [BigQuery] client connected to the project specified
// in the url. The format of the url is as follows:
//
//	bigquery://[project][?options]
//
// where project is optional. If not set, the project will attempt to be
// detected from the credentials and current gcloud settings.
//
// The options query parameters map directly to [bigquery.QueryConfig] fields
// using kebab-case. For example, MaxBytesBilled becomes max-bytes-billed.
//
// Common options include:
//   - credentials=path/to/creds.json: Path to credentials file
//   - max-bytes-billed=integer: Maximum bytes to be billed
//   - disable-query-cache=bool: Whether to disable query cache
//   - use-legacy-sql=bool: Whether to use legacy SQL
//   - location=string: Query location
//   - enable-storage-read=bool: Enable BigQuery Storage API
//
// For internal testing:
//   - endpoint=url: Custom endpoint for test containers
//
// If credentials are not specified, they will be located according to
// the Google Default Credentials process.
func (bq *BigQuery) Connect(rawURL string) (core.Driver, error) {
	ctx := context.Background()

	u, err := url.Parse(rawURL)
	if err != nil {
		return nil, err
	}

	if u.Scheme != "bigquery" {
		return nil, fmt.Errorf("unexpected scheme: %q", u.Scheme)
	}

	if u.Host == "" {
		u.Host = bigquery.DetectProjectID
	}

	options := []option.ClientOption{option.WithTelemetryDisabled()}
	params := u.Query()

	// special param to indicate we are running in testcontainer.
	if endpoint := params.Get("endpoint"); endpoint != "" {
		options = append(options,
			option.WithEndpoint(endpoint),
			option.WithGRPCDialOption(grpc.WithTransportCredentials(insecure.NewCredentials())),
			option.WithoutAuthentication(),
			internaloption.SkipDialSettingsValidation(),
		)
	} else {
		callIfStringSet("credentials", params, func(file string) error {
			options = append(options, option.WithCredentialsFile(file))
			return nil
		})
	}

	bqc, err := bigquery.NewClient(ctx, u.Host, options...)
	if err != nil {
		return nil, err
	}

	client := &bigQueryDriver{c: bqc}
	if err = setQueryConfigFromParams(&client.QueryConfig, params); err != nil {
		return nil, err
	}

	if err = callIfBoolSet("enable-storage-read", params, func() error {
		return client.c.EnableStorageReadClient(ctx, options...)
	}, nil); err != nil {
		return nil, err
	}

	return client, nil
}

func (*BigQuery) GetHelpers(opts *core.TableOptions) map[string]string {
	return map[string]string{
		"List":    fmt.Sprintf("SELECT * FROM `%s` TABLESAMPLE SYSTEM (5 PERCENT)", opts.Table),
		"Columns": fmt.Sprintf("SELECT * FROM `%s.INFORMATION_SCHEMA.COLUMNS` WHERE TABLE_SCHEMA = '%s' AND TABLE_NAME = '%s'", opts.Schema, opts.Schema, opts.Table),
	}
}



================================================
FILE: dbee/adapters/bigquery_driver.go
================================================
package adapters

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"reflect"
	"strconv"
	"strings"
	"unicode"

	"cloud.google.com/go/bigquery"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
	"google.golang.org/api/iterator"
)

var _ core.Driver = (*bigQueryDriver)(nil)

type bigQueryDriver struct {
	c *bigquery.Client
	bigquery.QueryConfig
}

func (d *bigQueryDriver) Query(ctx context.Context, queryStr string) (core.ResultStream, error) {
	query := d.c.Query(queryStr)
	d.Q = query.Q
	query.QueryConfig = d.QueryConfig

	iter, err := query.Read(ctx)
	if err != nil {
		return nil, err
	}

	var currentRow bigqueryRowLoader
	hasNext := true

	// schema and header only detectable after retrieving the first reslt
	if err := iter.Next(&currentRow); err != nil {
		if errors.Is(err, iterator.Done) {
			hasNext = false
		} else {
			return nil, err
		}
	}

	header := d.buildHeader("", iter.Schema)

	nextFn := func() (core.Row, error) {
		if !hasNext {
			return nil, nil
		}

		row := currentRow.row
		var nextLoader bigqueryRowLoader
		if err := iter.Next(&nextLoader); err != nil {
			if errors.Is(err, iterator.Done) {
				hasNext = false
				return row, nil
			}
			return nil, err
		}
		currentRow = nextLoader
		return row, nil
	}
	hasNextFn := func() bool { return hasNext }

	result := builders.NewResultStreamBuilder().
		WithNextFunc(nextFn, hasNextFn).
		WithHeader(header).
		Build()
	return result, nil
}

func (d *bigQueryDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	query := fmt.Sprintf(
		"SELECT COLUMN_NAME, DATA_TYPE FROM `%s.INFORMATION_SCHEMA.COLUMNS` WHERE TABLE_SCHEMA = '%s' AND TABLE_NAME = '%s'",
		opts.Schema, opts.Schema, opts.Table)

	result, err := d.Query(context.Background(), query)
	if err != nil {
		return nil, err
	}

	return builders.ColumnsFromResultStream(result)
}

func (d *bigQueryDriver) Structure() (layouts []*core.Structure, err error) {
	ctx := context.Background()

	datasetsIter := d.c.Datasets(ctx)
	for {
		dataset, err := datasetsIter.Next()
		if err != nil {
			if !errors.Is(err, iterator.Done) {
				return nil, err
			}

			break
		}

		datasetLayout := &core.Structure{
			Name:     dataset.DatasetID,
			Schema:   dataset.DatasetID,
			Type:     core.StructureTypeNone,
			Children: []*core.Structure{},
		}

		tablesIter := dataset.Tables(ctx)
		for {
			table, err := tablesIter.Next()
			if err != nil {
				if !errors.Is(err, iterator.Done) {
					return nil, err
				}

				break
			}

			datasetLayout.Children = append(datasetLayout.Children, &core.Structure{
				Name:     table.TableID,
				Schema:   table.DatasetID,
				Type:     core.StructureTypeTable,
				Children: nil,
			})
		}

		layouts = append(layouts, datasetLayout)
	}

	return layouts, nil
}

func (d *bigQueryDriver) Close() { _ = d.c.Close() }

func (d *bigQueryDriver) buildHeader(parentName string, schema bigquery.Schema) (columns core.Header) {
	for _, field := range schema {
		if field.Type == bigquery.RecordFieldType {
			nestedName := field.Name
			if parentName != "" {
				nestedName = parentName + "." + nestedName
			}
			columns = append(columns, d.buildHeader(nestedName, field.Schema)...)
		} else {
			columns = append(columns, field.Name)
		}
	}

	return columns
}

type bigqueryRowLoader struct{ row core.Row }

func (l *bigqueryRowLoader) Load(row []bigquery.Value, schema bigquery.Schema) error {
	l.row = make(core.Row, len(row))

	for i, col := range row {
		l.row[i] = col
	}

	return nil
}

func callIfBoolSet(name string, params url.Values, onTrue, onFalse func() error) error {
	if onTrue == nil {
		onTrue = func() error { return nil }
	}
	if onFalse == nil {
		onFalse = func() error { return nil }
	}

	return callIfSet(name, params, strconv.ParseBool, func(b bool) error {
		if b {
			return onTrue()
		}
		return onFalse()
	})
}

func callIfStringSet(name string, params url.Values, onSet func(string) error) error {
	return callIfSet(name, params, func(s string) (string, error) { return s, nil }, onSet)
}

func callIfSet[T any](name string, params url.Values, parse func(string) (T, error), cb func(T) error) error {
	setting := params.Get(name)
	if setting == "" {
		return nil
	}

	val, err := parse(setting)
	if err != nil {
		return fmt.Errorf("invalid value for %q: %w", name, err)
	}

	return cb(val)
}

func setQueryConfigFromParams(config *bigquery.QueryConfig, params url.Values) error {
	v := reflect.ValueOf(config).Elem()
	t := v.Type()

	// NumField panics if it isn't a struct
	if t.Kind() != reflect.Struct {
		return fmt.Errorf("expected struct, got %v", t.Kind())
	}

	for i := 0; i < t.NumField(); i++ {
		field, fieldValue := t.Field(i), v.Field(i)

		paramName := toKebabCase(field.Name)
		if val := params.Get(paramName); val != "" {
			return setFieldFromString(fieldValue, val)
		}
	}
	return nil
}

// toKebabCase converts a string to kebab-case
func toKebabCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if (unicode.IsUpper(r)) && (i != 0 &&
			!unicode.IsUpper(rune(s[i-1]))) && i+1 != len(s) {
			result.WriteByte('-')
		}
		result.WriteString(strings.ToLower(string(r)))
	}
	return result.String()
}

// setFieldFromString sets a field value from its string representation
func setFieldFromString(fieldValue reflect.Value, val string) error {
	if !fieldValue.CanSet() {
		return fmt.Errorf("field is not settable")
	}

	if val == "" {
		return nil
	}

	switch fieldValue.Kind() {
	case reflect.Bool:
		b, err := strconv.ParseBool(val)
		if err != nil {
			return fmt.Errorf("failed to parse bool: %w", err)
		}
		fieldValue.SetBool(b)
	case reflect.Int64, reflect.Int32, reflect.Int16, reflect.Int8, reflect.Int:
		i, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return fmt.Errorf("failed to parse int: %w", err)
		}
		fieldValue.SetInt(i)
	case reflect.String:
		fieldValue.SetString(val)
	case reflect.Ptr:
		if fieldValue.IsNil() {
			fieldValue.Set(reflect.New(fieldValue.Type().Elem()))
		}
		return setFieldFromString(fieldValue.Elem(), val)

	default:
		return fmt.Errorf("unsupported field type %s", fieldValue.Kind())
	}
	return nil
}



================================================
FILE: dbee/adapters/bigquery_driver_test.go
================================================
package adapters

import (
	"net/url"
	"reflect"
	"testing"

	"cloud.google.com/go/bigquery"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/stretchr/testify/assert"
)

func Test_toKebabCase(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "should convert to kebab case single",
			input: "helloWorld",
			want:  "hello-world",
		},
		{
			name:  "should convert to kebab case multiple",
			input: "fooBasYes",
			want:  "foo-bas-yes",
		},
		{
			name:  "should convert to kebab case with many upper case",
			input: "helloSQL",
			want:  "hello-sql",
		},
		{
			name:  "should not convert kebab case with upper case beginning",
			input: "Hello",
			want:  "hello",
		},
		{
			name:  "should not convert kebab case with upper case at the end",
			input: "hellO",
			want:  "hello",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := toKebabCase(tt.input)
			assert.Equal(t, tt.want, got)
		})
	}
}

func Test_bigQueryDriver_buildHeader(t *testing.T) {
	type args struct {
		parentName string
		schema     bigquery.Schema
	}
	tests := []struct {
		name string
		args args
		want core.Header
	}{
		{
			name: "should build header with no nested fields",
			args: args{parentName: "", schema: bigquery.Schema{
				{
					Name: "foo1",
					Type: bigquery.StringFieldType,
				},
				{
					Name: "foo2",
					Type: bigquery.StringFieldType,
				},
			}},
			want: []string{"foo1", "foo2"},
		},
		{
			name: "should build header with nested fields but no parent",
			args: args{schema: bigquery.Schema{
				{
					Name: "foo",
					Type: bigquery.RecordFieldType,
					Schema: bigquery.Schema{
						{
							Name: "nested_foo",
							Type: bigquery.StringFieldType,
						},
					},
				},
			}},
			want: []string{"nested_foo"},
		},
		{
			name: "should build header with nested fields and parent",
			args: args{parentName: "parent_foo", schema: bigquery.Schema{
				{
					Name: "foo",
					Type: bigquery.RecordFieldType,
					Schema: bigquery.Schema{
						{
							Name: "nested_foo",
							Type: bigquery.StringFieldType,
						},
					},
				},
			}},
			want: []string{"nested_foo"},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &bigQueryDriver{
				c:           &bigquery.Client{},
				QueryConfig: bigquery.QueryConfig{},
			}
			got := d.buildHeader(tt.args.parentName, tt.args.schema)
			assert.Equal(t, tt.want, got)
		})
	}
}

func Test_setQueryConfigFromParams(t *testing.T) {
	type args struct {
		cfg    *bigquery.QueryConfig
		params url.Values
	}
	tests := []struct {
		name    string
		args    args
		want    *bigquery.QueryConfig
		wantErr bool
	}{
		{
			name: "should set field when it exists and correct data type",
			args: args{
				cfg: &bigquery.QueryConfig{},
				params: url.Values{
					"max-bytes-billed": []string{"10"},
				},
			},
			want: &bigquery.QueryConfig{MaxBytesBilled: 10},
		},
		{
			name: "should not set when field does not exist",
			args: args{
				cfg:    &bigquery.QueryConfig{},
				params: url.Values{"does not exist": []string{}},
			},
			want: &bigquery.QueryConfig{},
		},
		{
			name: "should not set when data type isn't supported",
			args: args{
				cfg:    &bigquery.QueryConfig{},
				params: url.Values{"table-definitions": []string{}},
			},
			want: &bigquery.QueryConfig{},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := setQueryConfigFromParams(tt.args.cfg, tt.args.params)
			if tt.wantErr {
				assert.Error(t, err)
				return
			}
			assert.NoError(t, err)
			assert.Equal(t, tt.want, tt.args.cfg)
		})
	}
}

func Test_setFieldFromString(t *testing.T) {
	type args struct {
		fieldName  string
		fieldValue string
	}
	tests := []struct {
		name    string
		args    args
		want    *bigquery.QueryConfig
		wantErr bool
		errMsg  string
	}{
		{
			name: "should set string field",
			args: args{
				fieldName:  "DefaultProjectID",
				fieldValue: "foo",
			},
			want: &bigquery.QueryConfig{DefaultProjectID: "foo"},
		},
		{
			name: "should set bool field",
			args: args{
				fieldName:  "DisableQueryCache",
				fieldValue: "false",
			},
			want: &bigquery.QueryConfig{DisableQueryCache: false},
		},
		{
			name: "should set int64 field",
			args: args{
				fieldName:  "MaxBytesBilled",
				fieldValue: "10",
			},
			want: &bigquery.QueryConfig{MaxBytesBilled: int64(10)},
		},
		{
			name: "should set int field",
			args: args{
				fieldName:  "MaxBillingTier",
				fieldValue: "10",
			},
			want: &bigquery.QueryConfig{MaxBillingTier: 10},
		},
		{
			name: "should set time.Duration field (alias for int64)",
			args: args{
				fieldName:  "JobTimeout",
				fieldValue: "10000",
			},
			want: &bigquery.QueryConfig{JobTimeout: 10000},
		},
		{
			name: "should set WriteDisposition field (alias for string)",
			args: args{
				fieldName:  "WriteDisposition",
				fieldValue: "WRITE_TRUNCATE",
			},
			want: &bigquery.QueryConfig{WriteDisposition: "WRITE_TRUNCATE"},
		},
		{
			name: "should return nil when val is nil",
			args: args{
				fieldName:  "WriteDisposition",
				fieldValue: "",
			},
			want: &bigquery.QueryConfig{},
		},
		{
			name: "should error when field is not settable",
			args: args{
				fieldName:  "forceStorageAPI", // unexported field
				fieldValue: "true",
			},
			wantErr: true,
			errMsg:  "field is not settable",
		},
		{
			name: "should error when field type unsupported",
			args: args{
				fieldName:  "TableDefinitions",
				fieldValue: "{'hello': 'world'}",
			},
			wantErr: true,
			errMsg:  "unsupported field type map",
		},
		{
			name: "should error when unable to parse bool",
			args: args{
				fieldName:  "DisableQueryCache",
				fieldValue: "not a bool",
			},
			wantErr: true,
			errMsg:  "failed to parse bool",
		},
		{
			name: "should error when unable to parse int",
			args: args{
				fieldName:  "MaxBytesBilled",
				fieldValue: "not a number",
			},
			wantErr: true,
			errMsg:  "failed to parse int",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := &bigquery.QueryConfig{}
			v := reflect.ValueOf(cfg).Elem()

			err := setFieldFromString(v.FieldByName(tt.args.fieldName), tt.args.fieldValue)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.errMsg)
				return
			}
			assert.NoError(t, err)
			assert.EqualValues(t, tt.want, cfg)
		})
	}
}



================================================
FILE: dbee/adapters/clickhouse.go
================================================
package adapters

import (
	"context"
	"fmt"
	"time"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// Register client
func init() {
	_ = register(&Clickhouse{}, "clickhouse")
}

var _ core.Adapter = (*Clickhouse)(nil)

type Clickhouse struct{}

func (p *Clickhouse) Connect(url string) (core.Driver, error) {
	options, err := clickhouse.ParseDSN(url)
	if err != nil {
		return nil, fmt.Errorf("could not parse db connection string: %w", err)
	}

	jsonProcessor := func(a any) any {
		b, ok := a.([]byte)
		if !ok {
			return a
		}

		return newPostgresJSONResponse(b)
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	db := clickhouse.OpenDB(options)
	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("pinging connection failed with %v", err)
	}

	return &clickhouseDriver{
		c: builders.NewClient(db,
			builders.WithCustomTypeProcessor("json", jsonProcessor),
		),
		opts: options,
	}, nil
}

func (*Clickhouse) GetHelpers(opts *core.TableOptions) map[string]string {
	return map[string]string{
		"List": fmt.Sprintf(
			"SELECT * FROM %q.%q LIMIT 500",
			opts.Schema, opts.Table,
		),
		"Columns": fmt.Sprintf(
			"DESCRIBE %q.%q",
			opts.Schema, opts.Table,
		),
		"Info": fmt.Sprintf(
			"SELECT * FROM system.tables WHERE database = '%s' AND name = '%s'",
			opts.Schema, opts.Table,
		),
	}
}



================================================
FILE: dbee/adapters/clickhouse_driver.go
================================================
package adapters

import (
	"context"
	"fmt"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var (
	_ core.Driver           = (*clickhouseDriver)(nil)
	_ core.DatabaseSwitcher = (*clickhouseDriver)(nil)
)

type clickhouseDriver struct {
	c    *builders.Client
	opts *clickhouse.Options
}

func (c *clickhouseDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	// run query, fallback to affected rows
	return c.c.QueryUntilNotEmpty(ctx, query, "select changes() as 'Rows Affected'")
}

func (c *clickhouseDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return c.c.ColumnsFromQuery(`
		SELECT name, type
		FROM system.columns
		WHERE
			database='%s' AND
			table='%s'
		`, opts.Schema, opts.Table)
}

func (c *clickhouseDriver) Structure() ([]*core.Structure, error) {
	query := `
		SELECT
			database AS table_schema,
			name AS table_name,
			CASE
				WHEN engine IN (
					'MergeTree', 'ReplacingMergeTree', 'SummingMergeTree', 'AggregatingMergeTree',
					'CollapsingMergeTree', 'VersionedCollapsingMergeTree', 'GraphiteMergeTree',
					'TinyLog', 'Log', 'StripeLog', 'Memory', 'Buffer', 'Distributed'
				) THEN 'BASE TABLE'
				WHEN engine = 'View' THEN 'VIEW'
				WHEN engine = 'MaterializedView' THEN 'VIEW'
				WHEN engine = 'LiveView' THEN 'VIEW'
				WHEN database IN ('system', 'information_schema') THEN 'SYSTEM TABLE'
				ELSE 'UNKNOWN'
			END AS table_type
		FROM system.tables
		ORDER BY database, name
		`

	rows, err := c.Query(context.TODO(), query)
	if err != nil {
		return nil, err
	}

	return core.GetGenericStructure(rows, getPGStructureType)
}

func (c *clickhouseDriver) Close() {
	c.c.Close()
}

func (c *clickhouseDriver) ListDatabases() (current string, available []string, err error) {
	query := `
		SELECT
    		currentDatabase() AS current_db,
    		name AS schema_name
		FROM system.databases
		WHERE name NOT IN (currentDatabase(), 'INFORMATION_SCHEMA')
	`

	rows, err := c.Query(context.TODO(), query)
	if err != nil {
		return "", nil, err
	}

	for rows.HasNext() {
		row, err := rows.Next()
		if err != nil {
			return "", nil, err
		}

		// We know for a fact there are 2 string fields (see query above)
		current = row[0].(string)
		available = append(available, row[1].(string))
	}

	return current, available, nil
}

func (c *clickhouseDriver) SelectDatabase(name string) error {
	oldDB := c.opts.Auth.Database
	c.opts.Auth.Database = name

	db := clickhouse.OpenDB(c.opts)
	if err := db.PingContext(context.Background()); err != nil {
		c.opts.Auth.Database = oldDB
		return fmt.Errorf("pinging connection failed with %v", err)
	}

	c.c.Swap(db)
	return nil
}



================================================
FILE: dbee/adapters/databricks.go
================================================
package adapters

import (
	"database/sql"
	"fmt"
	"net/url"

	_ "github.com/databricks/databricks-sql-go"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// Register client
func init() {
	_ = register(&Databricks{}, "databricks")
}

var _ core.Adapter = (*Databricks)(nil)

type Databricks struct{}

// Connect parses the connectionURL and returns a new core.Driver
// connectionURL is a DSN structure in the format of:
//
// token:[my_token]@[hostname]:[port]/[endpoint http path]?param=value
//
// requires the 'catalog' parameter to be set.

// TODO: This could be extended with databricks connect by looking up
// the config if connectionURL is empty. Added in the future

// see https://github.com/databricks/databricks-sql-go for more information.
func (d *Databricks) Connect(connectionURL string) (core.Driver, error) {
	parsedURL, err := url.Parse(connectionURL)
	if err != nil {
		return nil, fmt.Errorf("failed to parse connection string: %w: ", err)
	}

	// NOTE: we could add a PingContext with timeout here but I'll leave that
	// up to the user to add in the DSN URL (given databricks bootup time).
	db, err := sql.Open("databricks", parsedURL.String())
	if err != nil {
		return nil, fmt.Errorf("invalid databricks connection string: %w", err)
	}

	currentCatalog := parsedURL.Query().Get("catalog")
	if currentCatalog == "" {
		return nil, fmt.Errorf("required parameter '?catalog=<catalog>' is missing")
	}

	return &databricksDriver{
		c:              builders.NewClient(db),
		connectionURL:  parsedURL,
		currentCatalog: currentCatalog,
	}, nil
}

// GetHelpers returns a map of helper queries for the given table.
func (d *Databricks) GetHelpers(opts *core.TableOptions) map[string]string {
	// TODO: extend this to include more helper queries
	list := fmt.Sprintf("SELECT * FROM %s.%s LIMIT 100;", opts.Schema, opts.Table)
	columns := fmt.Sprintf(`
		SELECT *
		FROM information_schema.column
		WHERE table_schema = '%s'
			AND table_name = '%s';`,
		opts.Schema, opts.Table)
	describe := fmt.Sprintf("DESCRIBE EXTENDED %s.%s;", opts.Schema, opts.Table)
	constraints := fmt.Sprintf(`
		SELECT *
		FROM information_schema.table_constraints
		WHERE table_schema = '%s'
			AND table_name = '%s';`,
		opts.Schema, opts.Table)
	keys := fmt.Sprintf(`
		SELECT *
		FROM information_schema.key_column_usage
		WHERE table_schema = '%s'
			AND table_name = '%s';`,
		opts.Schema, opts.Table)
	return map[string]string{
		"List":        list,
		"Columns":     columns,
		"Describe":    describe,
		"Constraints": constraints,
		"Keys":        keys,
	}
}



================================================
FILE: dbee/adapters/databricks_driver.go
================================================
package adapters

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var (
	_ core.Driver           = (*databricksDriver)(nil)
	_ core.DatabaseSwitcher = (*databricksDriver)(nil)
)

// databricksDriver is a driver for Databricks.
type databricksDriver struct {
	// c is the client used to execute queries.
	c              *builders.Client
	connectionURL  *url.URL
	currentCatalog string
}

// Query executes the given query and returns the result stream.
func (d *databricksDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	return d.c.QueryUntilNotEmpty(ctx, query)
}

// Columns returns the columns and their types for the given table.
func (d *databricksDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return d.c.ColumnsFromQuery(`
		SELECT column_name, data_type
		FROM information_schema.columns
		WHERE
			table_schema='%s' AND
			table_name='%s';`,
		opts.Schema, opts.Table)
}

// Structure returns the structure of the current catalog/database.
func (d *databricksDriver) Structure() ([]*core.Structure, error) {
	catalogQuery := fmt.Sprintf(`
		SELECT table_schema, table_name, table_type
		FROM system.information_schema.tables
		WHERE table_catalog = '%s'; `,
		d.currentCatalog)

	rows, err := d.Query(context.Background(), catalogQuery)
	if err != nil {
		return nil, err
	}

	return core.GetGenericStructure(rows, getDatabricksStructureType)
}

// getDatabricksStructureType returns the core.StructureType based on the
// given type string for databricks adapter.
func getDatabricksStructureType(typ string) core.StructureType {
	switch typ {
	case "TABLE", "BASE TABLE", "SYSTEM TABLE", "MANAGED", "STREAMING_TABLE", "MANAGED_SHALLOW_CLONE", "MANAGED_DEEP_CLONE":
		return core.StructureTypeTable
	case "VIEW", "SYSTEM VIEW", "MATERIALIZED_VIEW":
		return core.StructureTypeView
	default:
		return core.StructureTypeNone
	}
}

// Close closes the connection to the database.
func (d *databricksDriver) Close() {
	d.c.Close()
}

// ListDatabases returns the current catalog and a list of
// available catalogs.
func (d *databricksDriver) ListDatabases() (current string, available []string, err error) {
	query := `SHOW CATALOGS;`

	rows, err := d.Query(context.Background(), query)
	if err != nil {
		return "", nil, err
	}

	for rows.HasNext() {
		row, err := rows.Next()
		if err != nil {
			return "", nil, err
		}

		catalog, ok := row[0].(string)
		if !ok {
			return "", nil, fmt.Errorf("expected string, got %T", row[0])
		}
		available = append(available, catalog)
	}

	return d.currentCatalog, available, nil
}

// SelectDatabase switches the current database/catalog to the selected one.
func (d *databricksDriver) SelectDatabase(name string) error {
	// update the connection url with the new catalog param
	q := d.connectionURL.Query()
	q.Set("catalog", name)
	d.connectionURL.RawQuery = q.Encode()

	db, err := sql.Open("databricks", d.connectionURL.String())
	if err != nil {
		return fmt.Errorf("error switching catalog: %w", err)
	}

	// update the current catalog
	d.currentCatalog = name
	d.c.Swap(db)

	return nil
}



================================================
FILE: dbee/adapters/databricks_driver_test.go
================================================
package adapters

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// setupDatabricksTestDriver helper function to setup databricks driver for testing
func setupDatabricksTestDriver(t *testing.T) (*databricksDriver, sqlmock.Sqlmock) {
	t.Helper()

	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	require.NoError(t, err)
	t.Cleanup(func() { db.Close() })

	driver := &databricksDriver{
		c:              builders.NewClient(db),
		connectionURL:  &url.URL{},
		currentCatalog: "test_catalog",
	}

	return driver, mock
}

func Test_databricksDriver_Query(t *testing.T) {
	tests := []struct {
		give     string
		wantRows *sqlmock.Rows
		wantErr  bool
	}{
		{
			give: "SELECT * FROM test",
			wantRows: sqlmock.NewRows([]string{"col1", "col2"}).
				AddRow("value1", "value2"),
		},
		{
			give:    "INVALID QUERY",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.give, func(t *testing.T) {
			t.Parallel()

			driver, mock := setupDatabricksTestDriver(t)

			if tt.wantErr {
				mock.ExpectQuery(tt.give).WillReturnError(sql.ErrConnDone)
			} else {
				mock.ExpectQuery(tt.give).WillReturnRows(tt.wantRows)
			}

			got, err := driver.Query(context.Background(), tt.give)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, got)
				return
			}

			assert.NoError(t, err)
			assert.NotNil(t, got)
			assert.NoError(t, mock.ExpectationsWereMet())
		})
	}
}

func Test_databricksDriver_Columns(t *testing.T) {
	tests := []struct {
		name        string
		give        *core.TableOptions
		input       *sqlmock.Rows
		wantColumns []*core.Column
		wantErr     bool
	}{
		{
			name: "should succeed with cols found",
			give: &core.TableOptions{Schema: "public", Table: "users"},
			input: sqlmock.NewRows([]string{"column_name", "data_type"}).
				AddRow("id", "integer").
				AddRow("name", "varchar"),
			wantColumns: []*core.Column{
				{Name: "id", Type: "integer"},
				{Name: "name", Type: "varchar"},
			},
		},
		{
			name: "should fail with not found",
			give: &core.TableOptions{
				Schema: "invalid",
				Table:  "invalid",
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			driver, mock := setupDatabricksTestDriver(t)
			expectedQuery := fmt.Sprintf(`
                SELECT column_name, data_type
                FROM information_schema.columns
                WHERE
                    table_schema='%s' AND
                    table_name='%s';`,
				tt.give.Schema, tt.give.Table)

			if tt.wantErr {
				mock.ExpectQuery(expectedQuery).WillReturnError(sql.ErrConnDone)
			} else {
				mock.ExpectQuery(expectedQuery).WillReturnRows(tt.input)
			}

			got, err := driver.Columns(tt.give)

			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			assert.NoError(t, err)
			assert.Equal(t, tt.wantColumns, got)
			assert.NoError(t, mock.ExpectationsWereMet())
		})
	}
}

func Test_databricksDriver_Structure(t *testing.T) {
	tests := []struct {
		name     string
		testRows *sqlmock.Rows
		want     []*core.Structure
		wantErr  bool
	}{
		{
			name: "should succeed with tables and views",
			testRows: sqlmock.NewRows([]string{"table_schema", "table_name", "table_type"}).
				AddRow("public", "users", "TABLE").
				AddRow("public", "user_view", "VIEW"),
			want: []*core.Structure{
				{Name: "users", Schema: "public", Type: core.StructureTypeTable},
				{Name: "user_view", Schema: "public", Type: core.StructureTypeView},
			},
		},
		{
			name:    "should fail with error",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			driver, mock := setupDatabricksTestDriver(t)
			expectedQuery := `
                SELECT table_schema, table_name, table_type
                FROM system.information_schema.tables
                WHERE table_catalog = 'test_catalog'; `

			if tt.wantErr {
				mock.ExpectQuery(expectedQuery).WillReturnError(sql.ErrConnDone)
			} else {
				mock.ExpectQuery(expectedQuery).WillReturnRows(tt.testRows)
			}

			got, err := driver.Structure()

			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, got)
				return
			}

			assert.NoError(t, err)
			assert.NotNil(t, got)
			for _, g := range got {
				assert.Equal(t, core.StructureTypeSchema, g.Type)
				assert.Equal(t, tt.want, g.Children)
			}
			assert.NoError(t, mock.ExpectationsWereMet())
		})
	}
}

func Test_getDatabricksStructureType(t *testing.T) {
	tests := []struct {
		name string
		give string
		want core.StructureType
	}{
		{
			name: "should return table with table",
			give: "TABLE",
			want: core.StructureTypeTable,
		},
		{
			name: "should return table with system table",
			give: "SYSTEM TABLE",
			want: core.StructureTypeTable,
		},
		{
			name: "should return view with view",
			give: "VIEW",
			want: core.StructureTypeView,
		},
		{
			name: "should return none with unknown",
			give: "UNKNOWN",
			want: core.StructureTypeNone,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got := getDatabricksStructureType(tt.give)
			assert.Equal(t, tt.want, got)
		})
	}
}



================================================
FILE: dbee/adapters/databricks_test.go
================================================
package adapters

import (
	"testing"

	_ "github.com/databricks/databricks-sql-go"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestDatabricks_Connect(t *testing.T) {
	tests := []struct {
		name          string
		connectionURL string
		wantErr       bool
		messageErr    string
	}{
		{
			name:          "should fail with invalid url format",
			connectionURL: "://invalid",
			wantErr:       true,
			messageErr:    "failed to parse connection string",
		},
		{
			name:          "should fail with missing catalog",
			connectionURL: "token:dummytoken@hostname:443/sql/1.0/endpoints/1234567890",
			wantErr:       true,
			messageErr:    "required parameter '?catalog=<catalog>' is missing",
		},
		{
			name:          "should succeed with valid connection",
			connectionURL: "token:dummytoken@hostname:443/sql/1.0/endpoints/1234567890?catalog=my_catalog",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			d := &Databricks{}
			got, err := d.Connect(tt.connectionURL)

			if tt.wantErr {
				assert.NotEqual(t, "", tt.messageErr)
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.messageErr)
				return
			}
			assert.NoError(t, err)
			assert.NotNil(t, got)
		})
	}
}

func TestDatabricks_GetHelpers(t *testing.T) {
	defaultOpts := &core.TableOptions{
		Schema:          "test_schema",
		Table:           "test_table",
		Materialization: core.StructureTypeTable,
	}
	tests := []struct {
		name string
		key  string
		opts *core.TableOptions
		want string
	}{
		{
			name: "should return list query",
			key:  "List",
			opts: defaultOpts,
			want: "SELECT * FROM test_schema.test_table LIMIT 100;",
		},
		{
			name: "should return columns query",
			key:  "Columns",
			opts: defaultOpts,
			want: "\n\t\tSELECT *\n\t\tFROM information_schema.column\n\t\tWHERE table_schema = 'test_schema'\n\t\t\tAND table_name = 'test_table';",
		},
		{
			name: "should return describe query",
			key:  "Describe",
			opts: defaultOpts,
			want: "DESCRIBE EXTENDED test_schema.test_table;",
		},
		{
			name: "should return constraints query",
			key:  "Constraints",
			opts: defaultOpts,
			want: "\n\t\tSELECT *\n\t\tFROM information_schema.table_constraints\n\t\tWHERE table_schema = 'test_schema'\n\t\t\tAND table_name = 'test_table';",
		},
		{
			name: "should return key_column_usage query",
			key:  "Keys",
			opts: defaultOpts,
			want: "\n\t\tSELECT *\n\t\tFROM information_schema.key_column_usage\n\t\tWHERE table_schema = 'test_schema'\n\t\t\tAND table_name = 'test_table';",
		},
	}

	d := &Databricks{}
	helpers := d.GetHelpers(defaultOpts)

	for helperKey := range helpers {
		var found bool
		for _, tt := range tests {
			if tt.key == helperKey {
				found = true
				break
			}
		}
		require.True(t, found, "missing test case for helper key: %q", helperKey)
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			got := helpers[tt.key]
			assert.Equal(t, tt.want, got)
		})
	}
}



================================================
FILE: dbee/adapters/duck.go
================================================
//go:build cgo && ((darwin && (amd64 || arm64)) || (linux && (amd64 || arm64 || riscv64)))

package adapters

import (
	"database/sql"
	"fmt"
	"path/filepath"
	"strings"

	_ "github.com/marcboeker/go-duckdb"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// Register client
func init() {
	_ = register(&Duck{}, "duck", "duckdb")
}

var _ core.Adapter = (*Duck)(nil)

type Duck struct{}

// Helper function to get database from url
func parseDatabaseFromPath(path string) string {
	base := filepath.Base(path)
	parts := strings.Split(base, ".")
	if len(parts) > 1 && parts[0] == "" {
		parts = parts[1:]
	}
	return parts[0]
}

func (d *Duck) Connect(url string) (core.Driver, error) {
	db, err := sql.Open("duckdb", url)
	if err != nil {
		return nil, fmt.Errorf("unable to connect to duckdb database: %v", err)
	}

	currentDB := "memory"
	if url != "" {
		currentDB = parseDatabaseFromPath(url)
	}

	return &duckDriver{
		c:              builders.NewClient(db),
		currentDB: currentDB,
	}, nil
}

func (*Duck) GetHelpers(opts *core.TableOptions) map[string]string {
	return map[string]string{
		"List":        fmt.Sprintf("SELECT * FROM %q LIMIT 500", opts.Table),
		"Columns":     fmt.Sprintf("DESCRIBE %q", opts.Table),
		"Indexes":     fmt.Sprintf("SELECT * FROM duckdb_indexes() WHERE table_name = '%s'", opts.Table),
		"Constraints": fmt.Sprintf("SELECT * FROM duckdb_constraints() WHERE table_name = '%s'", opts.Table),
	}
}



================================================
FILE: dbee/adapters/duck_driver.go
================================================
package adapters

import (
	"context"
	"fmt"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var (
	_ core.Driver           = (*duckDriver)(nil)
	_ core.DatabaseSwitcher = (*duckDriver)(nil)
)

type duckDriver struct {
	c              *builders.Client
	currentDB string
}

func (d *duckDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	return d.c.QueryUntilNotEmpty(ctx, query)
}

func (d *duckDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return d.c.ColumnsFromQuery("DESCRIBE %q.%q", opts.Schema, opts.Table)
}

func (d *duckDriver) Structure() ([]*core.Structure, error) {
	catalogQuery := fmt.Sprintf(`
		SELECT table_schema, table_name, table_type
		FROM information_schema.tables
		WHERE table_catalog = '%s';`,
		d.currentDB)

	rows, err := d.Query(context.Background(), catalogQuery)
	if err != nil {
		return nil, err
	}

	return core.GetGenericStructure(rows, getDuckDBStructureType)
}

// getDuckDBStructureType returns the core.StructureType based on the
// given type string for duckdb adapter.
func getDuckDBStructureType(typ string) core.StructureType {
	// TODO: (phdah) Add more types if exists
	switch typ {
	case "BASE TABLE":
		return core.StructureTypeTable
	case "VIEW":
		return core.StructureTypeView
	default:
		return core.StructureTypeNone
	}
}

// ListDatabases returns the current catalog and a list of available catalogs.
// NOTE: (phdah) As of now, swapping catalogs is not enabled and only the
// current will be shown
func (d *duckDriver) ListDatabases() (current string, available []string, err error) {
	// no-op
	return d.currentDB, []string{"not supported yet"}, nil
}

// SelectDatabase switches the current database/catalog to the selected one.
func (d *duckDriver) SelectDatabase(name string) error {
	return nil
}

// Close closes the connection to the database.
func (d *duckDriver) Close() {
	d.c.Close()
}



================================================
FILE: dbee/adapters/duck_driver_test.go
================================================
package adapters

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func Test_parseDatabaseFromPath(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "should return `test` part from unix file path",
			input: "/tmp/test.db",
			want:  "test",
		},
		{
			name:  "should return `.hiddenFile` part from unix file path",
			input: "/tmp/.hiddenFile.db",
			want:  "hiddenFile",
		},
		{
			name:  "should return `my_file` part from file url path",
			input: "file:///tmp/my_file.database",
			want:  "my_file",
		},
		{
			name:  "should return `my_db` part from s3 bucket url",
			input: "s3://bucket_name/path/to/my_db.duckdb",
			want:  "my_db",
		},
		{
			name:  "should return `remote_db` part from https url",
			input: "https://www.example.com/remote_db.example.new",
			want:  "remote_db",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := parseDatabaseFromPath(tt.input)
			assert.Equal(t, tt.want, got)
		})
	}
}



================================================
FILE: dbee/adapters/mongo.go
================================================
package adapters

import (
	"context"
	"encoding/gob"
	"fmt"
	"net/url"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

// Register client
func init() {
	_ = register(&Mongo{}, "mongo", "mongodb")

	// register known types with gob
	// full list available in go.mongodb.org/.../bson godoc
	gob.Register(&mongoResponse{})
	gob.Register(bson.A{})
	gob.Register(bson.M{})
	gob.Register(bson.D{})
	gob.Register(primitive.ObjectID{})
	// gob.Register(primitive.DateTime)
	gob.Register(primitive.Binary{})
	gob.Register(primitive.Regex{})
	// gob.Register(primitive.JavaScript)
	gob.Register(primitive.CodeWithScope{})
	gob.Register(primitive.Timestamp{})
	gob.Register(primitive.Decimal128{})
	// gob.Register(primitive.MinKey{})
	// gob.Register(primitive.MaxKey{})
	// gob.Register(primitive.Undefined{})
	gob.Register(primitive.DBPointer{})
	// gob.Register(primitive.Symbol)
}

var _ core.Adapter = (*Mongo)(nil)

type Mongo struct{}

func (m *Mongo) Connect(rawURL string) (core.Driver, error) {
	// get database name from url
	u, err := url.Parse(rawURL)
	if err != nil {
		return nil, fmt.Errorf("mongo: invalid url: %w", err)
	}

	opts := options.Client().ApplyURI(rawURL)
	client, err := mongo.Connect(context.TODO(), opts)
	if err != nil {
		return nil, err
	}

	return &mongoDriver{
		c:      client,
		dbName: u.Path[1:],
	}, nil
}

func (*Mongo) GetHelpers(opts *core.TableOptions) map[string]string {
	return map[string]string{
		"List": fmt.Sprintf(`{"find": %q}`, opts.Table),
	}
}



================================================
FILE: dbee/adapters/mongo_driver.go
================================================
package adapters

import (
	"bytes"
	"context"
	"encoding/gob"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

var (
	_ core.Driver           = (*mongoDriver)(nil)
	_ core.DatabaseSwitcher = (*mongoDriver)(nil)
)

type mongoDriver struct {
	c      *mongo.Client
	dbName string
}

func (c *mongoDriver) getCurrentDatabase(ctx context.Context) (string, error) {
	if c.dbName != "" {
		return c.dbName, nil
	}

	dbs, err := c.c.ListDatabaseNames(ctx, bson.D{})
	if err != nil {
		return "", fmt.Errorf("failed to select default database: %w", err)
	}
	if len(dbs) < 1 {
		return "", fmt.Errorf("no databases found")
	}
	c.dbName = dbs[0]

	return c.dbName, nil
}

func (c *mongoDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return []*core.Column{
		{
			Name: "",
			Type: "collection",
		},
	}, nil
}

func (c *mongoDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	dbName, err := c.getCurrentDatabase(ctx)
	if err != nil {
		return nil, err
	}
	db := c.c.Database(dbName)

	var command any
	err = bson.UnmarshalExtJSON([]byte(query), false, &command)
	if err != nil {
		return nil, fmt.Errorf("cannot marshal command: \"%v\" to bson: %v", query, err)
	}

	var resp bson.M
	err = db.RunCommand(ctx, command).Decode(&resp)
	if err != nil {
		return nil, err
	}

	// check if "cursor" field exists and create an appropriate func
	var next func() (core.Row, error)
	var hasNext func() bool

	cur, ok := resp["cursor"]
	if ok {
		next, hasNext = builders.NextYield(func(yield func(...any)) error {
			cursor := cur.(bson.M)
			if !ok {
				return errors.New("type assertion for cursor object failed")
			}

			for _, b := range cursor {
				batch, ok := b.(bson.A)
				if !ok {
					continue
				}
				for _, item := range batch {
					yield(newMongoResponse(item))
				}
			}
			return nil
		})
	} else {
		next, hasNext = builders.NextSingle(newMongoResponse(resp))
	}

	// build result
	result := builders.NewResultStreamBuilder().
		WithNextFunc(next, hasNext).
		WithHeader(core.Header{"Reply"}).
		WithMeta(&core.Meta{
			SchemaType: core.SchemaLess,
		}).
		Build()

	return result, nil
}

func (c *mongoDriver) Structure() ([]*core.Structure, error) {
	ctx := context.Background()

	dbName, err := c.getCurrentDatabase(ctx)
	if err != nil {
		return nil, err
	}

	collections, err := c.c.Database(dbName).ListCollectionNames(ctx, bson.D{})
	if err != nil {
		return nil, err
	}

	var structure []*core.Structure

	for _, coll := range collections {
		structure = append(structure, &core.Structure{
			Name:   coll,
			Schema: "",
			Type:   core.StructureTypeTable,
		})
	}

	return structure, nil
}

func (c *mongoDriver) Close() {
	_ = c.c.Disconnect(context.TODO())
}

func (c *mongoDriver) ListDatabases() (current string, available []string, err error) {
	ctx := context.Background()

	dbName, err := c.getCurrentDatabase(ctx)
	if err != nil {
		return "", nil, err
	}

	all, err := c.c.ListDatabaseNames(ctx, bson.D{{
		Key: "name",
		Value: bson.D{{
			Key: "$not",
			Value: bson.D{{
				Key:   "$regex",
				Value: dbName,
			}},
		}},
	}})
	if err != nil {
		return "", nil, fmt.Errorf("failed to retrieve database names: %w", err)
	}

	return dbName, all, nil
}

func (c *mongoDriver) SelectDatabase(name string) error {
	c.dbName = name
	return nil
}

// mongoResponse serves as a wrapper around the mongo response
// to stringify the return values
type mongoResponse struct {
	value any
}

func newMongoResponse(val any) *mongoResponse {
	return &mongoResponse{
		value: val,
	}
}

func (mr *mongoResponse) String() string {
	parsed, err := json.MarshalIndent(mr.value, "", "  ")
	if err != nil {
		return fmt.Sprint(mr.value)
	}
	return string(parsed)
}

func (mr *mongoResponse) MarshalJSON() ([]byte, error) {
	return json.Marshal(mr.value)
}

func (mr *mongoResponse) GobEncode() ([]byte, error) {
	var err error
	w := new(bytes.Buffer)
	encoder := gob.NewEncoder(w)
	err = encoder.Encode(mr.value)
	if err != nil {
		return nil, err
	}
	return w.Bytes(), err
}

func (mr *mongoResponse) GobDecode(buf []byte) error {
	var err error
	r := bytes.NewBuffer(buf)
	decoder := gob.NewDecoder(r)
	err = decoder.Decode(&mr.value)
	if err != nil {
		return err
	}
	return err
}



================================================
FILE: dbee/adapters/mysql.go
================================================
package adapters

import (
	"database/sql"
	"fmt"
	"regexp"

	_ "github.com/go-sql-driver/mysql"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// Register client
func init() {
	_ = register(&MySQL{}, "mysql")
}

var _ core.Adapter = (*MySQL)(nil)

type MySQL struct{}

func (m *MySQL) Connect(url string) (core.Driver, error) {
	// add multiple statements support parameter
	match, err := regexp.MatchString(`[\?][\w]+=[\w-]+`, url)
	if err != nil {
		return nil, err
	}
	sep := "?"
	if match {
		sep = "&"
	}

	db, err := sql.Open("mysql", url+sep+"multiStatements=true")
	if err != nil {
		return nil, fmt.Errorf("unable to connect to mysql database: %v", err)
	}

	return &mySQLDriver{
		c: builders.NewClient(db),
	}, nil
}

func (*MySQL) GetHelpers(opts *core.TableOptions) map[string]string {
	return map[string]string{
		"List":         fmt.Sprintf("SELECT * FROM `%s`.`%s` LIMIT 500", opts.Schema, opts.Table),
		"Columns":      fmt.Sprintf("DESCRIBE `%s`.`%s`", opts.Schema, opts.Table),
		"Indexes":      fmt.Sprintf("SHOW INDEXES FROM `%s`.`%s`", opts.Schema, opts.Table),
		"Foreign Keys": fmt.Sprintf("SELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_SCHEMA = '%s' AND TABLE_NAME = '%s' AND CONSTRAINT_TYPE = 'FOREIGN KEY'", opts.Schema, opts.Table),
		"Primary Keys": fmt.Sprintf("SELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_SCHEMA = '%s' AND TABLE_NAME = '%s' AND CONSTRAINT_TYPE = 'PRIMARY KEY'", opts.Schema, opts.Table),
	}
}



================================================
FILE: dbee/adapters/mysql_driver.go
================================================
package adapters

import (
	"context"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var _ core.Driver = (*mySQLDriver)(nil)

type mySQLDriver struct {
	c *builders.Client
}

func (c *mySQLDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	// run query, fallback to affected rows
	return c.c.QueryUntilNotEmpty(ctx, query, "select ROW_COUNT() as 'Rows Affected'")
}

func (c *mySQLDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return c.c.ColumnsFromQuery("DESCRIBE `%s`.`%s`", opts.Schema, opts.Table)
}

func (c *mySQLDriver) Structure() ([]*core.Structure, error) {
	query := `SELECT table_schema, table_name FROM information_schema.tables`

	rows, err := c.Query(context.TODO(), query)
	if err != nil {
		return nil, err
	}

	children := make(map[string][]*core.Structure)

	for rows.HasNext() {
		row, err := rows.Next()
		if err != nil {
			return nil, err
		}

		// We know for a fact there are 2 string fields (see query above)
		schema := row[0].(string)
		table := row[1].(string)

		children[schema] = append(children[schema], &core.Structure{
			Name:   table,
			Schema: schema,
			Type:   core.StructureTypeTable,
		})

	}

	var structure []*core.Structure

	for k, v := range children {
		structure = append(structure, &core.Structure{
			Name:     k,
			Schema:   k,
			Type:     core.StructureTypeNone,
			Children: v,
		})
	}

	return structure, nil
}

func (c *mySQLDriver) Close() {
	c.c.Close()
}



================================================
FILE: dbee/adapters/oracle.go
================================================
package adapters

import (
	"database/sql"
	"fmt"

	_ "github.com/sijms/go-ora/v2"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// Register client
func init() {
	_ = register(&Oracle{}, "oracle")
}

var _ core.Adapter = (*Oracle)(nil)

type Oracle struct{}

func (o *Oracle) Connect(url string) (core.Driver, error) {
	db, err := sql.Open("oracle", url)
	if err != nil {
		return nil, fmt.Errorf("unable to connect to oracle database: %v", err)
	}

	return &oracleDriver{
		c: builders.NewClient(db),
	}, nil
}

func (*Oracle) GetHelpers(opts *core.TableOptions) map[string]string {
	from := `
		FROM all_constraints N
		JOIN all_cons_columns L
		ON N.constraint_name = L.constraint_name
		AND N.owner = L.owner `

	qualifyAndOrderBy := func(by string) string {
		return fmt.Sprintf(`
			L.table_name = '%s'
			ORDER BY %s`, opts.Table, by)
	}

	keyCmd := func(constraint string) string {
		return fmt.Sprintf(`
			SELECT
			L.table_name,
			L.column_name
			%s
			WHERE
			N.constraint_type = '%s' AND %s`,

			from,
			constraint,
			qualifyAndOrderBy("L.column_name"),
		)
	}

	return map[string]string{
		"Columns": fmt.Sprintf(`SELECT col.column_id,
				col.owner AS schema_name,
				col.table_name,
				col.column_name,
				col.data_type,
				col.data_length,
				col.data_precision,
				col.data_scale,
				col.nullable
			FROM sys.all_tab_columns col
			INNER JOIN sys.all_tables t
				ON col.owner = t.owner
				AND col.table_name = t.table_name
			WHERE col.owner = '%s'
				AND col.table_name = '%s'
			ORDER BY col.owner, col.table_name, col.column_id `,

			opts.Schema,
			opts.Table,
		),

		"Foreign Keys": keyCmd("R"),

		"Indexes": fmt.Sprintf(`
			SELECT DISTINCT
			N.owner,
			N.index_name,
			N.constraint_type
			%s
			WHERE %s `,

			from,
			qualifyAndOrderBy("N.index_name"),
		),

		"List": fmt.Sprintf("SELECT * FROM %q.%q", opts.Schema, opts.Table),

		"Primary Keys": keyCmd("P"),

		"References": fmt.Sprintf(`
			SELECT
			RFRING.owner,
			RFRING.table_name,
			RFRING.column_name
			FROM all_cons_columns RFRING
			JOIN all_constraints N
			ON RFRING.constraint_name = N.constraint_name
			JOIN all_cons_columns RFRD
			ON N.r_constraint_name = RFRD.constraint_name
			JOIN all_users U
			ON N.owner = U.username
			WHERE
			N.constraint_type = 'R'
			AND
			U.common = 'NO'
			AND
			RFRD.owner = '%s'
			AND
			RFRD.table_name = '%s'
			ORDER BY
			RFRING.owner,
			RFRING.table_name,
			RFRING.column_name`,

			opts.Schema,
			opts.Table,
		),
	}
}



================================================
FILE: dbee/adapters/oracle_driver.go
================================================
package adapters

import (
	"context"
	"strings"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var _ core.Driver = (*oracleDriver)(nil)

type oracleDriver struct {
	c *builders.Client
}

func (d *oracleDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	// Remove the trailing semicolon from the query - for some reason it isn't supported in go_ora
	query = strings.TrimSuffix(query, ";")

	// Use Exec or Query depending on the query
	action := strings.ToLower(strings.Split(query, " ")[0])
	hasReturnValues := strings.Contains(strings.ToLower(query), " returning ")
	if (action == "update" || action == "delete" || action == "insert") && !hasReturnValues {
		return d.c.Exec(ctx, query)
	}

	return d.c.QueryUntilNotEmpty(ctx, query)
}

func (d *oracleDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return d.c.ColumnsFromQuery(`
		SELECT
			col.column_name,
			col.data_type
		FROM sys.all_tab_columns col
		INNER JOIN sys.all_tables t
			ON col.owner = t.owner
			AND col.table_name = t.table_name
		WHERE col.owner = '%s'
			AND col.table_name = '%s'
		ORDER BY col.owner, col.table_name, col.column_id `,

		opts.Schema,
		opts.Table)
}

func (d *oracleDriver) Structure() ([]*core.Structure, error) {
	query := `
		SELECT owner, object_name, type
		FROM (
			SELECT owner, table_name as object_name, 'TABLE' as type
			FROM all_tables
			UNION ALL
			SELECT owner, table_name as object_name, 'EXTERNAL TABLE' as type
			FROM all_external_tables
			UNION ALL
			SELECT owner, view_name as object_name, 'VIEW' as type
			FROM all_views
			UNION ALL
			SELECT owner, mview_name as object_name, 'MATERIALIZED VIEW' as type
			FROM all_mviews
		)
		WHERE owner IN (SELECT username FROM all_users WHERE common = 'NO')
		ORDER BY owner, object_name
	`

	rows, err := d.Query(context.TODO(), query)
	if err != nil {
		return nil, err
	}

	decodeStructureType := func(s string) core.StructureType {
		switch s {
		case "TABLE", "EXTERNAL TABLE":
			return core.StructureTypeTable
		case "VIEW":
			return core.StructureTypeView
		case "MATERIALIZED VIEW":
			return core.StructureTypeMaterializedView
		default:
			return core.StructureTypeNone
		}
	}

	return core.GetGenericStructure(rows, decodeStructureType)
}

func (d *oracleDriver) Close() { d.c.Close() }



================================================
FILE: dbee/adapters/postgres.go
================================================
package adapters

import (
	"database/sql"
	"encoding/gob"
	"fmt"
	nurl "net/url"

	_ "github.com/lib/pq"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// Register client
func init() {
	_ = register(&Postgres{}, "postgres", "postgresql", "pg")

	// register special json response with gob
	gob.Register(&postgresJSONResponse{})
}

var _ core.Adapter = (*Postgres)(nil)

type Postgres struct{}

func (p *Postgres) Connect(url string) (core.Driver, error) {
	u, err := nurl.Parse(url)
	if err != nil {
		return nil, fmt.Errorf("could not parse db connection string: %w: ", err)
	}

	db, err := sql.Open("postgres", u.String())
	if err != nil {
		return nil, fmt.Errorf("unable to connect to postgres database: %w", err)
	}

	jsonProcessor := func(a any) any {
		b, ok := a.([]byte)
		if !ok {
			return a
		}

		return newPostgresJSONResponse(b)
	}

	return &postgresDriver{
		c: builders.NewClient(db,
			builders.WithCustomTypeProcessor("json", jsonProcessor),
			builders.WithCustomTypeProcessor("jsonb", jsonProcessor),
		),
		url: u,
	}, nil
}

func (*Postgres) GetHelpers(opts *core.TableOptions) map[string]string {
	basicConstraintQuery := `
	SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name, rc.update_rule, rc.delete_rule
	FROM
		information_schema.table_constraints AS tc
		JOIN information_schema.key_column_usage AS kcu
			ON tc.constraint_name = kcu.constraint_name
		JOIN information_schema.referential_constraints as rc
			ON tc.constraint_name = rc.constraint_name
		JOIN information_schema.constraint_column_usage AS ccu
			ON ccu.constraint_name = tc.constraint_name
	`

	return map[string]string{
		"List":    fmt.Sprintf("SELECT * FROM %q.%q LIMIT 500", opts.Schema, opts.Table),
		"Columns": fmt.Sprintf("SELECT * FROM information_schema.columns WHERE table_name='%s' AND table_schema='%s'", opts.Table, opts.Schema),
		"Indexes": fmt.Sprintf("SELECT * FROM pg_indexes WHERE tablename='%s' AND schemaname='%s'", opts.Table, opts.Schema),
		"Foreign Keys": fmt.Sprintf("%s WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '%s' AND tc.table_schema = '%s'",
			basicConstraintQuery,
			opts.Table,
			opts.Schema,
		),
		"References": fmt.Sprintf("%s WHERE constraint_type = 'FOREIGN KEY' AND ccu.table_name = '%s' AND tc.table_schema = '%s'",
			basicConstraintQuery,
			opts.Table,
			opts.Schema,
		),
		"Primary Keys": fmt.Sprintf("%s WHERE constraint_type = 'PRIMARY KEY' AND tc.table_name = '%s' AND tc.table_schema = '%s'",
			basicConstraintQuery,
			opts.Table,
			opts.Schema,
		),
	}
}



================================================
FILE: dbee/adapters/postgres_driver.go
================================================
package adapters

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/gob"
	"encoding/json"
	"fmt"
	nurl "net/url"
	"strings"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var (
	_ core.Driver           = (*postgresDriver)(nil)
	_ core.DatabaseSwitcher = (*postgresDriver)(nil)
)

type postgresDriver struct {
	c   *builders.Client
	url *nurl.URL
}

func (c *postgresDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	action := strings.ToLower(strings.Split(query, " ")[0])
	hasReturnValues := strings.Contains(strings.ToLower(query), " returning ")

	if (action == "update" || action == "delete" || action == "insert") && !hasReturnValues {
		return c.c.Exec(ctx, query)
	}

	return c.c.QueryUntilNotEmpty(ctx, query)
}

func (c *postgresDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return c.c.ColumnsFromQuery(`
		SELECT column_name, data_type
		FROM information_schema.columns
		WHERE
			table_schema='%s' AND
			table_name='%s'
		`, opts.Schema, opts.Table)
}

func (c *postgresDriver) Structure() ([]*core.Structure, error) {
	query := `
		SELECT table_schema, table_name, table_type FROM information_schema.tables UNION ALL
		SELECT schemaname, matviewname, 'VIEW' FROM pg_matviews;
	`

	rows, err := c.Query(context.TODO(), query)
	if err != nil {
		return nil, err
	}

	return core.GetGenericStructure(rows, getPGStructureType)
}

func (c *postgresDriver) Close() {
	c.c.Close()
}

func (c *postgresDriver) ListDatabases() (current string, available []string, err error) {
	query := `
		SELECT current_database(), datname FROM pg_database
		WHERE datistemplate = false
		AND datname != current_database();
	`

	rows, err := c.Query(context.TODO(), query)
	if err != nil {
		return "", nil, err
	}

	for rows.HasNext() {
		row, err := rows.Next()
		if err != nil {
			return "", nil, err
		}

		// We know for a fact there are 2 string fields (see query above)
		current = row[0].(string)
		available = append(available, row[1].(string))
	}

	return current, available, nil
}

func (c *postgresDriver) SelectDatabase(name string) error {
	c.url.Path = fmt.Sprintf("/%s", name)
	db, err := sql.Open("postgres", c.url.String())
	if err != nil {
		return fmt.Errorf("unable to switch databases: %w", err)
	}

	// sql.Open just validate its arguments
	// without creating a connection to the database
	// so we need to ping the database to check if it's valid
	if err = db.Ping(); err != nil {
		return fmt.Errorf("unable to connect to database: %q, err: %w", name, err)
	}

	c.c.Swap(db)

	return nil
}

// getPGStructureType returns the structure type based on the provided string.
func getPGStructureType(typ string) core.StructureType {
	switch typ {
	case "TABLE", "BASE TABLE", "FOREIGN", "FOREIGN TABLE", "SYSTEM TABLE":
		return core.StructureTypeTable
	case "VIEW", "SYSTEM VIEW":
		return core.StructureTypeView
	case "MATERIALIZED VIEW":
		return core.StructureTypeMaterializedView
	case "SINK":
		return core.StructureTypeSink
	case "SOURCE":
		return core.StructureTypeSource
	default:
		return core.StructureTypeNone
	}
}

// postgresJSONResponse serves as a wrapper around the json response
// to pretty-print the return values
type postgresJSONResponse struct {
	value []byte
}

func newPostgresJSONResponse(val []byte) *postgresJSONResponse {
	return &postgresJSONResponse{
		value: val,
	}
}

func (pj *postgresJSONResponse) String() string {
	var parsed bytes.Buffer
	err := json.Indent(&parsed, pj.value, "", "  ")
	if err != nil {
		return string(pj.value)
	}
	return parsed.String()
}

func (pj *postgresJSONResponse) MarshalJSON() ([]byte, error) {
	if json.Valid(pj.value) {
		return pj.value, nil
	}

	return json.Marshal(pj.value)
}

func (pj *postgresJSONResponse) GobEncode() ([]byte, error) {
	var err error
	w := new(bytes.Buffer)
	encoder := gob.NewEncoder(w)
	err = encoder.Encode(pj.value)
	if err != nil {
		return nil, err
	}
	return w.Bytes(), err
}

func (pj *postgresJSONResponse) GobDecode(buf []byte) error {
	var err error
	r := bytes.NewBuffer(buf)
	decoder := gob.NewDecoder(r)
	err = decoder.Decode(&pj.value)
	if err != nil {
		return err
	}
	return err
}



================================================
FILE: dbee/adapters/redis.go
================================================
package adapters

import (
	"encoding/gob"
	"fmt"

	"github.com/redis/go-redis/v9"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

// Register client
func init() {
	_ = register(&Redis{}, "redis")

	// register known types with gob
	gob.Register(&redisResponse{})
	gob.Register([]any{})
	gob.Register(map[any]any{})
}

var _ core.Adapter = (*Redis)(nil)

type Redis struct{}

func (r *Redis) Connect(url string) (core.Driver, error) {
	opt, err := redis.ParseURL(url)
	if err != nil {
		return nil, fmt.Errorf("unable to connect to redis database: %v", err)
	}
	c := redis.NewClient(opt)

	return &redisDriver{
		redis: c,
	}, nil
}

func (*Redis) GetHelpers(opts *core.TableOptions) map[string]string {
	return map[string]string{
		"List": "KEYS *",
	}
}



================================================
FILE: dbee/adapters/redis_driver.go
================================================
package adapters

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/redis/go-redis/v9"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var _ core.Driver = (*redisDriver)(nil)

type redisDriver struct {
	redis *redis.Client
}

func redisResponseToNext(response any) (func() (core.Row, error), func() bool) {
	// parse response
	switch resp := response.(type) {
	case string, int64, map[any]any:
		return builders.NextSingle(newRedisResponse(resp))
	case []any:
		return builders.NextSlice(resp, newRedisResponse)
	default:
		return builders.NextNil()
	}
}

func (c *redisDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	cmd, err := parseRedisCmd(query)
	if err != nil {
		return nil, err
	}

	response, err := c.redis.Do(ctx, cmd...).Result()
	if err != nil {
		return nil, err
	}

	next, hasNext := redisResponseToNext(response)

	// build result
	result := builders.NewResultStreamBuilder().
		WithNextFunc(next, hasNext).
		WithHeader(core.Header{"Reply"}).
		WithMeta(&core.Meta{
			SchemaType: core.SchemaLess,
		}).
		Build()

	return result, err
}

func (c *redisDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return []*core.Column{
		{
			Name: "",
			Type: "redis",
		},
	}, nil
}

func (c *redisDriver) Structure() ([]*core.Structure, error) {
	return []*core.Structure{
		{
			Name:   "Storage",
			Schema: "",
			Type:   core.StructureTypeTable,
		},
	}, nil
}

func (c *redisDriver) Close() {
	c.redis.Close()
}

// printSlice pretty prints nested slice using recursion
func printSlice(slice []any, level int) string {
	// indent prefix
	var prefix string
	for i := 0; i < level; i++ {
		prefix += "  "
	}

	var ret []string
	for _, v := range slice {
		if nested, ok := v.([]any); ok {
			ret = append(ret, printSlice(nested, level+1))
		} else {
			ret = append(ret, fmt.Sprintf("%s%v", prefix, v))
		}
	}
	return strings.Join(ret, "\n")
}

// printMap pretty prints map records
func printMap(m map[any]any) string {
	var ret []string
	for k, v := range m {
		ret = append(ret, fmt.Sprintf("%v: %v", k, v))
	}

	return strings.Join(ret, "\n")
}

// redisResponse serves as a wrapper around the redis response
// to stringify the return values
type redisResponse struct {
	Value any
}

// a preprocessor for redis response
func newRedisResponse(val any) any {
	return &redisResponse{
		Value: val,
	}
}

func (rr *redisResponse) String() string {
	switch value := rr.Value.(type) {
	case []any:
		return printSlice(value, 0)
	case map[any]any:
		return printMap(value)
	}
	return fmt.Sprint(rr.Value)
}

func (rr *redisResponse) MarshalJSON() ([]byte, error) {
	value := rr.Value

	m, ok := value.(map[any]any)
	if ok {
		ret := make(map[string]any)
		for k, v := range m {
			ret[fmt.Sprint(k)] = v
		}
		return json.Marshal(ret)
	}
	return json.Marshal(rr.Value)
}

// ErrUnmatchedDoubleQuote and ErrUnmatchedSingleQuote are errors returned from ParseRedisCmd
var (
	ErrUnmatchedDoubleQuote = func(position int) error { return fmt.Errorf("syntax error: unmatched double quote at: %d", position) }
	ErrUnmatchedSingleQuote = func(position int) error { return fmt.Errorf("syntax error: unmatched single quote at: %d", position) }
)

// parseRedisCmd parses string command into args for redis.Do
func parseRedisCmd(unparsed string) ([]any, error) {
	// error helper
	quoteErr := func(quote rune, position int) error {
		if quote == '"' {
			return ErrUnmatchedDoubleQuote(position)
		} else {
			return ErrUnmatchedSingleQuote(position)
		}
	}

	// return array
	var fields []any
	// what char is the current quote
	var blank rune
	var currentQuote struct {
		char     rune
		position int
	}
	// is the current char escaped or not?
	var escaped bool

	sb := &strings.Builder{}
	for i, r := range unparsed {
		// handle unescaped quotes
		if !escaped && (r == '"' || r == '\'') {
			// next char
			next := byte(' ')
			if i < len(unparsed)-1 {
				next = unparsed[i+1]
			}

			if r == currentQuote.char {
				if next != ' ' {
					return nil, quoteErr(r, i+1)
				}
				// end quote
				currentQuote.char = blank
				continue
			} else if currentQuote.char == blank {
				// start quote
				currentQuote.char = r
				currentQuote.position = i + 1
				continue
			}
		}

		// handle escapes
		if r == '\\' {
			escaped = true
			continue
		}

		// handle word end
		if currentQuote.char == blank && r == ' ' {
			fields = append(fields, sb.String())
			sb.Reset()
			continue
		}

		escaped = false
		sb.WriteRune(r)
	}

	// check if quote is not closed
	if currentQuote.char != blank {
		return nil, quoteErr(currentQuote.char, currentQuote.position)
	}

	// write last word
	if sb.Len() > 0 {
		fields = append(fields, sb.String())
	}

	return fields, nil
}



================================================
FILE: dbee/adapters/redis_test.go
================================================
package adapters

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestParseRedisCmd(t *testing.T) {
	r := require.New(t)

	type testCase struct {
		unparsed       string
		expectedResult []any
		expectedError  error
	}

	testCases := []testCase{
		// these should work
		{
			unparsed:       `set key val`,
			expectedResult: []any{"set", "key", "val"},
			expectedError:  nil,
		},
		{
			unparsed:       `set key "double quoted val"`,
			expectedResult: []any{"set", "key", "double quoted val"},
			expectedError:  nil,
		},
		{
			unparsed:       `set key 'single quoted val'`,
			expectedResult: []any{"set", "key", "single quoted val"},
			expectedError:  nil,
		},
		{
			unparsed:       `set key 'single quoted val with nested unescaped double quote (")'`,
			expectedResult: []any{"set", "key", "single quoted val with nested unescaped double quote (\")"},
			expectedError:  nil,
		},
		{
			unparsed:       `set key 'single quoted val with nested escaped double quote (\")'`,
			expectedResult: []any{"set", "key", "single quoted val with nested escaped double quote (\")"},
			expectedError:  nil,
		},
		{
			unparsed:       `set key 'single quoted val with nested escaped single quote (\')'`,
			expectedResult: []any{"set", "key", "single quoted val with nested escaped single quote (')"},
			expectedError:  nil,
		},
		{
			unparsed:       `set key "double quoted val with nested unescaped single quote (')"`,
			expectedResult: []any{"set", "key", "double quoted val with nested unescaped single quote (')"},
			expectedError:  nil,
		},
		{
			unparsed:       `set key "double quoted val with nested escaped single quote (\')"`,
			expectedResult: []any{"set", "key", "double quoted val with nested escaped single quote (')"},
			expectedError:  nil,
		},
		{
			unparsed:       `set key "double quoted val with nested escaped double quote (\")"`,
			expectedResult: []any{"set", "key", "double quoted val with nested escaped double quote (\")"},
			expectedError:  nil,
		},

		// these shouldn't work
		{
			unparsed:       `set key "unmatched double quoted val`,
			expectedResult: nil,
			expectedError:  ErrUnmatchedDoubleQuote(9),
		},
		{
			unparsed:       `set key 'unmatched single quoted val`,
			expectedResult: nil,
			expectedError:  ErrUnmatchedSingleQuote(9),
		},
		{
			unparsed:       `set key "double quoted val with nested unescaped double quote (")"`,
			expectedResult: nil,
			expectedError:  ErrUnmatchedDoubleQuote(64),
		},
		{
			unparsed:       `set key 'single quoted val with nested unescaped single quote (')'`,
			expectedResult: nil,
			expectedError:  ErrUnmatchedSingleQuote(64),
		},
	}

	for _, tc := range testCases {
		parsed, err := parseRedisCmd(tc.unparsed)
		if err != nil {
			r.Equal(err.Error(), tc.expectedError.Error())
			continue
		}
		r.Equal(parsed, tc.expectedResult)
	}
}



================================================
FILE: dbee/adapters/redshift.go
================================================
package adapters

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// init registers the RedshiftClient to the store,
// i.e. to lua frontend.
func init() {
	_ = register(&Redshift{}, "redshift")
}

var _ core.Adapter = (*Redshift)(nil)

type Redshift struct{}

func (r *Redshift) Connect(rawURL string) (core.Driver, error) {
	connURL, err := url.Parse(rawURL)
	if err != nil {
		return nil, fmt.Errorf("failed to parse connection string: %w", err)
	}

	// TODO: perhaps better to use something else than postgres driver..
	db, err := sql.Open("postgres", connURL.String())
	if err != nil {
		return nil, fmt.Errorf("unable to connect to redshift: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("unable to ping redshift: %w", err)
	}

	return &redshiftDriver{
		c:             builders.NewClient(db),
		connectionURL: connURL,
	}, nil
}

func (r *Redshift) GetHelpers(opts *core.TableOptions) map[string]string {
	out := make(map[string]string, 0)
	list := fmt.Sprintf("SELECT * FROM %q.%q LIMIT 100;", opts.Schema, opts.Table)

	switch opts.Materialization {
	case core.StructureTypeTable:
		out = map[string]string{
			"List":    list,
			"Columns": fmt.Sprintf("SELECT * FROM information_schema.columns WHERE table_name='%s' AND table_schema='%s';", opts.Table, opts.Schema),
			"Indexes": fmt.Sprintf("SELECT * FROM pg_indexes WHERE tablename='%s' AND schemaname='%s';", opts.Table, opts.Schema),
			"Foreign Keys": fmt.Sprintf(`
				SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name, rc.update_rule, rc.delete_rule
				FROM
					information_schema.table_constraints AS tc
					JOIN information_schema.key_column_usage AS kcu
						ON tc.constraint_name = kcu.constraint_name
					JOIN information_schema.referential_constraints as rc
						ON tc.constraint_name = rc.constraint_name
					JOIN information_schema.constraint_column_usage AS ccu
						ON ccu.constraint_name = tc.constraint_name
				WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '%s' AND tc.table_schema = '%s';`,

				opts.Table,
				opts.Schema,
			),
			"Table Definition": fmt.Sprintf(`
				SELECT
					*
				FROM svv_table_info
				WHERE "schema" = '%s'
					AND "table" = '%s';`,

				opts.Schema,
				opts.Table,
			),
		}

	case core.StructureTypeView:
		out = map[string]string{
			"List": list,
			"View Definition": fmt.Sprintf(`
				SELECT
					*
				FROM pg_views
				WHERE schemaname = '%s'
					AND viewname = '%s';`,

				opts.Schema,
				opts.Table,
			),
		}
	}

	return out
}



================================================
FILE: dbee/adapters/redshift_driver.go
================================================
package adapters

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"
	"time"

	_ "github.com/lib/pq"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var (
	_ core.Driver           = (*redshiftDriver)(nil)
	_ core.DatabaseSwitcher = (*redshiftDriver)(nil)
)

// redshiftDriver is a sql client for redshiftDriver.
// Mainly uses the postgres driver under the hood but with
// custom Layout function to get the table and view names correctly.
type redshiftDriver struct {
	c             *builders.Client
	connectionURL *url.URL
}

// Query executes a query and returns the result as an IterResult.
func (r *redshiftDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	return r.c.QueryUntilNotEmpty(ctx, query)
}

// Close closes the underlying sql.DB connection.
func (r *redshiftDriver) Close() {
	r.c.Close()
}

func (r *redshiftDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return r.c.ColumnsFromQuery(`
		SELECT column_name, data_type
		FROM information_schema.columns
		WHERE
			table_schema='%s' AND
			table_name='%s'
		`, opts.Schema, opts.Table)
}

// Structure returns the layout of the database. This represents the
// "schema" with all the tables and views. Note that ordering is not
// done here. The ordering is done in the lua frontend.
func (r *redshiftDriver) Structure() ([]*core.Structure, error) {
	query := `
		SELECT
			trim(n.nspname) AS schema_name,
			trim(c.relname) AS table_name,
			CASE
				WHEN c.relkind = 'v' THEN 'VIEW'
				ELSE 'TABLE'
			END AS table_type
			FROM
				pg_class AS c
			INNER JOIN
				pg_namespace AS n ON c.relnamespace = n.oid
			WHERE
				n.nspname NOT IN ('information_schema', 'pg_catalog');
	`

	rows, err := r.Query(context.Background(), query)
	if err != nil {
		return nil, err
	}

	return core.GetGenericStructure(rows, getPGStructureType)
}

func (r *redshiftDriver) ListDatabases() (current string, available []string, err error) {
	query := `
		SELECT current_database() AS current, datname
		FROM pg_database
		WHERE datistemplate = false
		  AND datname != current_database();`

	rows, err := r.Query(context.Background(), query)
	if err != nil {
		return "", nil, err
	}

	for rows.HasNext() {
		row, err := rows.Next()
		if err != nil {
			return "", nil, err
		}

		// current database is the first column, available databases are the rest
		current = row[0].(string)
		available = append(available, row[1].(string))
	}

	return current, available, nil
}

func (r *redshiftDriver) SelectDatabase(name string) error {
	r.connectionURL.Path = fmt.Sprintf("/%s", name)
	db, err := sql.Open("postgres", r.connectionURL.String())
	if err != nil {
		return fmt.Errorf("unable to switch databases: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err = db.PingContext(ctx); err != nil {
		return fmt.Errorf("unable to ping redshift: %w", err)
	}

	r.c.Swap(db)
	return nil
}



================================================
FILE: dbee/adapters/sqlite.go
================================================
//go:build (darwin && (amd64 || arm64)) || (freebsd && (386 || amd64 || arm || arm64)) || (linux && (386 || amd64 || arm || arm64 || ppc64le || riscv64 || s390x)) || (netbsd && amd64) || (openbsd && (amd64 || arm64)) || (windows && (amd64 || arm64))

package adapters

import (
	"database/sql"
	"fmt"
	"os/user"
	"path/filepath"
	"strings"

	_ "modernc.org/sqlite"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// Register client
func init() {
	_ = register(&SQLite{}, "sqlite", "sqlite3")
}

var _ core.Adapter = (*SQLite)(nil)

type SQLite struct{}

func (s *SQLite) expandPath(path string) (string, error) {
	usr, err := user.Current()
	if err != nil {
		return "", fmt.Errorf("user.Current: %w", err)
	}

	if path == "~" {
		return usr.HomeDir, nil
	} else if strings.HasPrefix(path, "~/") {
		return filepath.Join(usr.HomeDir, path[2:]), nil
	}

	return path, nil
}

func (s *SQLite) Connect(url string) (core.Driver, error) {
	path, err := s.expandPath(url)
	if err != nil {
		return nil, err
	}

	db, err := sql.Open("sqlite", path)
	if err != nil {
		return nil, fmt.Errorf("unable to connect to sqlite database: %v", err)
	}

	return &sqliteDriver{
		c:               builders.NewClient(db),
		currentDatabase: path,
	}, nil
}

func (*SQLite) GetHelpers(opts *core.TableOptions) map[string]string {
	return map[string]string{
		"List":         fmt.Sprintf("SELECT * FROM %q LIMIT 500", opts.Table),
		"Columns":      fmt.Sprintf("PRAGMA table_info('%s')", opts.Table),
		"Indexes":      fmt.Sprintf("SELECT * FROM pragma_index_list('%s')", opts.Table),
		"Foreign Keys": fmt.Sprintf("SELECT * FROM pragma_foreign_key_list('%s')", opts.Table),
		"Primary Keys": fmt.Sprintf("SELECT * FROM pragma_index_list('%s') WHERE origin = 'pk'", opts.Table),
	}
}



================================================
FILE: dbee/adapters/sqlite_driver.go
================================================
package adapters

import (
	"context"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var (
	_ core.Driver           = (*sqliteDriver)(nil)
	_ core.DatabaseSwitcher = (*sqliteDriver)(nil)
)

type sqliteDriver struct {
	c               *builders.Client
	currentDatabase string
}

func (d *sqliteDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	// run query, fallback to affected rows
	return d.c.QueryUntilNotEmpty(ctx, query, "select changes() as 'Rows Affected'")
}

func (d *sqliteDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return d.c.ColumnsFromQuery("SELECT name, type FROM pragma_table_info('%s')", opts.Table)
}

func (d *sqliteDriver) Structure() ([]*core.Structure, error) {
	// sqlite is single schema structure, so we hardcode the name of it.
	query := "SELECT 'sqlite_schema' as schema, name, type FROM sqlite_schema"

	rows, err := d.Query(context.Background(), query)
	if err != nil {
		return nil, err
	}

	decodeStructureType := func(typ string) core.StructureType {
		switch typ {
		case "table":
			return core.StructureTypeTable
		case "view":
			return core.StructureTypeView
		default:
			return core.StructureTypeNone
		}
	}
	return core.GetGenericStructure(rows, decodeStructureType)
}

func (d *sqliteDriver) Close() { d.c.Close() }

func (d *sqliteDriver) ListDatabases() (string, []string, error) {
	return d.currentDatabase, []string{"not supported yet"}, nil
}

// SelectDatabase is a no-op, added to make the UI more pleasent.
func (d *sqliteDriver) SelectDatabase(name string) error { return nil }



================================================
FILE: dbee/adapters/sqlserver.go
================================================
package adapters

import (
	"database/sql"
	"encoding/gob"
	"fmt"
	nurl "net/url"

	"github.com/google/uuid"
	_ "github.com/microsoft/go-mssqldb"
	_ "github.com/microsoft/go-mssqldb/integratedauth/krb5"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

// Register client
func init() {
	_ = register(&SQLServer{}, "sqlserver", "mssql")

	gob.Register(uuid.UUID{})
}

var _ core.Adapter = (*SQLServer)(nil)

type SQLServer struct{}

func (s *SQLServer) Connect(url string) (core.Driver, error) {
	u, err := nurl.Parse(url)
	if err != nil {
		return nil, fmt.Errorf("could not parse db connection string: %w: ", err)
	}

	db, err := sql.Open("sqlserver", u.String())
	if err != nil {
		return nil, fmt.Errorf("unable to connect to sqlserver database: %v", err)
	}

	return &sqlServerDriver{
		c: builders.NewClient(db,
			builders.WithCustomTypeProcessor(
				"uniqueidentifier",
				func(a any) any {
					b, ok := a.([]byte)
					if !ok {
						return a
					}

					id, err := uuid.FromBytes(b)
					if err != nil {
						return a
					}

					return id
				}),
		),
		url: u,
	}, nil
}

func (*SQLServer) GetHelpers(opts *core.TableOptions) map[string]string {
	columnSummary := fmt.Sprintf(`
      SELECT c.column_name + ' (' +
          ISNULL(( SELECT 'PK, ' FROM information_schema.table_constraints AS k JOIN information_schema.key_column_usage AS kcu ON k.constraint_name = kcu.constraint_name WHERE constraint_type='PRIMARY KEY' AND k.table_name = c.table_name AND kcu.column_name = c.column_name), '') +
          ISNULL(( SELECT 'FK, ' FROM information_schema.table_constraints AS k JOIN information_schema.key_column_usage AS kcu ON k.constraint_name = kcu.constraint_name WHERE constraint_type='FOREIGN KEY' AND k.table_name = c.table_name AND kcu.column_name = c.column_name), '') +
          data_type + COALESCE('(' + RTRIM(CAST(character_maximum_length AS VARCHAR)) + ')','(' + RTRIM(CAST(numeric_precision AS VARCHAR)) + ',' + RTRIM(CAST(numeric_scale AS VARCHAR)) + ')','(' + RTRIM(CAST(datetime_precision AS VARCHAR)) + ')','') + ', ' +
          CASE WHEN is_nullable = 'YES' THEN 'null' ELSE 'not null' END + ')' AS Columns
      FROM information_schema.columns c WHERE c.table_name='%s' AND c.TABLE_SCHEMA = '%s'`,

		opts.Table,
		opts.Schema,
	)

	foreignKeys := fmt.Sprintf(`
      SELECT c.constraint_name
         , kcu.column_name AS column_name
         , c2.table_name AS foreign_table_name
         , kcu2.column_name AS foreign_column_name
      FROM information_schema.table_constraints c
            INNER JOIN information_schema.key_column_usage kcu
              ON c.constraint_schema = kcu.constraint_schema
                AND c.constraint_name = kcu.constraint_name
            INNER JOIN information_schema.referential_constraints rc
              ON c.constraint_schema = rc.constraint_schema
                AND c.constraint_name = rc.constraint_name
            INNER JOIN information_schema.table_constraints c2
              ON rc.unique_constraint_schema = c2.constraint_schema
                AND rc.unique_constraint_name = c2.constraint_name
            INNER JOIN information_schema.key_column_usage kcu2
              ON c2.constraint_schema = kcu2.constraint_schema
                AND c2.constraint_name = kcu2.constraint_name
                AND kcu.ordinal_position = kcu2.ordinal_position
      WHERE c.constraint_type = 'FOREIGN KEY'
      AND c.TABLE_NAME = '%s' AND c.TABLE_SCHEMA = '%s'`,

		opts.Table,
		opts.Schema,
	)

	references := fmt.Sprintf(`
      SELECT kcu1.constraint_name AS constraint_name
          , kcu1.table_name AS foreign_table_name
          , kcu1.column_name AS foreign_column_name
          , kcu2.column_name AS column_name
      FROM information_schema.referential_constraints AS rc
      INNER JOIN information_schema.key_column_usage AS kcu1
          ON kcu1.constraint_catalog = rc.constraint_catalog
          AND kcu1.constraint_schema = rc.constraint_schema
          AND kcu1.constraint_name = rc.constraint_name
      INNER JOIN information_schema.key_column_usage AS kcu2
          ON kcu2.constraint_catalog = rc.unique_constraint_catalog
          AND kcu2.constraint_schema = rc.unique_constraint_schema
          AND kcu2.constraint_name = rc.unique_constraint_name
          AND kcu2.ordinal_position = kcu1.ordinal_position
      WHERE kcu2.table_name='%s' AND kcu2.table_schema = '%s'`,

		opts.Table,
		opts.Schema,
	)

	primaryKeys := fmt.Sprintf(`
       SELECT tc.constraint_name, kcu.column_name
       FROM
           information_schema.table_constraints AS tc
           JOIN information_schema.key_column_usage AS kcu
             ON tc.constraint_name = kcu.constraint_name
           JOIN information_schema.constraint_column_usage AS ccu
             ON ccu.constraint_name = tc.constraint_name
      WHERE constraint_type = 'PRIMARY KEY'
      AND tc.table_name = '%s' AND tc.table_schema = '%s'`,

		opts.Table,
		opts.Schema,
	)

	constraints := fmt.Sprintf(`
      SELECT u.CONSTRAINT_NAME, c.CHECK_CLAUSE FROM INFORMATION_SCHEMA.CONSTRAINT_TABLE_USAGE u
          INNER JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS c ON u.CONSTRAINT_NAME = c.CONSTRAINT_NAME
      WHERE TABLE_NAME = '%s' AND u.TABLE_SCHEMA = '%s'`,

		opts.Table,
		opts.Schema,
	)

	return map[string]string{
		"List":         fmt.Sprintf("SELECT top 200 * from [%s]", opts.Table),
		"Columns":      columnSummary,
		"Indexes":      fmt.Sprintf("exec sp_helpindex '%s.%s'", opts.Schema, opts.Table),
		"Foreign Keys": foreignKeys,
		"References":   references,
		"Primary Keys": primaryKeys,
		"Constraints":  constraints,
		"Describe":     fmt.Sprintf("exec sp_help ''%s.%s''", opts.Schema, opts.Table),
	}
}



================================================
FILE: dbee/adapters/sqlserver_driver.go
================================================
package adapters

import (
	"context"
	"database/sql"
	"fmt"
	nurl "net/url"
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
)

var (
	_ core.Driver           = (*sqlServerDriver)(nil)
	_ core.DatabaseSwitcher = (*sqlServerDriver)(nil)
)

type sqlServerDriver struct {
	c   *builders.Client
	url *nurl.URL
}

func (c *sqlServerDriver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	// run query, fallback to affected rows
	return c.c.QueryUntilNotEmpty(ctx, query, "select @@ROWCOUNT as 'Rows Affected'")
}

func (c *sqlServerDriver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	return c.c.ColumnsFromQuery(`
		SELECT
			column_name,
			data_type
		FROM information_schema.columns
			WHERE table_name='%s' AND
			table_schema = '%s'`,
		opts.Table,
		opts.Schema,
	)
}

func (c *sqlServerDriver) Structure() ([]*core.Structure, error) {
	query := `
    SELECT table_schema, table_name, table_type
    FROM INFORMATION_SCHEMA.TABLES`

	rows, err := c.Query(context.TODO(), query)
	if err != nil {
		return nil, err
	}

	return core.GetGenericStructure(rows, getPGStructureType)
}

func (c *sqlServerDriver) Close() {
	c.c.Close()
}

func (c *sqlServerDriver) ListDatabases() (current string, available []string, err error) {
	query := `
		SELECT DB_NAME(), name
		FROM sys.databases
		WHERE name != DB_NAME();
	`

	rows, err := c.Query(context.TODO(), query)
	if err != nil {
		return "", nil, err
	}

	for rows.HasNext() {
		row, err := rows.Next()
		if err != nil {
			return "", nil, err
		}

		// We know for a fact there are 2 string fields (see query above)
		current = row[0].(string)
		available = append(available, row[1].(string))
	}

	return current, available, nil
}

func (c *sqlServerDriver) SelectDatabase(name string) error {
	q := c.url.Query()
	q.Set("database", name)
	c.url.RawQuery = q.Encode()

	db, err := sql.Open("sqlserver", c.url.String())
	if err != nil {
		return fmt.Errorf("unable to switch databases: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		return fmt.Errorf("unable to switch databases: %w", err)
	}

	c.c.Swap(db)

	return nil
}



================================================
FILE: dbee/core/call.go
================================================
package core

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
)

type (
	CallID string

	Call struct {
		id        CallID
		query     string
		state     CallState
		timeTaken time.Duration
		timestamp time.Time

		result     *Result
		archive    *archive
		cancelFunc func()

		// any error that might occur during execution
		err  error
		done chan struct{}
	}
)

// callPersistent is used for marshaling and unmarshaling the call
type callPersistent struct {
	ID        string `json:"id"`
	Query     string `json:"query"`
	State     string `json:"state"`
	TimeTaken int64  `json:"time_taken_us"`
	Timestamp int64  `json:"timestamp_us"`
	Error     string `json:"error,omitempty"`
}

func (c *Call) toPersistent() *callPersistent {
	errMsg := ""
	if c.err != nil {
		errMsg = c.err.Error()
	}

	return &callPersistent{
		ID:        string(c.id),
		Query:     c.query,
		State:     c.state.String(),
		TimeTaken: c.timeTaken.Microseconds(),
		Timestamp: c.timestamp.UnixMicro(),
		Error:     errMsg,
	}
}

func (s *Call) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.toPersistent())
}

func (c *Call) UnmarshalJSON(data []byte) error {
	var alias callPersistent

	if err := json.Unmarshal(data, &alias); err != nil {
		return err
	}

	done := make(chan struct{})
	close(done)

	archive := newArchive(CallID(alias.ID))
	state := CallStateFromString(alias.State)
	if state == CallStateArchived && archive.isEmpty() {
		state = CallStateUnknown
	}

	var callErr error
	if alias.Error != "" {
		callErr = errors.New(alias.Error)
	}

	*c = Call{
		id:        CallID(alias.ID),
		query:     alias.Query,
		state:     state,
		timeTaken: time.Duration(alias.TimeTaken) * time.Microsecond,
		timestamp: time.UnixMicro(alias.Timestamp),
		err:       callErr,

		result:  new(Result),
		archive: newArchive(CallID(alias.ID)),

		done: done,
	}

	return nil
}

func newCallFromExecutor(executor func(context.Context) (ResultStream, error), query string, onEvent func(CallState, *Call)) *Call {
	id := CallID(uuid.New().String())
	c := &Call{
		id:    id,
		query: query,
		state: CallStateUnknown,

		result:  new(Result),
		archive: newArchive(id),

		done: make(chan struct{}),
	}

	eventsCh := make(chan CallState, 10)

	ctx, cancel := context.WithCancel(context.Background())
	c.timestamp = time.Now()
	c.cancelFunc = func() {
		cancel()
		c.timeTaken = time.Since(c.timestamp)
		eventsCh <- CallStateCanceled
	}

	// event function handler
	go func() {
		for state := range eventsCh {
			if c.state == CallStateExecutingFailed ||
				c.state == CallStateRetrievingFailed ||
				c.state == CallStateCanceled {
				return
			}
			c.state = state

			// trigger event callback
			if onEvent != nil {
				onEvent(state, c)
			}
		}
	}()

	go func() {
		defer close(eventsCh)

		// execute the function
		eventsCh <- CallStateExecuting
		iter, err := executor(ctx)
		if err != nil {
			c.timeTaken = time.Since(c.timestamp)
			c.err = err
			eventsCh <- CallStateExecutingFailed
			close(c.done)
			return
		}

		// set iterator to result
		err = c.result.SetIter(iter, func() { eventsCh <- CallStateRetrieving })
		if err != nil {
			c.timeTaken = time.Since(c.timestamp)
			c.err = err
			eventsCh <- CallStateRetrievingFailed
			close(c.done)
			return
		}

		// archive the result
		err = c.archive.setResult(c.result)
		if err != nil {
			c.timeTaken = time.Since(c.timestamp)
			c.err = err
			eventsCh <- CallStateArchiveFailed
			close(c.done)
			return
		}

		c.timeTaken = time.Since(c.timestamp)
		eventsCh <- CallStateArchived
		close(c.done)
	}()

	return c
}

func (c *Call) GetID() CallID {
	return c.id
}

func (c *Call) GetQuery() string {
	return c.query
}

func (c *Call) GetState() CallState {
	return c.state
}

func (c *Call) GetTimeTaken() time.Duration {
	return c.timeTaken
}

func (c *Call) GetTimestamp() time.Time {
	return c.timestamp
}

func (c *Call) Err() error {
	return c.err
}

// Done returns a non-buffered channel that is closed when
// call finishes.
func (c *Call) Done() chan struct{} {
	return c.done
}

func (c *Call) Cancel() {
	if c.state > CallStateExecuting {
		return
	}
	if c.cancelFunc != nil {
		c.cancelFunc()
	}
}

func (c *Call) GetResult() (*Result, error) {
	if c.result.IsEmpty() {
		iter, err := c.archive.getResult()
		if err != nil {
			return nil, fmt.Errorf("c.archive.getResult: %w", err)
		}
		err = c.result.SetIter(iter, nil)
		if err != nil {
			return nil, fmt.Errorf("c.result.setIter: %w", err)
		}
	}

	return c.result, nil
}



================================================
FILE: dbee/core/call_archive.go
================================================
package core

import (
	"encoding/gob"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sync/atomic"
	"time"

	"golang.org/x/sync/errgroup"
)

func init() {
	// gob doesn't know how to encode/decode time otherwise
	gob.Register(time.Time{})
}

const archiveBasePath = "/tmp/dbee-history/"

// these variables create a file name for a specified type
var (
	archiveDir = func(callID CallID) string {
		return filepath.Join(archiveBasePath, string(callID))
	}

	metaFile = func(callID CallID) string {
		return filepath.Join(archiveDir(callID), "meta.gob")
	}
	headerFile = func(callID CallID) string {
		return filepath.Join(archiveDir(callID), "header.gob")
	}
	rowFile = func(callID CallID, i int) string {
		return filepath.Join(archiveDir(callID), fmt.Sprintf("row_%d.gob", i))
	}
)

type archive struct {
	id       CallID
	isFilled bool
}

func newArchive(id CallID) *archive {
	isFilled := true
	_, err := os.Stat(archiveDir(id))
	if os.IsNotExist(err) {
		isFilled = false
	}
	return &archive{
		id:       id,
		isFilled: isFilled,
	}
}

func (a *archive) isEmpty() bool {
	return !a.isFilled
}

// archive stores the cache record to disk as a set of gob files
func (a *archive) setResult(result *Result) error {
	if a.isFilled {
		return nil
	}

	// create the directory for the history record
	err := os.MkdirAll(archiveDir(a.id), os.ModePerm)
	if err != nil {
		return fmt.Errorf("os.MkdirAll: %w", err)
	}

	// serialize the data
	// files inside the directory ..../call_id/:
	// header.gob - header
	// meta.gob - meta
	// row_0.gob - first row
	// row_n.gob - n-th row

	// header
	file, err := os.Create(headerFile(a.id))
	if err != nil {
		return fmt.Errorf("os.Create: %w", err)
	}
	defer file.Close()

	encoder := gob.NewEncoder(file)
	err = encoder.Encode(result.Header())
	if err != nil {
		return fmt.Errorf("encoder.Encode: %w", err)
	}

	// meta
	file, err = os.Create(metaFile(a.id))
	if err != nil {
		return err
	}
	defer file.Close()

	encoder = gob.NewEncoder(file)
	err = encoder.Encode(*result.Meta())
	if err != nil {
		return err
	}

	// rows
	chunkSize := 500
	length := len(result.rows)

	// write chunks concurrently
	g := &errgroup.Group{}
	g.SetLimit(10)
	for i := 0; i <= length/chunkSize; i++ {
		i := i
		g.Go(func() error {
			// get chunk
			chunkStart := chunkSize * i
			chunkEnd := chunkSize * (i + 1)
			if chunkEnd > length {
				chunkEnd = length
			}
			chunk, err := result.Rows(chunkStart, chunkEnd)
			if err != nil {
				return err
			}
			if len(chunk) == 0 {
				return nil
			}

			file, err := os.Create(rowFile(a.id, i))
			if err != nil {
				return fmt.Errorf("os.Create: %w", err)
			}
			defer file.Close()

			encoder := gob.NewEncoder(file)
			err = encoder.Encode(chunk)
			if err != nil {
				return fmt.Errorf("encoder.Encode: %w", err)
			}

			return nil
		})
	}
	if err := g.Wait(); err != nil {
		return err
	}

	a.isFilled = true

	return nil
}

// unarchive loads result from archive in form of an iterator
func (a *archive) getResult() (*archiveRows, error) {
	if !a.isFilled {
		return nil, errors.New("archive does not contain a result")
	}
	return newArchiveRows(a.id)
}

type archiveRows struct {
	id      CallID
	header  Header
	meta    *Meta
	iter    func() (Row, error)
	hasNext func() bool
}

func newArchiveRows(id CallID) (*archiveRows, error) {
	r := &archiveRows{
		id: id,
	}

	err := r.readHeader()
	if err != nil {
		return nil, err
	}
	err = r.readMeta()
	if err != nil {
		return nil, err
	}

	r.readIter()

	return r, nil
}

func (r *archiveRows) readHeader() error {
	// header
	var header Header
	file, err := os.Open(headerFile(r.id))
	if err != nil {
		return fmt.Errorf("os.Open: %w", err)
	}
	defer file.Close()

	decoder := gob.NewDecoder(file)
	err = decoder.Decode(&header)
	if err != nil {
		return fmt.Errorf("decoder.Decode: %w", err)
	}

	r.header = header

	return nil
}

func (r *archiveRows) readMeta() error {
	// meta
	var meta Meta
	file, err := os.Open(metaFile(r.id))
	if err != nil {
		return fmt.Errorf("os.Open: %w", err)
	}
	defer file.Close()

	decoder := gob.NewDecoder(file)
	err = decoder.Decode(&meta)
	if err != nil {
		return fmt.Errorf("decoder.Decode: %w", err)
	}

	r.meta = &meta

	return nil
}

// closeOnce closes the channel if it isn't already closed.
func closeOnce[T any](ch chan T) {
	select {
	case <-ch:
	default:
		close(ch)
	}
}

// readIter creates next and hasNext functions.
// This method is basically the same as builders/NextYield, but is copy-pasted
// because of import cycles.
func (r *archiveRows) readIter() {
	// open the first file if it exists,
	// loop through its contents and try the next file
	fileExists := func(rowIndex int) bool {
		_, err := os.Stat(rowFile(r.id, rowIndex))
		return err == nil
	}

	// openFile returns rows of the file
	openFile := func(i int) ([]Row, error) {
		file, err := os.Open(rowFile(r.id, i))
		if err != nil {
			return nil, fmt.Errorf("os.Open: %w", err)
		}
		defer file.Close()

		var rows []Row

		decoder := gob.NewDecoder(file)
		err = decoder.Decode(&rows)
		if err != nil {
			return nil, fmt.Errorf("decoder.Decode: %w", err)
		}

		return rows, nil
	}

	resultsCh := make(chan []any, 10)
	errorsCh := make(chan error, 1)
	readyCh := make(chan struct{})
	doneCh := make(chan struct{})

	// spawn channel function
	go func() {
		defer func() {
			close(doneCh)
			closeOnce(readyCh)
			close(resultsCh)
			close(errorsCh)
		}()

		file := 0
		for {
			if !fileExists(file) {
				return
			}
			rows, err := openFile(file)
			if err != nil {
				errorsCh <- err
				return
			}

			for _, row := range rows {
				resultsCh <- row
				closeOnce(readyCh)
			}

			file++
		}
	}()

	<-readyCh

	var nextVal atomic.Value
	var nextErr atomic.Value

	r.hasNext = func() bool {
		select {
		case vals, ok := <-resultsCh:
			if !ok {
				return false
			}
			nextVal.Store(vals)
			return true
		case err := <-errorsCh:
			if err != nil {
				nextErr.Store(err)
				return false
			}
		case <-doneCh:
			if len(resultsCh) < 1 {
				return false
			}
		case <-time.After(5 * time.Second):
			nextErr.Store(errors.New("next row timeout"))
			return false
		}

		return r.hasNext()
	}

	r.iter = func() (Row, error) {
		var val Row
		var err error

		nval := nextVal.Load()
		if nval != nil {
			val = nval.([]any)
		}
		nerr := nextErr.Load()
		if nerr != nil {
			err = nerr.(error)
		}
		return val, err
	}
}

func (r *archiveRows) Meta() *Meta {
	return r.meta
}

func (r *archiveRows) Header() Header {
	return r.header
}

func (r *archiveRows) Next() (Row, error) {
	return r.iter()
}

func (r *archiveRows) HasNext() bool {
	return r.hasNext()
}

func (r *archiveRows) Close() {
	// no-op
}



================================================
FILE: dbee/core/call_state.go
================================================
package core

type CallState int

const (
	CallStateUnknown CallState = iota
	CallStateExecuting
	CallStateExecutingFailed
	CallStateRetrieving
	CallStateRetrievingFailed
	CallStateArchived
	CallStateArchiveFailed
	CallStateCanceled
)

func CallStateFromString(s string) CallState {
	switch s {
	case CallStateUnknown.String():
		return CallStateUnknown

	case CallStateExecuting.String():
		return CallStateExecuting
	case CallStateExecutingFailed.String():
		return CallStateExecutingFailed

	case CallStateRetrieving.String():
		return CallStateRetrieving
	case CallStateRetrievingFailed.String():
		return CallStateRetrievingFailed

	case CallStateArchived.String():
		return CallStateArchived
	case CallStateArchiveFailed.String():
		return CallStateArchiveFailed

	case CallStateCanceled.String():
		return CallStateCanceled

	default:
		return CallStateUnknown
	}
}

func (s CallState) String() string {
	switch s {
	case CallStateUnknown:
		return "unknown"

	case CallStateExecuting:
		return "executing"
	case CallStateExecutingFailed:
		return "executing_failed"

	case CallStateRetrieving:
		return "retrieving"
	case CallStateRetrievingFailed:
		return "retrieving_failed"

	case CallStateArchived:
		return "archived"
	case CallStateArchiveFailed:
		return "archive_failed"

	case CallStateCanceled:
		return "canceled"

	default:
		return "unknown"
	}
}



================================================
FILE: dbee/core/call_test.go
================================================
package core_test

import (
	"context"
	"encoding/json"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/require"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/mock"
)

func TestCall_Success(t *testing.T) {
	r := require.New(t)

	rows := mock.NewRows(0, 10)

	connection, err := core.NewConnection(&core.ConnectionParams{}, mock.NewAdapter(rows,
		mock.AdapterWithResultStreamOpts(mock.ResultStreamWithNextSleep(300*time.Millisecond)),
	))
	r.NoError(err)

	expectedEvents := []core.CallState{
		core.CallStateExecuting,
		core.CallStateRetrieving,
		core.CallStateArchived,
	}

	eventIndex := 0
	call := connection.Execute("_", func(state core.CallState, c *core.Call) {
		// make sure events were in order
		r.Equal(expectedEvents[eventIndex], state)
		eventIndex++

		if state == core.CallStateRetrieving {
			result, err := c.GetResult()
			r.NoError(err)

			actualRows, err := result.Rows(0, len(rows))
			r.NoError(err)

			r.Equal(rows, actualRows)
		}
	})

	// wait for call to finish
	select {
	case <-call.Done():
		// wait a bit for event index to stabilize
		time.Sleep(100 * time.Millisecond)
	case <-time.After(5 * time.Second):
		t.Error("call did not finish in expected time")
	}

	// make sure all events passed
	r.Equal(len(expectedEvents), eventIndex)
}

func TestCall_Cancel(t *testing.T) {
	r := require.New(t)

	rows := mock.NewRows(0, 10)

	adapter := mock.NewAdapter(rows,
		mock.AdapterWithQuerySideEffect("wait", func(ctx context.Context) error {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-time.After(10 * time.Second):
			}
			return nil
		}),
		mock.AdapterWithResultStreamOpts(mock.ResultStreamWithNextSleep(300*time.Millisecond)),
	)

	connection, err := core.NewConnection(&core.ConnectionParams{}, adapter)
	r.NoError(err)

	expectedEvents := []core.CallState{
		core.CallStateExecuting,
		core.CallStateCanceled,
	}

	eventIndex := 0
	call := connection.Execute("wait", func(state core.CallState, c *core.Call) {
		// wait for first event and cancel request
		c.Cancel()
		// make sure events were in order
		r.Equal(expectedEvents[eventIndex], state)
		eventIndex++
	})

	// wait for call to finish
	select {
	case <-call.Done():
		// wait a bit for event index to stabilize
		time.Sleep(100 * time.Millisecond)
	case <-time.After(5 * time.Second):
		t.Error("call did not finish in expected time")
	}

	// make sure all events passed
	r.Equal(len(expectedEvents), eventIndex)
}

func TestCall_FailedQuery(t *testing.T) {
	r := require.New(t)

	rows := mock.NewRows(0, 10)

	adapter := mock.NewAdapter(rows,
		mock.AdapterWithQuerySideEffect("fail", func(ctx context.Context) error {
			return errors.New("query failed")
		}),
		mock.AdapterWithResultStreamOpts(mock.ResultStreamWithNextSleep(300*time.Millisecond)),
	)

	connection, err := core.NewConnection(&core.ConnectionParams{}, adapter)
	r.NoError(err)

	expectedEvents := []core.CallState{
		core.CallStateExecuting,
		core.CallStateExecutingFailed,
	}

	eventIndex := 0
	call := connection.Execute("fail", func(state core.CallState, c *core.Call) {
		// make sure events were in order
		r.Equal(expectedEvents[eventIndex], state)
		eventIndex++

		if state == core.CallStateExecutingFailed {
			r.NotNil(c.Err())
		}
	})

	// wait for call to finish
	select {
	case <-call.Done():
		// wait a bit for event index to stabilize
		time.Sleep(100 * time.Millisecond)
	case <-time.After(5 * time.Second):
		t.Error("call did not finish in expected time")
	}

	// make sure all events passed
	r.Equal(len(expectedEvents), eventIndex)
}

func TestCall_Archive(t *testing.T) {
	r := require.New(t)

	rows := mock.NewRows(0, 10)

	connection, err := core.NewConnection(&core.ConnectionParams{}, mock.NewAdapter(rows,
		mock.AdapterWithResultStreamOpts(mock.ResultStreamWithNextSleep(300*time.Millisecond)),
	))
	r.NoError(err)

	call := connection.Execute("_", nil)

	// wait for call to finish
	select {
	case <-call.Done():
		// wait a bit for event index to stabilize
		time.Sleep(100 * time.Millisecond)
	case <-time.After(5 * time.Second):
		t.Error("call did not finish in expected time")
	}

	// check result
	result, err := call.GetResult()
	r.NoError(err)
	actualRows, err := result.Rows(0, len(rows))
	r.NoError(err)
	r.Equal(rows, actualRows)

	// marshal to json
	b, err := json.Marshal(call)
	r.NoError(err)

	// marshal back
	restoredCall := new(core.Call)
	err = json.Unmarshal(b, restoredCall)
	r.NoError(err)

	// check result again
	result, err = restoredCall.GetResult()
	r.NoError(err)
	actualRows, err = result.Rows(0, len(rows))
	r.NoError(err)
	r.Equal(rows, actualRows)
}



================================================
FILE: dbee/core/connection.go
================================================
package core

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"github.com/google/uuid"
)

var ErrDatabaseSwitchingNotSupported = errors.New("database switching not supported")

// TableOptions contain options for gathering information about specific table.
type TableOptions struct {
	Table           string
	Schema          string
	Materialization StructureType
}

type (
	// Adapter is an object which allows to connect to database using a url.
	// It also has the GetHelpers method, which returns a list of operations for
	// a given type.
	Adapter interface {
		Connect(url string) (Driver, error)
		GetHelpers(opts *TableOptions) map[string]string
	}

	// Driver is an interface for a specific database driver.
	Driver interface {
		Query(ctx context.Context, query string) (ResultStream, error)
		Structure() ([]*Structure, error)
		Columns(opts *TableOptions) ([]*Column, error)
		Close()
	}

	// DatabaseSwitcher is an optional interface for drivers that have database switching capabilities.
	DatabaseSwitcher interface {
		SelectDatabase(string) error
		ListDatabases() (current string, available []string, err error)
	}
)

type ConnectionID string

type Connection struct {
	params           *ConnectionParams
	unexpandedParams *ConnectionParams

	driver  Driver
	adapter Adapter
}

func (s *Connection) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.params)
}

func NewConnection(params *ConnectionParams, adapter Adapter) (*Connection, error) {
	expanded := params.Expand()

	if expanded.ID == "" {
		expanded.ID = ConnectionID(uuid.New().String())
	}

	driver, err := adapter.Connect(expanded.URL)
	if err != nil {
		return nil, fmt.Errorf("adapter.Connect: %w", err)
	}

	c := &Connection{
		params:           expanded,
		unexpandedParams: params,

		driver:  driver,
		adapter: adapter,
	}

	return c, nil
}

func (c *Connection) GetID() ConnectionID {
	return c.params.ID
}

func (c *Connection) GetName() string {
	return c.params.Name
}

func (c *Connection) GetType() string {
	return c.params.Type
}

func (c *Connection) GetURL() string {
	return c.params.URL
}

// GetParams returns the original source for this connection
func (c *Connection) GetParams() *ConnectionParams {
	return c.unexpandedParams
}

func (c *Connection) Execute(query string, onEvent func(CallState, *Call)) *Call {
	exec := func(ctx context.Context) (ResultStream, error) {
		if strings.TrimSpace(query) == "" {
			return nil, errors.New("empty query")
		}
		return c.driver.Query(ctx, query)
	}

	return newCallFromExecutor(exec, query, onEvent)
}

// SelectDatabase tries to switch to a given database with the used client.
// on error, the switch doesn't happen and the previous connection remains active.
func (c *Connection) SelectDatabase(name string) error {
	switcher, ok := c.driver.(DatabaseSwitcher)
	if !ok {
		return ErrDatabaseSwitchingNotSupported
	}

	err := switcher.SelectDatabase(name)
	if err != nil {
		return fmt.Errorf("switcher.SelectDatabase: %w", err)
	}

	return nil
}

func (c *Connection) ListDatabases() (current string, available []string, err error) {
	switcher, ok := c.driver.(DatabaseSwitcher)
	if !ok {
		return "", nil, ErrDatabaseSwitchingNotSupported
	}

	currentDB, availableDBs, err := switcher.ListDatabases()
	if err != nil {
		return "", nil, fmt.Errorf("switcher.ListDatabases: %w", err)
	}

	return currentDB, availableDBs, nil
}

func (c *Connection) GetColumns(opts *TableOptions) ([]*Column, error) {
	if opts == nil {
		return nil, fmt.Errorf("opts cannot be nil")
	}

	cols, err := c.driver.Columns(opts)
	if err != nil {
		return nil, fmt.Errorf("c.driver.Columns: %w", err)
	}
	if len(cols) < 1 {
		return nil, errors.New("no column names found for specified opts")
	}

	return cols, nil
}

func (c *Connection) GetStructure() ([]*Structure, error) {
	// structure
	structure, err := c.driver.Structure()
	if err != nil {
		return nil, err
	}

	// fallback to not confuse users
	if len(structure) < 1 {
		structure = []*Structure{
			{
				Name: "no schema to show",
				Type: StructureTypeNone,
			},
		}
	}
	return structure, nil
}

func (c *Connection) GetHelpers(opts *TableOptions) map[string]string {
	if opts == nil {
		opts = &TableOptions{}
	}

	helpers := c.adapter.GetHelpers(opts)
	if helpers == nil {
		return make(map[string]string)
	}

	return helpers
}

func (c *Connection) Close() {
	c.driver.Close()
}



================================================
FILE: dbee/core/connection_params.go
================================================
package core

import "encoding/json"

type ConnectionParams struct {
	ID   ConnectionID
	Name string
	Type string
	URL  string
}

// Expand returns a copy of the original parameters with expanded fields
func (p *ConnectionParams) Expand() *ConnectionParams {
	return &ConnectionParams{
		ID:   ConnectionID(expandOrDefault(string(p.ID))),
		Name: expandOrDefault(p.Name),
		Type: expandOrDefault(p.Type),
		URL:  expandOrDefault(p.URL),
	}
}

func (cp *ConnectionParams) MarshalJSON() ([]byte, error) {
	return json.Marshal(struct {
		ID   string `json:"id"`
		Name string `json:"name"`
		Type string `json:"type"`
		URL  string `json:"url"`
	}{
		ID:   string(cp.ID),
		Name: cp.Name,
		Type: cp.Type,
		URL:  cp.URL,
	})
}



================================================
FILE: dbee/core/expand.go
================================================
package core

import (
	"bytes"
	"errors"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

func expand(value string) (string, error) {
	tmpl, err := template.New("expand_variables").
		Funcs(template.FuncMap{
			"env":  os.Getenv,
			"exec": execCommand,
		}).
		Parse(value)
	if err != nil {
		return "", err
	}

	var out bytes.Buffer
	err = tmpl.Execute(&out, nil)
	if err != nil {
		return "", err
	}

	return out.String(), nil
}

func execCommand(line string) (string, error) {
	if strings.Contains(line, " | ") {
		out, err := exec.Command("sh", "-c", line).Output()
		return strings.TrimSpace(string(out)), err
	}

	l := strings.Split(line, " ")
	if len(l) < 1 {
		return "", errors.New("no command provided")
	}
	cmd := l[0]
	args := l[1:]

	out, err := exec.Command(cmd, args...).Output()
	return strings.TrimSpace(string(out)), err
}

// expandOrDefault silently suppresses errors.
func expandOrDefault(value string) string {
	ex, err := expand(value)
	if err != nil {
		return value
	}
	return ex
}



================================================
FILE: dbee/core/expand_test.go
================================================
package core

import (
	"os"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestExpand(t *testing.T) {
	r := require.New(t)

	testCases := []struct {
		input    string
		expected string
	}{
		{"normal string", "normal string"},
		{"{{ env `HOME` }}", os.Getenv("HOME")},
		{"{{ exec `echo \"hello\nbuddy\" | grep buddy` }}", "buddy"},
	}

	for _, tc := range testCases {
		actual, err := expand(tc.input)
		r.NoError(err)

		r.Equal(tc.expected, actual)
	}
}



================================================
FILE: dbee/core/result.go
================================================
package core

import (
	"context"
	"fmt"
	"sync"
	"time"
)

var ErrInvalidRange = func(from, to int) error { return fmt.Errorf("invalid selection range: %d ... %d", from, to) }

// Result is the cached form of the ResultStream iterator
type Result struct {
	header Header
	meta   *Meta
	rows   []Row

	isDrained  bool
	isFilled   bool
	writeMutex sync.Mutex
	readMutex  sync.RWMutex
}

// SetIter sets the ResultStream iterator to result.
// This can be done only once!
func (cr *Result) SetIter(iter ResultStream, onFillStart func()) error {
	// lock write mutex
	cr.writeMutex.Lock()
	defer cr.writeMutex.Unlock()

	// close iterator on return
	defer iter.Close()

	cr.header = iter.Header()
	cr.meta = iter.Meta()
	cr.rows = make([]Row, 0)

	cr.isDrained = false
	cr.isFilled = true

	defer func() { cr.isDrained = true }()

	// trigger callback
	if onFillStart != nil {
		onFillStart()
	}

	// drain the iterator
	for iter.HasNext() {
		row, err := iter.Next()
		if err != nil {
			cr.isFilled = false
			return err
		}

		cr.rows = append(cr.rows, row)
	}

	return nil
}

func (cr *Result) Wipe() {
	// lock write and read mutexes
	cr.writeMutex.Lock()
	defer cr.writeMutex.Unlock()
	cr.readMutex.Lock()
	defer cr.readMutex.Unlock()

	// clear everything
	cr.header = Header{}
	cr.meta = &Meta{}
	cr.rows = []Row{}
	cr.isDrained = false
	cr.isFilled = false
}

func (cr *Result) Format(formatter Formatter, from, to int) ([]byte, error) {
	rows, fromAdjusted, _, err := cr.getRows(from, to)
	if err != nil {
		return nil, fmt.Errorf("cr.Rows: %w", err)
	}

	opts := &FormatterOptions{
		SchemaType: cr.meta.SchemaType,
		ChunkStart: fromAdjusted,
	}

	f, err := formatter.Format(cr.header, rows, opts)
	if err != nil {
		return nil, fmt.Errorf("formatter.Format: %w", err)
	}

	return f, nil
}

func (cr *Result) Len() int {
	return len(cr.rows)
}

func (cr *Result) IsEmpty() bool {
	return !cr.isFilled
}

func (cr *Result) Header() Header {
	return cr.header
}

func (cr *Result) Meta() *Meta {
	return cr.meta
}

func (cr *Result) Rows(from, to int) ([]Row, error) {
	rows, _, _, err := cr.getRows(from, to)
	return rows, err
}

// getRows returns the row range and adjusted from-to values
func (cr *Result) getRows(from, to int) (rows []Row, rangeFrom, rangeTo int, err error) {
	// increment the read mutex
	cr.readMutex.RLock()
	defer cr.readMutex.RUnlock()

	// validation
	if (from < 0 && to < 0) || (from >= 0 && to >= 0) {
		if from > to {
			return nil, 0, 0, ErrInvalidRange(from, to)
		}
	}
	// undefined -> error
	if from < 0 && to >= 0 {
		return nil, 0, 0, ErrInvalidRange(from, to)
	}

	// timeout context
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Wait for drain, available index or timeout
	for !cr.isDrained && (to < 0 || to > len(cr.rows)) {

		if err := ctx.Err(); err != nil {
			return nil, 0, 0, fmt.Errorf("cache flushing timeout exceeded: %s", err)
		}
		time.Sleep(50 * time.Millisecond)
	}

	// calculate range
	length := len(cr.rows)
	if from < 0 {
		from += length + 1
		if from < 0 {
			from = 0
		}
	}
	if to < 0 {
		to += length + 1
		if to < 0 {
			to = 0
		}
	}

	if from > length {
		from = length
	}
	if to > length {
		to = length
	}

	return cr.rows[from:to], from, to, nil
}



================================================
FILE: dbee/core/result_test.go
================================================
package core_test

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/mock"
)

func TestResult(t *testing.T) {
	type testCase struct {
		name          string
		from          int
		to            int
		input         []core.Row
		expected      []core.Row
		expectedError error
	}

	testCases := []testCase{
		{
			name:          "get all",
			from:          0,
			to:            -1,
			input:         mock.NewRows(0, 10),
			expected:      mock.NewRows(0, 10),
			expectedError: nil,
		},
		{
			name:          "get basic range",
			from:          0,
			to:            3,
			input:         mock.NewRows(0, 10),
			expected:      mock.NewRows(0, 3),
			expectedError: nil,
		},
		{
			name:          "get last 2",
			from:          -3,
			to:            -1,
			input:         mock.NewRows(0, 10),
			expected:      mock.NewRows(8, 10),
			expectedError: nil,
		},
		{
			name:          "get only one",
			from:          0,
			to:            1,
			input:         mock.NewRows(0, 10),
			expected:      mock.NewRows(0, 1),
			expectedError: nil,
		},

		{
			name:          "invalid range",
			from:          5,
			to:            1,
			input:         mock.NewRows(0, 10),
			expected:      nil,
			expectedError: core.ErrInvalidRange(5, 1),
		},
		{
			name:          "invalid range (even if 10 can be higher than -1, its undefined and should fail)",
			from:          -5,
			to:            10,
			input:         mock.NewRows(0, 10),
			expected:      nil,
			expectedError: core.ErrInvalidRange(-5, 10),
		},

		{
			name:          "wait for available index",
			from:          0,
			to:            3,
			input:         mock.NewRows(0, 10),
			expected:      mock.NewRows(0, 3),
			expectedError: nil,
		},
		{
			name:          "wait for all to be drained",
			from:          0,
			to:            -1,
			input:         mock.NewRows(0, 10),
			expected:      mock.NewRows(0, 10),
			expectedError: nil,
		},
	}

	result := new(core.Result)

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			r := require.New(t)
			// wipe any previous result
			result.Wipe()

			// set a new iterator with input
			err := result.SetIter(mock.NewResultStream(tc.input, mock.ResultStreamWithNextSleep(300*time.Millisecond)), nil)
			r.NoError(err)

			rows, err := result.Rows(tc.from, tc.to)
			if err != nil {
				r.ErrorContains(tc.expectedError, err.Error())
			}
			r.Equal(rows, tc.expected)
		})
	}
}



================================================
FILE: dbee/core/types.go
================================================
package core

import (
	"errors"
	"strings"
)

type SchemaType int

const (
	SchemaFul SchemaType = iota
	SchemaLess
)

type (
	// FormatterOptions provide various options for formatters
	FormatterOptions struct {
		SchemaType SchemaType
		ChunkStart int
	}

	// Formatter converts header and rows to bytes
	Formatter interface {
		Format(header Header, rows []Row, opts *FormatterOptions) ([]byte, error)
	}
)

type (
	// Row and Header are attributes of IterResult iterator
	Row    []any
	Header []string

	// Meta holds metadata
	Meta struct {
		// type of schema (schemaful or schemaless)
		SchemaType SchemaType
	}

	// ResultStream is a result from executed query and has a form of an iterator
	ResultStream interface {
		Meta() *Meta
		Header() Header
		Next() (Row, error)
		HasNext() bool
		Close()
	}
)

type StructureType int

const (
	StructureTypeNone StructureType = iota
	StructureTypeTable
	StructureTypeView
	StructureTypeMaterializedView
	StructureTypeStreamingTable
	StructureTypeSink
	StructureTypeSource
	StructureTypeManaged
	StructureTypeSchema
)

// String returns the string representation of the StructureType
func (s StructureType) String() string {
	switch s {
	case StructureTypeNone:
		return ""
	case StructureTypeTable:
		return "table"
	case StructureTypeView:
		return "view"
	case StructureTypeMaterializedView:
		return "materialized_view"
	case StructureTypeStreamingTable:
		return "streaming_table"
	case StructureTypeSink:
		return "sink"
	case StructureTypeSource:
		return "source"
	case StructureTypeManaged:
		return "managed"
	case StructureTypeSchema:
		return "schema"
	default:
		return ""
	}
}

// ErrInsufficienStructureInfo is returned when the structure info is insufficient
var ErrInsufficienStructureInfo = errors.New("structure info is insufficient. Expected at least 'schema', 'table' and 'type' columns in that order")

// GetGenericStructure returns a generic structure for an adapter.
// The rows `ResultStream` need to be a query which returns at least 3 string columns:
//  1. schema
//  2. table
//  3. type
//
// in this order.
//
// The `structTypeFn` function is used to determine the `StructureType` based on the type string.
// `structTypeFn` is adapter specific based on `type` pattern.
// The function should return `StructureTypeNone` if the type is unknown.
func GetGenericStructure(rows ResultStream, structTypeFn func(string) StructureType) ([]*Structure, error) {
	children := make(map[string][]*Structure)

	for rows.HasNext() {
		row, err := rows.Next()
		if err != nil {
			return nil, err
		}
		if len(row) < 3 {
			return nil, ErrInsufficienStructureInfo
		}

		errCast := errors.New("expected string, got %T")
		schema, ok := row[0].(string)
		if !ok {
			return nil, errCast
		}
		table, ok := row[1].(string)
		if !ok {
			return nil, errCast
		}
		typ, ok := row[2].(string)
		if !ok {
			return nil, errCast
		}

		children[schema] = append(children[schema], &Structure{
			Name:   table,
			Schema: schema,
			Type:   structTypeFn(typ),
		})
	}

	structure := make([]*Structure, 0, len(children))

	for schema, models := range children {
		structure = append(structure, &Structure{
			Name:     schema,
			Schema:   schema,
			Type:     StructureTypeSchema,
			Children: models,
		})
	}

	return structure, nil
}

func StructureTypeFromString(s string) StructureType {
	switch strings.ToLower(s) {
	case "table":
		return StructureTypeTable
	case "view":
		return StructureTypeView
	default:
		return StructureTypeNone
	}
}

// Structure represents the structure of a single database
type Structure struct {
	// Name to be displayed
	Name   string
	Schema string
	// Type of layout
	Type StructureType
	// Children layout nodes
	Children []*Structure
}

type Column struct {
	// Column name
	Name string
	// Database data type
	Type string
}



================================================
FILE: dbee/core/builders/client.go
================================================
package builders

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

// default sql client used by other specific implementations
type Client struct {
	db             *sql.DB
	typeProcessors map[string]func(any) any
}

func NewClient(db *sql.DB, opts ...ClientOption) *Client {
	config := clientConfig{
		typeProcessors: make(map[string]func(any) any),
	}
	for _, opt := range opts {
		opt(&config)
	}

	return &Client{
		db:             db,
		typeProcessors: config.typeProcessors,
	}
}

func (c *Client) Close() {
	c.db.Close()
}

// Swap swaps current database connection for another one
// and closes the old one.
func (c *Client) Swap(db *sql.DB) {
	c.db.Close()
	c.db = db
}

// ColumnsFromQuery executes a given query on a new connection and
// converts the results to columns. A query should return a result that is
// at least 2 columns wide and have the following structure:
//
//	1st elem: name - string
//	2nd elem: type - string
//
// Query is sprintf-ed with args, so ColumnsFromQuery("select a from %s", "table_name") works.
func (c *Client) ColumnsFromQuery(query string, args ...any) ([]*core.Column, error) {
	result, err := c.Query(context.Background(), fmt.Sprintf(query, args...))
	if err != nil {
		return nil, err
	}

	return ColumnsFromResultStream(result)
}

// Exec executes a query and returns a stream with single row (number of affected results).
func (c *Client) Exec(ctx context.Context, query string) (*ResultStream, error) {
	res, err := c.db.ExecContext(ctx, query)
	if err != nil {
		return nil, err
	}

	affected, err := res.RowsAffected()
	if err != nil {
		return nil, err
	}

	rows := NewResultStreamBuilder().
		WithNextFunc(NextSingle(affected)).
		WithHeader(core.Header{"Rows Affected"}).
		Build()

	return rows, nil
}

// Query executes a query on a connection and returns a result stream.
func (c *Client) Query(ctx context.Context, query string) (*ResultStream, error) {
	rows, err := c.db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}

	return c.parseRows(rows)
}

// QueryUntilNotEmpty executes given queries on a single connection and returns when one of them
// has a nonempty result.
// Useful for specifying "fallback" queries like "ROWCOUNT()" when there are no results in query.
func (c *Client) QueryUntilNotEmpty(ctx context.Context, queries ...string) (*ResultStream, error) {
	if len(queries) < 1 {
		return nil, errors.New("no queries provided")
	}

	conn, err := c.db.Conn(ctx)
	if err != nil {
		return nil, fmt.Errorf("c.db.Conn: %w", err)
	}

	for _, query := range queries {
		rows, err := conn.QueryContext(ctx, query)
		if err != nil {
			_ = conn.Close()
			return nil, fmt.Errorf("conn.QueryContext: %w", err)
		}

		result, err := c.parseRows(rows)
		if err != nil {
			_ = conn.Close()
			return nil, err
		}

		// has result
		if len(result.Header()) > 0 {
			result.AddCallback(func() { _ = conn.Close() })
			return result, nil
		}

		result.Close()
	}

	_ = conn.Close()

	// return an empty result
	return NewResultStreamBuilder().
		WithNextFunc(NextNil()).
		WithHeader(core.Header{"No Results"}).
		Build(), nil
}

func (c *Client) getTypeProcessor(typ string) func(any) any {
	proc, ok := c.typeProcessors[strings.ToLower(typ)]
	if ok {
		return proc
	}

	return func(val any) any {
		valb, ok := val.([]byte)
		if ok {
			return string(valb)
		}
		return val
	}
}

// parseRows transforms sql rows to result stream.
func (c *Client) parseRows(rows *sql.Rows) (*ResultStream, error) {
	// create new rows
	header, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	hasNextFunc := func() bool {
		// TODO: do we even support multiple result sets?
		// if not next result, check for any new sets
		if !rows.Next() {
			if !rows.NextResultSet() {
				return false
			}
			return rows.Next()
		}
		return true
	}

	nextFunc := func() (core.Row, error) {
		dbCols, err := rows.ColumnTypes()
		if err != nil {
			return nil, err
		}

		columns := make([]any, len(dbCols))
		columnPointers := make([]any, len(dbCols))
		for i := range columns {
			columnPointers[i] = &columns[i]
		}

		if err := rows.Scan(columnPointers...); err != nil {
			return nil, err
		}

		row := make(core.Row, len(dbCols))
		for i := range dbCols {
			val := *columnPointers[i].(*any)

			proc := c.getTypeProcessor(dbCols[i].DatabaseTypeName())

			row[i] = proc(val)
		}

		return row, nil
	}

	result := NewResultStreamBuilder().
		WithNextFunc(nextFunc, hasNextFunc).
		WithHeader(header).
		WithCloseFunc(func() {
			_ = rows.Close()
		}).
		Build()

	return result, nil
}



================================================
FILE: dbee/core/builders/client_options.go
================================================
package builders

import "strings"

type clientConfig struct {
	typeProcessors map[string]func(any) any
}

type ClientOption func(*clientConfig)

func WithCustomTypeProcessor(typ string, fn func(any) any) ClientOption {
	return func(cc *clientConfig) {
		t := strings.ToLower(typ)
		_, ok := cc.typeProcessors[t]
		if ok {
			// processor already registered for this type
			return
		}

		cc.typeProcessors[t] = fn
	}
}



================================================
FILE: dbee/core/builders/columns.go
================================================
package builders

import (
	"errors"
	"fmt"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

// ColumnsFromResultStream converts the result stream to columns.
// A result stream should return rows that are at least 2 columns wide and
// have the following structure:
//
//	1st elem: name - string
//	2nd elem: type - string
func ColumnsFromResultStream(rows core.ResultStream) ([]*core.Column, error) {
	var out []*core.Column

	for rows.HasNext() {
		row, err := rows.Next()
		if err != nil {
			return nil, fmt.Errorf("result.Next: %w", err)
		}

		if len(row) < 2 {
			return nil, errors.New("could not retrieve column info: insufficient data")
		}

		name, ok := row[0].(string)
		if !ok {
			return nil, errors.New("could not retrieve column info: name not a string")
		}

		typ, ok := row[1].(string)
		if !ok {
			return nil, errors.New("could not retrieve column info: type not a string")
		}

		column := &core.Column{
			Name: name,
			Type: typ,
		}

		out = append(out, column)
	}

	return out, nil
}



================================================
FILE: dbee/core/builders/next.go
================================================
package builders

import (
	"errors"
	"sync/atomic"
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

// NextSingle creates next and hasNext functions from a provided single value
func NextSingle(value any) (func() (core.Row, error), func() bool) {
	has := true

	// iterator functions
	next := func() (core.Row, error) {
		if !has {
			return nil, errors.New("no next row")
		}
		has = false
		return core.Row{value}, nil
	}

	hasNext := func() bool {
		return has
	}

	return next, hasNext
}

// NextSlice creates next and hasNext functions from provided values
// preprocessor is an optional function which parses a single value from slice before adding it to a row
func NextSlice[T any](values []T, preprocess func(T) any) (func() (core.Row, error), func() bool) {
	if preprocess == nil {
		preprocess = func(v T) any { return v }
	}

	index := 0

	hasNext := func() bool {
		return index < len(values)
	}

	// iterator functions
	next := func() (core.Row, error) {
		if !hasNext() {
			return nil, errors.New("no next row")
		}

		row := core.Row{preprocess(values[index])}
		index++
		return row, nil
	}

	return next, hasNext
}

// NextNil creates next and hasNext functions that don't return anything (no rows)
func NextNil() (func() (core.Row, error), func() bool) {
	hasNext := func() bool {
		return false
	}

	// iterator functions
	next := func() (core.Row, error) {
		return nil, errors.New("no next row")
	}

	return next, hasNext
}

// closeOnce closes the channel if it isn't already closed.
func closeOnce[T any](ch chan T) {
	select {
	case <-ch:
	default:
		close(ch)
	}
}

// NextYield creates next and hasNext functions by calling yield in internal function.
// WARNING: the caller must call "hasNext" before each call to "next".
func NextYield(fn func(yield func(...any)) error) (func() (core.Row, error), func() bool) {
	resultsCh := make(chan []any, 10)
	errorsCh := make(chan error, 1)
	readyCh := make(chan struct{})
	doneCh := make(chan struct{})

	// spawn channel function
	go func() {
		defer func() {
			close(doneCh)
			closeOnce(readyCh)
			close(resultsCh)
			close(errorsCh)
		}()

		err := fn(func(v ...any) {
			resultsCh <- v
			closeOnce(readyCh)
		})
		if err != nil {
			errorsCh <- err
		}
	}()

	<-readyCh

	var nextVal atomic.Value
	var nextErr atomic.Value

	var hasNext func() bool
	hasNext = func() bool {
		select {
		case vals, ok := <-resultsCh:
			if !ok {
				return false
			}
			nextVal.Store(vals)
			return true
		case err := <-errorsCh:
			if err != nil {
				nextErr.Store(err)
				return false
			}
		case <-doneCh:
			if len(resultsCh) < 1 {
				return false
			}
		case <-time.After(5 * time.Second):
			nextErr.Store(errors.New("next row timeout"))
			return false
		}

		return hasNext()
	}

	next := func() (core.Row, error) {
		var val core.Row
		var err error

		nval := nextVal.Load()
		if nval != nil {
			val = nval.([]any)
		}
		nerr := nextErr.Load()
		if nerr != nil {
			err = nerr.(error)
		}
		return val, err
	}

	return next, hasNext
}



================================================
FILE: dbee/core/builders/next_test.go
================================================
package builders_test

import (
	"errors"
	"testing"
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/builders"
	"github.com/stretchr/testify/require"
)

func testNextYield(t *testing.T, sleep bool) {
	r := require.New(t)

	rows := [][]any{{"first", "row"}, {"second"}, {"third"}, {"fourth"}, {"fifth"}, {"and", "last", "row"}}

	next, hasNext := builders.NextYield(func(yield func(...any)) error {
		for i, row := range rows {
			if sleep && (i == 2 || i == 4) {
				time.Sleep(500 * time.Millisecond)
			}
			yield(row...)
		}

		return nil
	})

	i := 0
	for hasNext() {
		row, err := next()

		r.NoError(err)

		r.NotEqual(0, len(row))

		r.Equal(row, core.Row(rows[i]))

		i++
	}

	r.Equal(i, len(rows))
}

func TestNextYield_Success(t *testing.T) {
	// test with random sleeping
	testNextYield(t, true)

	for i := 0; i < 1000; i++ {
		testNextYield(t, false)
	}
}

func TestNextYield_Error(t *testing.T) {
	expectedError := errors.New("expected error")

	next, hasNext := builders.NextYield(func(yield func(...any)) error {
		return expectedError
	})

	for hasNext() {
		_, err := next()
		require.Error(t, err, expectedError.Error())
	}
}

func TestNextYield_NoRows(t *testing.T) {
	_, hasNext := builders.NextYield(func(yield func(...any)) error {
		time.Sleep(1 * time.Second)
		return nil
	})

	require.Equal(t, false, hasNext())
}

func TestNextYield_SingleRow(t *testing.T) {
	r := require.New(t)
	next, hasNext := builders.NextYield(func(yield func(...any)) error {
		yield(1)
		time.Sleep(1 * time.Second)
		return nil
	})

	r.True(hasNext())

	row, err := next()
	r.NoError(err)
	r.Equal(1, len(row))
	r.Equal(1, row[0])

	r.Equal(false, hasNext())
}



================================================
FILE: dbee/core/builders/result.go
================================================
package builders

import (
	"errors"
	"sync"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

var _ core.ResultStream = (*ResultStream)(nil)

type ResultStream struct {
	next    func() (core.Row, error)
	hasNext func() bool
	closes  []func()
	meta    *core.Meta
	header  core.Header
	once    sync.Once
}

func (r *ResultStream) AddCallback(fn func()) {
	r.closes = append(r.closes, fn)
}

func (r *ResultStream) Meta() *core.Meta {
	return r.meta
}

func (r *ResultStream) Header() core.Header {
	return r.header
}

func (r *ResultStream) HasNext() bool {
	return r.hasNext()
}

func (r *ResultStream) Next() (core.Row, error) {
	rows, err := r.next()
	if err != nil || rows == nil {
		r.Close()
		return nil, err
	}
	return rows, nil
}

func (r *ResultStream) Close() {
	r.once.Do(func() {
		for _, fn := range r.closes {
			if fn != nil {
				fn()
			}
		}
	})

	r.hasNext = func() bool {
		return false
	}
}

// ResultStreamBuilder builds the rows
type ResultStreamBuilder struct {
	next    func() (core.Row, error)
	hasNext func() bool
	header  core.Header
	closes  []func()
	meta    *core.Meta
}

func NewResultStreamBuilder() *ResultStreamBuilder {
	return &ResultStreamBuilder{
		next:    func() (core.Row, error) { return nil, errors.New("no next row") },
		hasNext: func() bool { return false },
		header:  core.Header{},
		meta:    &core.Meta{},
	}
}

func (b *ResultStreamBuilder) WithNextFunc(fn func() (core.Row, error), has func() bool) *ResultStreamBuilder {
	b.next = fn
	b.hasNext = has
	return b
}

func (b *ResultStreamBuilder) WithHeader(header core.Header) *ResultStreamBuilder {
	b.header = header
	return b
}

func (b *ResultStreamBuilder) WithCloseFunc(fn func()) *ResultStreamBuilder {
	b.closes = append(b.closes, fn)
	return b
}

func (b *ResultStreamBuilder) WithMeta(meta *core.Meta) *ResultStreamBuilder {
	b.meta = meta
	return b
}

func (b *ResultStreamBuilder) Build() *ResultStream {
	return &ResultStream{
		next:    b.next,
		hasNext: b.hasNext,
		header:  b.header,
		closes:  b.closes,
		meta:    b.meta,
		once:    sync.Once{},
	}
}



================================================
FILE: dbee/core/format/csv.go
================================================
package format

import (
	"bytes"
	"encoding/csv"
	"fmt"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

var _ core.Formatter = (*CSV)(nil)

type CSV struct{}

func NewCSV() *CSV {
	return &CSV{}
}

func (cf *CSV) parseSchemaFul(header core.Header, rows []core.Row) [][]string {
	data := [][]string{
		header,
	}
	for _, row := range rows {
		var csvRow []string
		for _, rec := range row {
			csvRow = append(csvRow, fmt.Sprint(rec))
		}
		data = append(data, csvRow)
	}

	return data
}

func (cf *CSV) Format(header core.Header, rows []core.Row, _ *core.FormatterOptions) ([]byte, error) {
	// parse as if schema is defined regardles of schema presence in the result
	data := cf.parseSchemaFul(header, rows)

	b := new(bytes.Buffer)
	w := csv.NewWriter(b)

	err := w.WriteAll(data)
	if err != nil {
		return nil, fmt.Errorf("w.WriteAll: %w", err)
	}

	return b.Bytes(), nil
}



================================================
FILE: dbee/core/format/json.go
================================================
package format

import (
	"encoding/json"
	"fmt"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

var _ core.Formatter = (*JSON)(nil)

type JSON struct{}

func NewJSON() *JSON {
	return &JSON{}
}

func (jf *JSON) parseSchemaFul(header core.Header, rows []core.Row) []map[string]any {
	var data []map[string]any

	for _, row := range rows {
		record := make(map[string]any, len(row))
		for i, val := range row {
			var h string
			if i < len(header) {
				h = header[i]
			} else {
				h = fmt.Sprintf("<unknown-field-%d>", i)
			}
			record[h] = val
		}
		data = append(data, record)
	}

	return data
}

func (jf *JSON) parseSchemaLess(header core.Header, rows []core.Row) []any {
	var data []any

	for _, row := range rows {
		if len(row) == 1 {
			data = append(data, row[0])
		} else if len(row) > 1 {
			data = append(data, row)
		}
	}
	return data
}

func (jf *JSON) Format(header core.Header, rows []core.Row, opts *core.FormatterOptions) ([]byte, error) {
	var data any
	switch opts.SchemaType {
	case core.SchemaLess:
		data = jf.parseSchemaLess(header, rows)
	case core.SchemaFul:
		fallthrough
	default:
		data = jf.parseSchemaFul(header, rows)
	}

	out, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("json.MarshalIndent: %w", err)
	}

	return out, nil
}



================================================
FILE: dbee/core/mock/adapter.go
================================================
package mock

import (
	"context"
	"fmt"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

var _ core.Driver = (*driver)(nil)

type driver struct {
	data   []core.Row
	config *adapterConfig
}

func (d *driver) Query(ctx context.Context, query string) (core.ResultStream, error) {
	eff, ok := d.config.querySideEffects[query]
	if ok {
		err := eff(ctx)
		if err != nil {
			return nil, fmt.Errorf("side effect error: %w", err)
		}
	}

	return NewResultStream(d.data, d.config.resultStreamOptions...), nil
}

func (d *driver) Structure() ([]*core.Structure, error) {
	var structure []*core.Structure

	for table := range d.config.tableColumns {
		structure = append(structure, &core.Structure{
			Name: table,
			Type: core.StructureTypeTable,
		})
	}

	return structure, nil
}

func (d *driver) Columns(opts *core.TableOptions) ([]*core.Column, error) {
	columns, ok := d.config.tableColumns[opts.Table]
	if !ok {
		return nil, fmt.Errorf("unknown table: %s", opts.Table)
	}

	return columns, nil
}

func (d *driver) Close() {}

var _ core.Adapter = (*Adapter)(nil)

type Adapter struct {
	data   []core.Row
	config *adapterConfig
}

func NewAdapter(data []core.Row, opts ...AdapterOption) *Adapter {
	config := &adapterConfig{
		querySideEffects: make(map[string]func(context.Context) error),
		tableHelpers:     make(map[string]string),
		tableColumns:     make(map[string][]*core.Column),

		resultStreamOptions: []ResultStreamOption{},
	}
	for _, opt := range opts {
		opt(config)
	}

	return &Adapter{
		data:   data,
		config: config,
	}
}

func (a *Adapter) Connect(_ string) (core.Driver, error) {
	return &driver{
		data:   a.data,
		config: a.config,
	}, nil
}

func (a *Adapter) GetHelpers(opts *core.TableOptions) map[string]string {
	return a.config.tableHelpers
}



================================================
FILE: dbee/core/mock/adapter_options.go
================================================
package mock

import (
	"context"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

type adapterConfig struct {
	querySideEffects map[string]func(context.Context) error
	tableHelpers     map[string]string
	tableColumns     map[string][]*core.Column

	resultStreamOptions []ResultStreamOption
}

type AdapterOption func(*adapterConfig)

func AdapterWithQuerySideEffect(query string, sideEffect func(context.Context) error) AdapterOption {
	return func(c *adapterConfig) {
		_, ok := c.querySideEffects[query]
		if ok {
			panic("side effect already registered for query: " + query)
		}

		c.querySideEffects[query] = sideEffect
	}
}

func AdapterWithTableHelper(name string, query string) AdapterOption {
	return func(c *adapterConfig) {
		_, ok := c.tableHelpers[name]
		if ok {
			panic("query already registered for table helper: " + name)
		}

		c.tableHelpers[name] = query
	}
}

func AdapterWithTableDefinition(table string, columns []*core.Column) AdapterOption {
	return func(c *adapterConfig) {
		_, ok := c.tableColumns[table]
		if ok {
			panic("columns already registered for table: " + table)
		}

		c.tableColumns[table] = columns
	}
}

func AdapterWithResultStreamOpts(opts ...ResultStreamOption) AdapterOption {
	return func(c *adapterConfig) {
		c.resultStreamOptions = append(c.resultStreamOptions, opts...)
	}
}



================================================
FILE: dbee/core/mock/result.go
================================================
package mock

import (
	"errors"
	"fmt"
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

func newNext(rows []core.Row) (func() (core.Row, error), func() bool) {
	index := 0

	hasNext := func() bool {
		return index < len(rows)
	}

	// iterator functions
	next := func() (core.Row, error) {
		if !hasNext() {
			return nil, errors.New("no next row")
		}

		row := rows[index]
		index++
		return row, nil
	}

	return next, hasNext
}

type ResultStream struct {
	next    func() (core.Row, error)
	hasNext func() bool
	config  *resultStreamConfig
}

func makeDefaultHeader(rows []core.Row) core.Header {
	var header core.Header
	if len(rows) > 0 {
		for i := range rows[0] {
			header = append(header, fmt.Sprintf("header_%d", i))
		}
	}
	return header
}

// NewResultStream returns a mocked result stream with provided rows.
// It creates a header that matches the number of columns in the first row
// in form of: <header_0>, <header_1>, etc.
func NewResultStream(rows []core.Row, opts ...ResultStreamOption) *ResultStream {
	config := &resultStreamConfig{
		nextSleep: 0,
		meta:      &core.Meta{},
		header:    makeDefaultHeader(rows),
	}
	for _, opt := range opts {
		opt(config)
	}

	next, hasNext := newNext(rows)

	return &ResultStream{
		next:    next,
		hasNext: hasNext,
		config:  config,
	}
}

func (rs *ResultStream) Meta() *core.Meta {
	return rs.config.meta
}

func (rs *ResultStream) Header() core.Header {
	return rs.config.header
}

func (rs *ResultStream) Next() (core.Row, error) {
	time.Sleep(rs.config.nextSleep)
	return rs.next()
}

func (rs *ResultStream) HasNext() bool {
	return rs.hasNext()
}

func (rs *ResultStream) Close() {}

// NewRows returns a slice of rows in form of:
//
//	{ <index>(int), "row_<index>"(string) }
//
// where the first index is "from" and the last one is one less than "to".
func NewRows(from, to int) []core.Row {
	var rows []core.Row

	for i := from; i < to; i++ {
		rows = append(rows, core.Row{i, fmt.Sprintf("row_%d", i)})
	}
	return rows
}



================================================
FILE: dbee/core/mock/result_options.go
================================================
package mock

import (
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

type resultStreamConfig struct {
	nextSleep time.Duration
	meta      *core.Meta
	header    core.Header
}

type ResultStreamOption func(*resultStreamConfig)

func ResultStreamWithNextSleep(s time.Duration) ResultStreamOption {
	return func(c *resultStreamConfig) {
		c.nextSleep = s
	}
}

func ResultStreamWithMeta(meta *core.Meta) ResultStreamOption {
	return func(c *resultStreamConfig) {
		c.meta = meta
	}
}

func ResultStreamWithHeader(header core.Header) ResultStreamOption {
	return func(c *resultStreamConfig) {
		c.header = header
	}
}



================================================
FILE: dbee/handler/call_log.go
================================================
package handler

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

func (h *Handler) storeCallLog() error {
	store := make(map[core.ConnectionID][]*core.Call)

	for connID := range h.lookupConnection {
		calls, err := h.ConnectionGetCalls(connID)
		if err != nil || len(calls) < 1 {
			continue
		}
		store[connID] = calls
	}

	b, err := json.MarshalIndent(store, "", "  ")
	if err != nil {
		return fmt.Errorf("json.MarshalIndent: %w", err)
	}

	file, err := os.Create(callLogFileName)
	if err != nil {
		return fmt.Errorf("os.Create: %s", err)
	}
	defer file.Close()

	_, err = file.Write(b)
	if err != nil {
		return fmt.Errorf("file.Write: %w", err)
	}

	return nil
}

func (h *Handler) restoreCallLog() error {
	file, err := os.Open(callLogFileName)
	if err != nil {
		return fmt.Errorf("os.Open: %w", err)
	}
	defer file.Close()

	decoder := json.NewDecoder(file)

	var store map[core.ConnectionID][]*core.Call

	err = decoder.Decode(&store)
	if err != nil {
		return fmt.Errorf("decoder.Decode: %w", err)
	}

	for connID, calls := range store {
		callIDs := make([]core.CallID, len(calls))

		// fill call lookup
		for i, c := range calls {
			h.lookupCall[c.GetID()] = c
			callIDs[i] = c.GetID()
		}

		// add to conn-call lookup
		h.lookupConnectionCall[connID] = append(h.lookupConnectionCall[connID], callIDs...)
	}

	return nil
}



================================================
FILE: dbee/handler/event_bus.go
================================================
package handler

import (
	"fmt"

	"github.com/neovim/go-client/nvim"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/plugin"
)

type eventBus struct {
	vim *nvim.Nvim
	log *plugin.Logger
}

func (eb *eventBus) callLua(event string, data string) {
	err := eb.vim.ExecLua(fmt.Sprintf(`require("dbee.handler.__events").trigger(%q, %s)`, event, data), nil)
	if err != nil {
		eb.log.Infof("eb.vim.ExecLua: %s", err)
	}
}

func (eb *eventBus) CallStateChanged(call *core.Call) {
	errMsg := "nil"
	if err := call.Err(); err != nil {
		errMsg = fmt.Sprintf("[[%s]]", err.Error())
	}

	data := fmt.Sprintf(`{
		call = {
			id = %q,
			query = %q,
			state = %q,
			time_taken_us = %d,
			timestamp_us = %d,
			error = %s,
		},
	}`, call.GetID(),
		call.GetQuery(),
		call.GetState().String(),
		call.GetTimeTaken().Microseconds(),
		call.GetTimestamp().UnixMicro(),
		errMsg)

	eb.callLua("call_state_changed", data)
}

func (eb *eventBus) CurrentConnectionChanged(id core.ConnectionID) {
	data := fmt.Sprintf(`{
		conn_id = %q,
	}`, id)

	eb.callLua("current_connection_changed", data)
}

// DatabaseSelected is called when the selected database of a connection is changed.
// Sends the new database name along with affected connection ID to the lua event handler.
func (eb *eventBus) DatabaseSelected(id core.ConnectionID, dbname string) {
	data := fmt.Sprintf(`{
		conn_id = %q,
		database_name = %q,
	}`, id, dbname)

	eb.callLua("database_selected", data)
}



================================================
FILE: dbee/handler/format_table.go
================================================
package handler

import (
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/jedib0t/go-pretty/v6/text"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

var _ core.Formatter = (*Table)(nil)

type Table struct{}

func newTable() *Table {
	return &Table{}
}

func (tf *Table) Format(header core.Header, rows []core.Row, opts *core.FormatterOptions) ([]byte, error) {
	tableHeaders := []any{""}
	for _, k := range header {
		tableHeaders = append(tableHeaders, k)
	}
	index := opts.ChunkStart

	var tableRows []table.Row
	for _, row := range rows {
		indexedRow := append([]any{index + 1}, row...)
		tableRows = append(tableRows, table.Row(indexedRow))
		index += 1
	}

	t := table.NewWriter()
	t.AppendHeader(table.Row(tableHeaders))
	t.AppendRows(tableRows)
	t.AppendSeparator()
	t.SetStyle(table.StyleLight)
	t.Style().Format = table.FormatOptions{
		Footer: text.FormatDefault,
		Header: text.FormatDefault,
		Row:    text.FormatDefault,
	}
	t.Style().Options.DrawBorder = false
	t.SuppressTrailingSpaces()
	render := t.Render()

	return []byte(render), nil
}



================================================
FILE: dbee/handler/handler.go
================================================
package handler

import (
	"errors"
	"fmt"
	"io"
	"os"
	"slices"
	"strconv"
	"time"

	"github.com/neovim/go-client/nvim"

	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/kndndrj/nvim-dbee/dbee/core/format"
	"github.com/kndndrj/nvim-dbee/dbee/plugin"
)

const callLogFileName = "/tmp/dbee-calllog.json"

type Handler struct {
	vim    *nvim.Nvim
	log    *plugin.Logger
	events *eventBus

	lookupConnection     map[core.ConnectionID]*core.Connection
	lookupCall           map[core.CallID]*core.Call
	lookupConnectionCall map[core.ConnectionID][]core.CallID

	currentConnectionID core.ConnectionID
}

func New(vim *nvim.Nvim, logger *plugin.Logger) *Handler {
	h := &Handler{
		vim: vim,
		log: logger,
		events: &eventBus{
			vim: vim,
			log: logger,
		},

		lookupConnection:     make(map[core.ConnectionID]*core.Connection),
		lookupCall:           make(map[core.CallID]*core.Call),
		lookupConnectionCall: make(map[core.ConnectionID][]core.CallID),
	}

	// restore the call log concurrently
	go func() {
		err := h.restoreCallLog()
		if err != nil {
			h.log.Infof("h.restoreCallLog: %s", err)
		}
	}()

	return h
}

func (h *Handler) Close() {
	// wait for unfinished calls
	for _, c := range h.lookupCall {
		select {
		case <-c.Done():
		case <-time.After(10 * time.Second):
		}
	}

	// store call log
	err := h.storeCallLog()
	if err != nil {
		h.log.Infof("h.storeCallLog: %s", err)
	}

	// close connections
	for _, c := range h.lookupConnection {
		c.Close()
	}
}

func (h *Handler) CreateConnection(params *core.ConnectionParams) (core.ConnectionID, error) {
	c, err := adapters.NewConnection(params)
	if err != nil {
		return "", fmt.Errorf("adapters.NewConnection: %w", err)
	}

	_, ok := h.lookupConnection[c.GetID()]
	if ok {
		c.Close()
		return "", fmt.Errorf("connection with id already exists. id: %s", params.ID)
	}

	h.lookupConnection[c.GetID()] = c
	_ = h.SetCurrentConnection(c.GetID())

	return c.GetID(), nil
}

func (h *Handler) DeleteConnection(id core.ConnectionID) error {
	c, ok := h.lookupConnection[id]
	if !ok {
		return fmt.Errorf("connection with id does not exist. id: %s", id)
	}
	c.Close()
	delete(h.lookupConnection, id)
	return nil
}

func (h *Handler) GetConnections(ids []core.ConnectionID) []*core.Connection {
	var conns []*core.Connection

	for _, c := range h.lookupConnection {
		if len(ids) > 0 && !slices.Contains(ids, c.GetID()) {
			continue
		}
		conns = append(conns, c)
	}

	return conns
}

func (h *Handler) AddHelpers(typ string, helpers map[string]string) error {
	return new(adapters.Mux).AddHelpers(typ, helpers)
}

func (h *Handler) ConnectionGetHelpers(connID core.ConnectionID, opts *core.TableOptions) (map[string]string, error) {
	c, ok := h.lookupConnection[connID]
	if !ok {
		return nil, fmt.Errorf("unknown connection with id: %q", connID)
	}

	return c.GetHelpers(opts), nil
}

func (h *Handler) GetCurrentConnection() (*core.Connection, error) {
	c, ok := h.lookupConnection[h.currentConnectionID]
	if !ok {
		return nil, fmt.Errorf("current connection has not been set yet")
	}
	return c, nil
}

func (h *Handler) SetCurrentConnection(connID core.ConnectionID) error {
	_, ok := h.lookupConnection[connID]
	if !ok {
		return fmt.Errorf("unknown connection with id: %q", connID)
	}

	if h.currentConnectionID == connID {
		return nil
	}

	// update connection and trigger event
	h.currentConnectionID = connID
	h.events.CurrentConnectionChanged(connID)

	return nil
}

func (h *Handler) ConnectionExecute(connID core.ConnectionID, query string) (*core.Call, error) {
	c, ok := h.lookupConnection[connID]
	if !ok {
		return nil, fmt.Errorf("unknown connection with id: %q", connID)
	}

	call := c.Execute(query, func(state core.CallState, c *core.Call) {
		if err := c.Err(); err != nil {
			h.log.Errorf("cl.Err: %s", err)
		}

		h.events.CallStateChanged(c)
	})

	id := call.GetID()

	// add to lookup
	h.lookupCall[id] = call
	h.lookupConnectionCall[connID] = append(h.lookupConnectionCall[connID], id)

	// update current call and conn
	_ = h.SetCurrentConnection(connID)

	return call, nil
}

func (h *Handler) ConnectionGetCalls(connID core.ConnectionID) ([]*core.Call, error) {
	_, ok := h.lookupConnection[connID]
	if !ok {
		return nil, fmt.Errorf("unknown connection with id: %q", connID)
	}

	var calls []*core.Call
	callIDs, ok := h.lookupConnectionCall[connID]
	if !ok {
		return calls, nil
	}
	for _, cID := range callIDs {
		c, ok := h.lookupCall[cID]
		if !ok {
			continue
		}
		calls = append(calls, c)
	}

	return calls, nil
}

func (h *Handler) ConnectionGetParams(connID core.ConnectionID) (*core.ConnectionParams, error) {
	c, ok := h.lookupConnection[connID]
	if !ok {
		return nil, fmt.Errorf("unknown connection with id: %q", connID)
	}

	return c.GetParams(), nil
}

func (h *Handler) ConnectionGetStructure(connID core.ConnectionID) ([]*core.Structure, error) {
	c, ok := h.lookupConnection[connID]
	if !ok {
		return nil, fmt.Errorf("unknown connection with id: %q", connID)
	}

	layout, err := c.GetStructure()
	if err != nil {
		return nil, fmt.Errorf("c.GetStructure: %w", err)
	}

	return layout, nil
}

func (h *Handler) ConnectionGetColumns(connID core.ConnectionID, opts *core.TableOptions) ([]*core.Column, error) {
	c, ok := h.lookupConnection[connID]
	if !ok {
		return nil, fmt.Errorf("unknown connection with id: %q", connID)
	}

	columns, err := c.GetColumns(opts)
	if err != nil {
		return nil, err
	}

	return columns, nil
}

func (h *Handler) ConnectionListDatabases(connID core.ConnectionID) (current string, available []string, err error) {
	c, ok := h.lookupConnection[connID]
	if !ok {
		return "", nil, fmt.Errorf("unknown connection with id: %q", connID)
	}

	currentDB, availableDBs, err := c.ListDatabases()
	if err != nil {
		if errors.Is(err, core.ErrDatabaseSwitchingNotSupported) {
			return "", []string{}, nil
		}
		return "", nil, fmt.Errorf("c.ListDatabases: %w", err)
	}

	return currentDB, availableDBs, nil
}

func (h *Handler) ConnectionSelectDatabase(connID core.ConnectionID, database string) error {
	c, ok := h.lookupConnection[connID]
	if !ok {
		return fmt.Errorf("unknown connection with id: %q", connID)
	}

	err := c.SelectDatabase(database)
	if err != nil {
		return fmt.Errorf("c.SelectDatabase: %w", err)
	}
	h.events.DatabaseSelected(connID, database)

	return nil
}

func (h *Handler) CallCancel(callID core.CallID) error {
	call, ok := h.lookupCall[callID]
	if !ok {
		return fmt.Errorf("unknown call with id: %q", callID)
	}

	call.Cancel()
	return nil
}

func (h *Handler) CallDisplayResult(callID core.CallID, buffer nvim.Buffer, from, to int) (int, error) {
	call, ok := h.lookupCall[callID]
	if !ok {
		return 0, fmt.Errorf("unknown call with id: %q", callID)
	}

	res, err := call.GetResult()
	if err != nil {
		return 0, fmt.Errorf("call.GetResult: %w", err)
	}

	text, err := res.Format(newTable(), from, to)
	if err != nil {
		return 0, fmt.Errorf("res.Format: %w", err)
	}

	_, err = newBuffer(h.vim, buffer).Write(text)
	if err != nil {
		return 0, fmt.Errorf("buffer.Write: %w", err)
	}

	return res.Len(), nil
}

func (h *Handler) CallStoreResult(callID core.CallID, fmat, out string, from, to int, arg ...any) error {
	stat, ok := h.lookupCall[callID]
	if !ok {
		return fmt.Errorf("unknown call with id: %q", callID)
	}

	var formatter core.Formatter
	switch fmat {
	case "json":
		formatter = format.NewJSON()
	case "csv":
		formatter = format.NewCSV()
	case "table":
		formatter = newTable()
	default:
		return fmt.Errorf("store output: %q is not supported", fmat)
	}

	writer, cleanup, err := h.getStoreWriter(out, arg...)
	if err != nil {
		return err
	}
	defer cleanup()

	res, err := stat.GetResult()
	if err != nil {
		return fmt.Errorf("stat.GetResult: %w", err)
	}

	text, err := res.Format(formatter, from, to)
	if err != nil {
		return fmt.Errorf("res.Format: %w", err)
	}

	_, err = writer.Write(text)
	if err != nil {
		return fmt.Errorf("buffer.Write: %w", err)
	}

	return nil
}

func (h *Handler) getStoreWriter(output string, arg ...any) (writer io.Writer, cleanup func(), err error) {
	switch output {
	case "file":
		if len(arg) < 1 || arg[0] == "" {
			return nil, func() {}, fmt.Errorf("no output path provided")
		}

		path, ok := arg[0].(string)
		if !ok {
			return nil, func() {}, fmt.Errorf("invalid output path: not a string")
		}

		writer, err := os.Create(path)
		if err != nil {
			return nil, func() {}, err
		}

		return writer, func() { writer.Close() }, nil
	case "buffer":
		if len(arg) < 1 {
			return nil, func() {}, fmt.Errorf("no buffer provided")
		}

		buf, ok := arg[0].(int64)
		if ok {
			return newBuffer(h.vim, nvim.Buffer(buf)), func() {}, nil
		}

		bufstr, ok := arg[0].(string)
		if ok {
			buf, err := strconv.ParseInt(bufstr, 10, 64)
			return newBuffer(h.vim, nvim.Buffer(buf)), func() {}, err
		}

		return nil, func() {}, fmt.Errorf("buffer number not an int")

	case "yank":
		register := ""
		if len(arg) > 0 {
			register, _ = arg[0].(string)
		}

		return newYankRegister(h.vim, register), func() {}, nil
	}

	return nil, func() {}, fmt.Errorf("store output: %q is not supported", output)
}



================================================
FILE: dbee/handler/marshal.go
================================================
package handler

import (
	"github.com/neovim/go-client/msgpack"

	"github.com/kndndrj/nvim-dbee/dbee/core"
)

// callWrap is a wrapper around core.Call with msgpack marshaling capabilities
type callWrap struct {
	call *core.Call
}

func WrapCall(call *core.Call) *callWrap {
	return &callWrap{
		call: call,
	}
}

func WrapCalls(calls []*core.Call) []*callWrap {
	wraps := make([]*callWrap, len(calls))

	for i := range calls {
		wraps[i] = &callWrap{
			call: calls[i],
		}
	}

	return wraps
}

func (cw *callWrap) MarshalMsgPack(enc *msgpack.Encoder) error {
	if cw.call == nil {
		return enc.Encode(nil)
	}

	errMsg := ""
	if err := cw.call.Err(); err != nil {
		errMsg = err.Error()
	}

	return enc.Encode(&struct {
		ID        string `msgpack:"id"`
		Query     string `msgpack:"query"`
		State     string `msgpack:"state"`
		TimeTaken int64  `msgpack:"time_taken_us"`
		Timestamp int64  `msgpack:"timestamp_us"`
		Error     string `msgpack:"error,omitempty"`
	}{
		ID:        string(cw.call.GetID()),
		Query:     cw.call.GetQuery(),
		State:     cw.call.GetState().String(),
		TimeTaken: cw.call.GetTimeTaken().Microseconds(),
		Timestamp: cw.call.GetTimestamp().UnixMicro(),
		Error:     errMsg,
	})
}

// connectionWrap is wrapper around core.Connection with msgpack marshaling capabilities
type connectionWrap struct {
	connection *core.Connection
}

func WrapConnection(connection *core.Connection) *connectionWrap {
	return &connectionWrap{
		connection: connection,
	}
}

func WrapConnections(connections []*core.Connection) []*connectionWrap {
	wraps := make([]*connectionWrap, len(connections))

	for i := range connections {
		wraps[i] = &connectionWrap{
			connection: connections[i],
		}
	}

	return wraps
}

func (cw *connectionWrap) MarshalMsgPack(enc *msgpack.Encoder) error {
	if cw.connection == nil {
		return enc.Encode(nil)
	}
	return enc.Encode(&struct {
		ID   string `msgpack:"id"`
		Name string `msgpack:"name"`
		Type string `msgpack:"type"`
		URL  string `msgpack:"url"`
	}{
		ID:   string(cw.connection.GetID()),
		Name: cw.connection.GetName(),
		Type: cw.connection.GetType(),
		URL:  cw.connection.GetURL(),
	})
}

// connectionParamsWrap is wrapper around core.ConnectionParams with msgpack marshaling capabilities
type connectionParamsWrap struct {
	params *core.ConnectionParams
}

func WrapConnectionParams(params *core.ConnectionParams) *connectionParamsWrap {
	return &connectionParamsWrap{
		params: params,
	}
}

func (cw *connectionParamsWrap) MarshalMsgPack(enc *msgpack.Encoder) error {
	if cw.params == nil {
		return enc.Encode(nil)
	}
	return enc.Encode(&struct {
		ID   string `msgpack:"id"`
		Name string `msgpack:"name"`
		Type string `msgpack:"type"`
		URL  string `msgpack:"url"`
	}{
		ID:   string(cw.params.ID),
		Name: cw.params.Name,
		Type: cw.params.Type,
		URL:  cw.params.URL,
	})
}

// structureWrap is a wrapper around core.Structure with msgpack marshaling capabilities
type structureWrap struct {
	structure *core.Structure
}

func WrapStructure(structure *core.Structure) *structureWrap {
	return &structureWrap{
		structure: structure,
	}
}

func WrapStructures(structures []*core.Structure) []*structureWrap {
	wraps := make([]*structureWrap, len(structures))

	for i := range structures {
		wraps[i] = &structureWrap{
			structure: structures[i],
		}
	}

	return wraps
}

func (cw *structureWrap) MarshalMsgPack(enc *msgpack.Encoder) error {
	if cw.structure == nil {
		return enc.Encode(nil)
	}
	return enc.Encode(&struct {
		Name     string           `msgpack:"name"`
		Schema   string           `msgpack:"schema"`
		Type     string           `msgpack:"type"`
		Children []*structureWrap `msgpack:"children"`
	}{
		Name:     cw.structure.Name,
		Schema:   cw.structure.Schema,
		Type:     cw.structure.Type.String(),
		Children: WrapStructures(cw.structure.Children),
	})
}

// columnWrap is a wrapper around core.Column with msgpack marshaling capabilities
type columnWrap struct {
	column *core.Column
}

func WrapColumn(column *core.Column) *columnWrap {
	return &columnWrap{
		column: column,
	}
}

func WrapColumns(columns []*core.Column) []*columnWrap {
	wraps := make([]*columnWrap, len(columns))

	for i := range columns {
		wraps[i] = &columnWrap{
			column: columns[i],
		}
	}

	return wraps
}

func (cw *columnWrap) MarshalMsgPack(enc *msgpack.Encoder) error {
	if cw.column == nil {
		return enc.Encode(nil)
	}
	return enc.Encode(&struct {
		Name string `msgpack:"name"`
		Type string `msgpack:"type"`
	}{
		Name: cw.column.Name,
		Type: cw.column.Type,
	})
}



================================================
FILE: dbee/handler/output_buffer.go
================================================
package handler

import (
	"bufio"
	"bytes"

	"github.com/neovim/go-client/nvim"
)

func newBuffer(vim *nvim.Nvim, buffer nvim.Buffer) *Buffer {
	return &Buffer{
		buffer: buffer,
		vim:    vim,
	}
}

type Buffer struct {
	buffer nvim.Buffer
	vim    *nvim.Nvim
}

func (b *Buffer) Write(p []byte) (int, error) {
	scanner := bufio.NewScanner(bytes.NewReader(p))
	var lines [][]byte
	for scanner.Scan() {
		lines = append(lines, []byte(scanner.Text()))
	}

	const modifiableOptionName = "modifiable"

	// is the buffer modifiable
	isModifiable := false
	err := b.vim.BufferOption(b.buffer, modifiableOptionName, &isModifiable)
	if err != nil {
		return 0, err
	}

	if !isModifiable {
		err = b.vim.SetBufferOption(b.buffer, modifiableOptionName, true)
		if err != nil {
			return 0, err
		}
	}

	err = b.vim.SetBufferLines(b.buffer, 0, -1, true, lines)
	if err != nil {
		return 0, err
	}

	if !isModifiable {
		err = b.vim.SetBufferOption(b.buffer, modifiableOptionName, false)
		if err != nil {
			return 0, err
		}
	}

	return len(p), nil
}



================================================
FILE: dbee/handler/output_yank.go
================================================
package handler

import (
	"fmt"

	"github.com/neovim/go-client/nvim"
)

type YankRegister struct {
	vim      *nvim.Nvim
	register string
}

func newYankRegister(vim *nvim.Nvim, register string) *YankRegister {
	return &YankRegister{
		vim:      vim,
		register: register,
	}
}

func (yr *YankRegister) Write(p []byte) (int, error) {
	err := yr.vim.Call("setreg", nil, yr.register, string(p))
	if err != nil {
		return 0, fmt.Errorf("r.vim.Call: %w", err)
	}

	return len(p), err
}



================================================
FILE: dbee/plugin/logger.go
================================================
package plugin

import (
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/neovim/go-client/nvim"
)

type Logger struct {
	vim          *nvim.Nvim
	logger       *log.Logger
	file         *os.File
	triedFileSet bool
}

func NewLogger(vim *nvim.Nvim) *Logger {
	return &Logger{
		vim:          vim,
		logger:       log.New(os.Stdout, "", log.Ldate|log.Ltime),
		triedFileSet: false,
	}
}

func (l *Logger) setupFile() error {
	var fileName string
	err := l.vim.Call("stdpath", &fileName, "cache")
	if err != nil {
		return err
	}
	fileName = filepath.Join(fileName, "dbee", "dbee.log")

	file, err := os.OpenFile(fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o666)
	if err != nil {
		return err
	}

	l.logger.SetOutput(file)
	return nil
}

func (l *Logger) Close() {
	if l.file != nil {
		l.file.Close()
	}
}

func (l *Logger) log(level, message string) {
	if l.file == nil && !l.triedFileSet {
		err := l.setupFile()
		if err != nil {
			l.logger.Print(err)
		}
		l.triedFileSet = true
	}

	l.logger.Printf("[%s]: %s", level, message)
}

func (l *Logger) Infof(format string, args ...any) {
	l.log("info", fmt.Sprintf(format, args...))
}

func (l *Logger) Errorf(format string, args ...any) {
	l.log("error", fmt.Sprintf(format, args...))
}



================================================
FILE: dbee/plugin/manifest.go
================================================
package plugin

const manifestLuaFile = `-- This file is automatically generated using "dbee -manifest <file>"
-- DO NOT EDIT!

return function()
  -- Register host
  vim.fn["remote#host#Register"]("{{ .Host }}", "x", function()
    return vim.fn.jobstart({ "{{ .Executable }}" }, {
      rpc = true,
      detach = true,
      on_stderr = function(_, data, _)
        for _, line in ipairs(data) do
          print(line)
        end
      end,
    })
  end)

  -- Manifest
  vim.fn["remote#host#RegisterPlugin"]("{{ .Host }}", "0", {
  {{- range .Specs }}
    { type = "{{ .Type }}", name = "{{ .Name }}", sync = {{ .Sync }}, opts = vim.empty_dict() },
  {{- end }}
  })
end
`



================================================
FILE: dbee/plugin/plugin.go
================================================
package plugin

import (
	"fmt"
	"os"
	"reflect"
	"sort"
	"text/template"

	"github.com/neovim/go-client/nvim"
)

// Plugin represents a remote plugin.
type Plugin struct {
	vim         *nvim.Nvim
	pluginSpecs []*pluginSpec
	log         *Logger
}

// New returns an intialized plugin.
func New(v *nvim.Nvim, l *Logger) *Plugin {
	return &Plugin{
		vim: v,
		log: l,
	}
}

type pluginSpec struct {
	sm   string
	Type string            `msgpack:"type"`
	Name string            `msgpack:"name"`
	Sync bool              `msgpack:"sync"`
	Opts map[string]string `msgpack:"opts"`
}

func isSync(f interface{}) bool {
	t := reflect.TypeOf(f)

	return t.Kind() == reflect.Func && t.NumOut() > 0
}

func (p *Plugin) handle(fn interface{}, spec *pluginSpec) {
	p.pluginSpecs = append(p.pluginSpecs, spec)
	if p.vim == nil {
		return
	}

	if err := p.vim.RegisterHandler(spec.sm, fn); err != nil {
		panic(err)
	}
}

func (p *Plugin) logReturn(method string, values []reflect.Value) {
	// check for return errors
	for _, val := range values {
		v := val.Interface()

		if v, ok := v.(error); ok && v != nil {
			p.log.Infof("method %q failed with error: %s", method, v)
			return
		}
	}

	p.log.Infof("method %q returned successfully", method)
}

// RegisterEndpoint registers fn as a handler for a vim function. The function
// signature for fn is one of
//
//	func([v *nvim.Nvim,] args {arrayType}) ({resultType}, error)
//	func([v *nvim.Nvim,] args {arrayType}) error
//
// where {arrayType} is a type that can be unmarshaled from a MessagePack
// array and {resultType} is the type of function result.
func (p *Plugin) RegisterEndpoint(name string, fn any) {
	v := reflect.ValueOf(fn)

	newFn := reflect.MakeFunc(v.Type(), func(args []reflect.Value) (results []reflect.Value) {
		p.log.Infof("calling method %q", name)
		ret := v.Call(args)
		p.logReturn(name, ret)
		return ret
	})

	p.handle(newFn.Interface(), &pluginSpec{
		sm:   `0:function:` + name,
		Type: `function`,
		Name: name,
		Sync: isSync(fn),
		Opts: make(map[string]string),
	})
}

func (p *Plugin) Manifest(host, executable, writeTo string) error {
	// Sort for consistent order on output.
	sort.Slice(p.pluginSpecs, func(i, j int) bool {
		return p.pluginSpecs[i].sm < p.pluginSpecs[j].sm
	})

	tmpl, err := template.New("manifest_template").Parse(manifestLuaFile)
	if err != nil {
		return fmt.Errorf("template.New.Parse: %w", err)
	}

	outputFile, err := os.Create(writeTo)
	if err != nil {
		return fmt.Errorf("os.Create: %w", err)
	}

	err = tmpl.Execute(outputFile, struct {
		Host       string
		Executable string
		Specs      []*pluginSpec
	}{
		Host:       host,
		Executable: executable,
		Specs:      p.pluginSpecs,
	})
	if err != nil {
		return fmt.Errorf("tmpl.Execute: %w", err)
	}

	return nil
}



================================================
FILE: dbee/tests/README.md
================================================
# Raison d'être

This directory contains tests for the dbee project that are not unit tests.

## Tests:

Try to follow the uber-go style guide for tests, which can be found
[here](https://github.com/uber-go/guide/blob/master/style.md#test-tables).

### How to run tests

[Go testcontainers](https://golang.testcontainers.org/modules) is used to run integration tests
against the [adapters](./../adapters) package.

Testcontainers support two types of provider, docker and podman. If `podman` executable is detected,
then it will be used as the default provider. Otherwise `docker` will be used. When using podman,
the ryuk container (repear) need to be run as privileged, set env variable
`TESTCONTAINERS_RYUK_CONTAINER_PRIVILEGED=true` before running any tests to enable it.

### How to run tests

Tests are run via (from dbee pwd):

```bash
go test ./tests/... -v
```

If you want to disable cache add the `-count=1` flag:

```bash
go test ./tests/... -v -count=1
```

To run a specific adapter, you can use the `-run` flag:

```bash
go test ./tests/... -v -run Test<AdapterName>
```

For example, to run the `postgres` adapter tests:

```bash
go test ./tests/... -v -run TestPostgres
```

### Add new tests

Take a look at the `postgres` adapter example on how to add a new integration. Otherwise, the
default documentation from [testcontainers](https://golang.testcontainers.org/modules) is always
very helpful to look at.



================================================
FILE: dbee/tests/integration/bigquery_integration_test.go
================================================
package integration

import (
	"context"
	"log"
	"testing"
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
	tc "github.com/testcontainers/testcontainers-go"
)

// BigQueryTestSuite is the test suite for the bigquery adapter.
type BigQueryTestSuite struct {
	tsuite.Suite
	ctr *th.BigQueryContainer
	ctx context.Context
	d   *core.Connection
}

// TestBigQueryTestSuite is the entrypoint for go test.
func TestBigQueryTestSuite(t *testing.T) {
	tsuite.Run(t, new(BigQueryTestSuite))
}

func (suite *BigQueryTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	ctr, err := th.NewBigQueryContainer(suite.ctx, &core.ConnectionParams{
		ID:   "test-bigquery",
		Name: "test-bigquery",
	})
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr = ctr
	suite.d = ctr.Driver
}

func (suite *BigQueryTestSuite) TeardownSuite() {
	tc.CleanupContainer(suite.T(), suite.ctr)
}

func (suite *BigQueryTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "Syntax error"

	call := suite.d.Execute("invalid sql", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *BigQueryTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "SELECT 1")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

func (suite *BigQueryTestSuite) TestShouldReturnOneRow() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "createdAt", "name"}
	wantRows := []core.Row{
		{
			int64(1),
			"john",
			time.Date(2025, 1, 21, 0, 0, 0, 0, time.UTC),
		},
	}

	query := "SELECT id, name, createdAt FROM `dataset_test.table_test` WHERE id = 1"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *BigQueryTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantRows := []core.Row{
		{
			int64(1),
			"john",
			time.Date(2025, 1, 21, 0, 0, 0, 0, time.UTC),
		},
		{
			int64(2),
			"bob",
			time.Date(2025, 1, 21, 0, 1, 0, 0, time.UTC),
		},
	}
	query := "SELECT id, name, createdAt FROM `dataset_test.table_test` WHERE id IN (1, 2)"

	gotRows, _, _, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *BigQueryTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	wantSomeSchema, wantSomeTable := "dataset_test", "table_test"

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.Contains(t, gotSchemas, wantSomeSchema)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)
}

func (suite *BigQueryTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "id", Type: "INTEGER"},
		{Name: "name", Type: "STRING"},
		{Name: "createdAt", Type: "TIMESTAMP"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "table_test",
		Schema:          "dataset_test",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}



================================================
FILE: dbee/tests/integration/clickhouse_integration_test.go
================================================
package integration

import (
	"context"
	"log"
	"testing"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
	tc "github.com/testcontainers/testcontainers-go"
)

// ClickHouseTestSuite is the test suite for the clickhouse adapter.
type ClickHouseTestSuite struct {
	tsuite.Suite
	ctr *th.ClickHouseContainer
	ctx context.Context
	d   *core.Connection
}

func TestClickHouseTestSuite(t *testing.T) {
	tsuite.Run(t, new(ClickHouseTestSuite))
}

func (suite *ClickHouseTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	ctr, err := th.NewClickHouseContainer(suite.ctx, &core.ConnectionParams{
		ID:   "test-clickhouse",
		Name: "test-clickhouse",
	})
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr = ctr
	suite.d = ctr.Driver
}

func (suite *ClickHouseTestSuite) TeardownSuite() {
	tc.CleanupContainer(suite.T(), suite.ctr)
}

func (suite *ClickHouseTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "Syntax error"

	call := suite.d.Execute("invalid sql", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *ClickHouseTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "SELECT 1")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

func (suite *ClickHouseTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username"}
	wantRows := []core.Row{
		{uint32(1), "john_doe"},
		{uint32(2), "jane_smith"},
	}

	query := "SELECT id, username FROM test.test_view"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *ClickHouseTestSuite) TestShouldReturnOneRow() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username"}
	wantRows := []core.Row{{uint32(1), "john_doe"}}

	query := "SELECT id, username FROM test.test_table WHERE id = 1"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *ClickHouseTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	var (
		wantSomeSchema = "test"
		wantSomeTable  = "test_table"
		wantSomeView   = "test_view"
	)

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.Contains(t, gotSchemas, wantSomeSchema)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)

	gotViews := th.GetModels(t, structure, core.StructureTypeView)
	assert.Contains(t, gotViews, wantSomeView)
}

func (suite *ClickHouseTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "id", Type: "UInt32"},
		{Name: "username", Type: "String"},
		{Name: "email", Type: "String"},
		{Name: "created_at", Type: "DateTime"},
		{Name: "is_active", Type: "UInt8"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "test_table",
		Schema:          "test",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}

func (suite *ClickHouseTestSuite) TestShouldSwitchDatabase() {
	t := suite.T()

	want := "dev"
	wantAllExceptCurrent := []string{"default", "information_schema", "system", "test"}

	err := suite.d.SelectDatabase(want)
	assert.NoError(t, err)

	got, gotAllExceptCurrent, err := suite.d.ListDatabases()
	assert.NoError(t, err)
	assert.Equal(t, want, got)
	assert.Equal(t, wantAllExceptCurrent, gotAllExceptCurrent)
}

func (suite *ClickHouseTestSuite) TestShouldFailSwitchDatabase() {
	t := suite.T()

	want := "doesnt exist"
	// create a new connection to avoid changing the default database
	driver, err := suite.ctr.NewDriver(&core.ConnectionParams{
		ID:   "test-clickhouse-2",
		Name: "test-clickhouse-2",
	})
	assert.NoError(t, err)

	err = driver.SelectDatabase(want)
	assert.Error(t, err)
	assert.ErrorContains(t, err, want)
}



================================================
FILE: dbee/tests/integration/docs.go
================================================
// Package integration provides integration tests for dbee adapters.
package integration



================================================
FILE: dbee/tests/integration/duckdb_integration_test.go
================================================
package integration

import (
	"context"
	"log"
	"testing"
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
)

// DuckDBTestSuite defines the integration test suite for DuckDB.
type DuckDBTestSuite struct {
	tsuite.Suite
	ctr *th.DuckDBContainer
	ctx context.Context
	d   *core.Connection
}

// TestDuckDBTestSuite runs the test suite.
func TestDuckDBTestSuite(t *testing.T) {
	tsuite.Run(t, new(DuckDBTestSuite))
}

// SetupSuite initializes an in-memory DuckDB instance.
func (suite *DuckDBTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	tempDir := suite.T().TempDir()

	params := &core.ConnectionParams{ID: "test-duckdb", Name: "test-duckdb"}
	ctr, err := th.NewDuckDBContainer(suite.ctx, params, tempDir)
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr = ctr
	suite.d = ctr.Driver // easier access to driver
}

// TeardownSuite cleans up after tests.
func (suite *DuckDBTestSuite) TeardownSuite() {
	suite.d.Close()
}

// TestShouldErrorInvalidQuery ensures invalid SQL fails.
func (suite *DuckDBTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "syntax error"

	call := suite.d.Execute("INVALID SQL", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *DuckDBTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "SELECT COUNT(*) FROM range(5000000000)")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

// TestShouldReturnRows validates data retrieval for all rows.
func (suite *DuckDBTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{
		"id", "username", "email", "created_at",
	}
	wantRows := []core.Row{
		{
			int32(1),
			"john_doe",
			"john@example.com",
			time.Date(2023, 1, 1, 10, 0, 0, 0, time.UTC),
		},
		{
			int32(2),
			"jane_smith",
			"jane@example.com",
			time.Date(2023, 1, 2, 11, 30, 0, 0, time.UTC),
		},
		{
			int32(3),
			"bob_wilson",
			"bob@example.com",
			time.Date(2023, 1, 3, 9, 15, 0, 0, time.UTC),
		},
	}

	query := "SELECT id, username, email, created_at FROM test_container.test_schema.test_table"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

// TestShouldReturnSingleRows validates data retrieval for one rows.
func (suite *DuckDBTestSuite) TestShouldReturnSingleRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username", "email"}
	wantRows := []core.Row{
		{int32(2), "jane_smith", "jane@example.com"},
	}

	query := "SELECT * FROM test_container.test_schema.test_view;"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *DuckDBTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	// no need to check entire structure, just some key elements
	var (
		wantSomeSchema = "test_schema"
		wantSomeTable  = "test_table"
		wantSomeView   = "test_view"
	)

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.Contains(t, gotSchemas, wantSomeSchema)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)

	gotViews := th.GetModels(t, structure, core.StructureTypeView)
	assert.Contains(t, gotViews, wantSomeView)
}

// TestShouldReturnColumns validates column metadata.
func (suite *DuckDBTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "id", Type: "INTEGER"},
		{Name: "username", Type: "VARCHAR"},
		{Name: "email", Type: "VARCHAR"},
		{Name: "created_at", Type: "TIMESTAMP"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "test_table",
		Schema:          "test_schema",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}

// TestListOnlyOneDatabase validates listing database only return a single database.
func (suite *DuckDBTestSuite) TestListOnlyOneDatabase() {
	t := suite.T()

	wantCurrent := "test_container"
	wantAvailable := []string{"not supported yet"}
	gotCurrent, gotAvailable, err := suite.d.ListDatabases()
	assert.NoError(t, err)
	assert.Equal(t, wantCurrent, gotCurrent)
	assert.Equal(t, wantAvailable, gotAvailable)
}

// TestShouldNoOperationSwitchDatabase validates selecting new database, which is a no-op.
func (suite *DuckDBTestSuite) TestShouldNoOperationSwitchDatabase() {
	t := suite.T()

	driver, err := suite.ctr.NewDriver(&core.ConnectionParams{
		ID:   "test-duckdb-2",
		Name: "test-duckdb-2",
	})
	assert.NoError(t, err)

	err = driver.SelectDatabase("no-op")
	assert.Nil(t, err)
}



================================================
FILE: dbee/tests/integration/mysql_integration_test.go
================================================
package integration

import (
	"context"
	"log"
	"testing"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
	tc "github.com/testcontainers/testcontainers-go"
)

// MySQLTestSuite is the test suite for the mysql adapter.
type MySQLTestSuite struct {
	tsuite.Suite
	ctr *th.MySQLContainer
	ctx context.Context
	d   *core.Connection
}

func TestMySQLTestSuite(t *testing.T) {
	tsuite.Run(t, new(MySQLTestSuite))
}

func (suite *MySQLTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	ctr, err := th.NewMySQLContainer(suite.ctx, &core.ConnectionParams{
		ID:   "test-mysql",
		Name: "test-mysql",
	})
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr = ctr
	suite.d = ctr.Driver // easier access to driver
}

func (suite *MySQLTestSuite) TeardownSuite() {
	tc.CleanupContainer(suite.T(), suite.ctr)
}

func (suite *MySQLTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "You have an error in your SQL syntax"

	call := suite.d.Execute("invalid sql", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *MySQLTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "SELECT 1")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

func (suite *MySQLTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username", "email"}
	wantRows := []core.Row{
		{"1", "john_doe", "john@example.com"},
		{"2", "jane_smith", "jane@example.com"},
		{"3", "bob_wilson", "bob@example.com"},
	}

	query := "SELECT * FROM test.test_table"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *MySQLTestSuite) TestShouldReturnSingleRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username", "email"}
	wantRows := []core.Row{
		{"2", "jane_smith", "jane@example.com"},
	}

	query := "SELECT * FROM test.test_view"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *MySQLTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	wantSchemas := []string{"information_schema", "mysql", "performance_schema", "sys", "test"}
	wantSomeTable := "test_table"

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.ElementsMatch(t, wantSchemas, gotSchemas)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)
}

func (suite *MySQLTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "id", Type: "int unsigned"},
		{Name: "username", Type: "varchar(255)"},
		{Name: "email", Type: "varchar(255)"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "test_table",
		Schema:          "test",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}



================================================
FILE: dbee/tests/integration/oracle_integration_test.go
================================================
package integration

import (
	"context"
	"log"
	"testing"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
	tc "github.com/testcontainers/testcontainers-go"
)

// OracleTestSuite is the test suite for the oracle adapter.
type OracleTestSuite struct {
	tsuite.Suite
	ctr *th.OracleContainer
	ctx context.Context
	d   *core.Connection
}

func TestOracleTestSuite(t *testing.T) {
	tsuite.Run(t, new(OracleTestSuite))
}

func (suite *OracleTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	ctr, err := th.NewOracleContainer(suite.ctx, &core.ConnectionParams{
		ID:   "test-oracle",
		Name: "test-oracle",
	})
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr = ctr
	suite.d = ctr.Driver
}

func (suite *OracleTestSuite) TeardownSuite() {
	tc.CleanupContainer(suite.T(), suite.ctr)
}

func (suite *OracleTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "ORA-00900: invalid SQL statement"

	call := suite.d.Execute("invalid sql", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *OracleTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "SELECT 1")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

func (suite *OracleTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"ID", "USERNAME"}
	wantRows := []core.Row{
		{"1", "john_doe"},
		{"2", "jane_smith"},
		{"3", "bob_wilson"},
	}

	query := "SELECT ID, USERNAME FROM test_table"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *OracleTestSuite) TestShouldReturnOneRow() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"ID", "USERNAME"}
	wantRows := []core.Row{{"2", "jane_smith"}}

	query := "SELECT ID, USERNAME FROM test_view"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *OracleTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	var (
		wantSomeSchema = "TESTER"
		wantSomeTable  = "TEST_TABLE"
		wantSomeView   = "TEST_VIEW"
	)

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.Contains(t, gotSchemas, wantSomeSchema)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)

	gotViews := th.GetModels(t, structure, core.StructureTypeView)
	assert.Contains(t, gotViews, wantSomeView)
}

func (suite *OracleTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "ID", Type: "NUMBER"},
		{Name: "USERNAME", Type: "VARCHAR2"},
		{Name: "EMAIL", Type: "VARCHAR2"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "TEST_TABLE",
		Schema:          "TESTER",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}



================================================
FILE: dbee/tests/integration/postgres_integration_test.go
================================================
package integration

import (
	"context"
	"log"
	"testing"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
	tc "github.com/testcontainers/testcontainers-go"
)

// PostgresTestSuite is the test suite for the postgres adapter.
type PostgresTestSuite struct {
	tsuite.Suite // inherit from testify suite
	// ctr is the postgres testcontainer
	ctr *th.PostgresContainer
	ctx context.Context
	// d is the postgres adapter
	d *core.Connection
}

// TestPostgresTestSuite is the entrypoint for go test.
//
// testify/suite can't handle parallel tests, see
// https://github.com/stretchr/testify/issues/934
func TestPostgresTestSuite(t *testing.T) {
	tsuite.Run(t, new(PostgresTestSuite))
}

func (suite *PostgresTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	ctr, err := th.NewPostgresContainer(suite.ctx, &core.ConnectionParams{
		ID:   "test-postgres",
		Name: "test-postgres",
	})
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr = ctr
	suite.d = ctr.Driver // easier access to driver
}

func (suite *PostgresTestSuite) TeardownSuite() {
	tc.CleanupContainer(suite.T(), suite.ctr)
}

func (suite *PostgresTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "syntax error"

	call := suite.d.Execute("invalid sql", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *PostgresTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "SELECT pg_sleep(1)")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

func (suite *PostgresTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username", "email"}
	wantRows := []core.Row{
		{int64(1), "john_doe", "john@example.com"},
		{int64(2), "jane_smith", "jane@example.com"},
		{int64(3), "bob_wilson", "bob@example.com"},
	}

	query := "SELECT * FROM test.test_table;"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *PostgresTestSuite) TestShouldReturnSingleRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username", "email"}
	wantRows := []core.Row{
		{int64(2), "jane_smith", "jane@example.com"},
	}

	query := "SELECT * FROM test.test_view;"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *PostgresTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	// no need to check entire structure, just some key elements
	var (
		wantSomeSchema = "test"
		wantSomeTable  = "test_table"
		wantSomeView   = "test_view"
	)

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.Contains(t, gotSchemas, wantSomeSchema)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)

	gotViews := th.GetModels(t, structure, core.StructureTypeView)
	assert.Contains(t, gotViews, wantSomeView)
}

func (suite *PostgresTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "id", Type: "integer"},
		{Name: "username", Type: "character varying"},
		{Name: "email", Type: "character varying"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "test_table",
		Schema:          "test",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}

func (suite *PostgresTestSuite) TestShouldSwitchDatabase() {
	t := suite.T()

	want := "postgres" // default database always present
	wantAllExceptCurrent := []string{"dev"}

	err := suite.d.SelectDatabase(want)
	assert.NoError(t, err)

	got, gotAllExceptCurrent, err := suite.d.ListDatabases()
	assert.NoError(t, err)
	assert.Equal(t, want, got)
	assert.Equal(t, wantAllExceptCurrent, gotAllExceptCurrent)
}

func (suite *PostgresTestSuite) TestShouldFailSwitchDatabase() {
	t := suite.T()

	want := "doesnt exist"
	// create a new connection to avoid changing the default database
	driver, err := suite.ctr.NewDriver(&core.ConnectionParams{
		ID:   "test-postgres-2",
		Name: "test-postgres-2",
	})
	assert.NoError(t, err)

	err = driver.SelectDatabase(want)
	assert.Error(t, err)
	assert.ErrorContains(t, err, want)
}



================================================
FILE: dbee/tests/integration/redshift_integration_test.go
================================================
package integration

import (
	"context"
	"log"
	"testing"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
	tc "github.com/testcontainers/testcontainers-go"
)

// RedshiftTestSuite is the test suite for the redshift adapter.
type RedshiftTestSuite struct {
	tsuite.Suite
	ctr *th.PostgresContainer
	ctx context.Context
	d   *core.Connection
}

// TestRedshiftTestSuite is the entrypoint for go test.
func TestRedshiftTestSuite(t *testing.T) {
	tsuite.Run(t, new(RedshiftTestSuite))
}

func (suite *RedshiftTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	ctr, err := th.NewPostgresContainer(suite.ctx, &core.ConnectionParams{
		ID:   "test-redshift",
		Name: "test-redshift",
		Type: "redshift",
	})
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr = ctr
	suite.d = ctr.Driver
}

func (suite *RedshiftTestSuite) TeardownSuite() {
	tc.CleanupContainer(suite.T(), suite.ctr)
}

func (suite *RedshiftTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "syntax error"

	call := suite.d.Execute("invalid sql", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *RedshiftTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "SELECT 1")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

func (suite *RedshiftTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username", "email"}
	wantRows := []core.Row{
		{int64(1), "john_doe", "john@example.com"},
		{int64(2), "jane_smith", "jane@example.com"},
		{int64(3), "bob_wilson", "bob@example.com"},
	}

	query := "SELECT * FROM test.test_table;"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *RedshiftTestSuite) TestShouldReturnSingleRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username", "email"}
	wantRows := []core.Row{
		{int64(2), "jane_smith", "jane@example.com"},
	}

	query := "SELECT * FROM test.test_view;"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *RedshiftTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	// no need to check entire structure, just some key elements
	var (
		wantSomeSchema = "test"
		wantSomeTable  = "test_table"
		wantSomeView   = "test_view"
	)

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.Contains(t, gotSchemas, wantSomeSchema)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)

	gotViews := th.GetModels(t, structure, core.StructureTypeView)
	assert.Contains(t, gotViews, wantSomeView)
}

func (suite *RedshiftTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "id", Type: "integer"},
		{Name: "username", Type: "character varying"},
		{Name: "email", Type: "character varying"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "test_table",
		Schema:          "test",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}

func (suite *RedshiftTestSuite) TestShouldSwitchDatabase() {
	t := suite.T()

	want := "postgres" // default database always present
	wantAllExceptCurrent := []string{"dev"}

	err := suite.d.SelectDatabase(want)
	assert.NoError(t, err)

	got, gotAllExceptCurrent, err := suite.d.ListDatabases()
	assert.NoError(t, err)
	assert.Equal(t, want, got)
	assert.Equal(t, wantAllExceptCurrent, gotAllExceptCurrent)
}

func (suite *RedshiftTestSuite) TestShouldFailSwitchDatabase() {
	t := suite.T()

	want := "doesnt exist"
	// create a new connection to avoid changing the default database
	driver, err := suite.ctr.NewDriver(&core.ConnectionParams{
		ID:   "test-redshift-2",
		Name: "test-redshift-2",
		Type: "redshift",
	})
	assert.NoError(t, err)

	err = driver.SelectDatabase(want)
	assert.Error(t, err)
	assert.ErrorContains(t, err, want)
}



================================================
FILE: dbee/tests/integration/sqlite_integration_test.go
================================================
package integration

import (
	"context"
	"log"
	"testing"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
	tc "github.com/testcontainers/testcontainers-go"
)

// SQLiteTestSuite is the test suite for the sqlite adapter.
type SQLiteTestSuite struct {
	tsuite.Suite
	ctr *th.SQLiteContainer
	ctx context.Context
	d   *core.Connection
}

func TestSQLiteTestSuite(t *testing.T) {
	tsuite.Run(t, new(SQLiteTestSuite))
}

func (suite *SQLiteTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	tempDir := suite.T().TempDir()

	params := &core.ConnectionParams{ID: "test-sqlite", Name: "test-sqlite"}
	ctr, err := th.NewSQLiteContainer(suite.ctx, params, tempDir)
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr, suite.d = ctr, ctr.Driver
}

func (suite *SQLiteTestSuite) TeardownSuite() {
	tc.CleanupContainer(suite.T(), suite.ctr)
}

func (suite *SQLiteTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "syntax error"

	call := suite.d.Execute("invalid sql", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *SQLiteTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "SELECT 1")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

func (suite *SQLiteTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username"}
	wantRows := []core.Row{
		{int64(1), "john_doe"},
		{int64(2), "jane_smith"},
		{int64(3), "bob_wilson"},
	}

	query := "SELECT id, username FROM test_table"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *SQLiteTestSuite) TestShouldReturnOneRow() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"id", "username"}
	wantRows := []core.Row{{int64(2), "jane_smith"}}

	query := "SELECT id, username FROM test_view"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *SQLiteTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	var (
		wantSchema    = "sqlite_schema"
		wantSomeTable = "test_table"
		wantSomeView  = "test_view"
	)

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.Contains(t, gotSchemas, wantSchema)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)

	gotViews := th.GetModels(t, structure, core.StructureTypeView)
	assert.Contains(t, gotViews, wantSomeView)
}

func (suite *SQLiteTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "id", Type: "INTEGER"},
		{Name: "username", Type: "TEXT"},
		{Name: "email", Type: "TEXT"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "test_table",
		Schema:          "sqlite_schema",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}

func (suite *SQLiteTestSuite) TestShouldNoOperationSwitchDatabase() {
	t := suite.T()

	driver, err := suite.ctr.NewDriver(&core.ConnectionParams{
		ID:   "test-sqlite-2",
		Name: "test-sqlite-2",
	})
	assert.NoError(t, err)

	err = driver.SelectDatabase("no-op")
	assert.Nil(t, err)
}



================================================
FILE: dbee/tests/integration/sqlserver_integration_test.go
================================================
// NOTE(ms): required due to https://github.com/microsoft/mssql-docker/issues/895
//go:debug x509negativeserial=1

package integration

import (
	"context"
	"log"
	"testing"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	th "github.com/kndndrj/nvim-dbee/dbee/tests/testhelpers"
	"github.com/stretchr/testify/assert"
	tsuite "github.com/stretchr/testify/suite"
	tc "github.com/testcontainers/testcontainers-go"
)

// MSSQLServerTestSuite is the test suite for the MSSQLServer adapter.
type MSSQLServerTestSuite struct {
	tsuite.Suite
	ctr *th.MSSQLServerContainer
	ctx context.Context
	d   *core.Connection
}

// TestMSSQLServerTestSuite is the entrypoint for go test.
func TestMSSQLServerTestSuite(t *testing.T) {
	tsuite.Run(t, new(MSSQLServerTestSuite))
}

func (suite *MSSQLServerTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	ctr, err := th.NewSQLServerContainer(suite.ctx, &core.ConnectionParams{
		ID:   "test-mssql",
		Name: "test-mssql",
	})
	if err != nil {
		log.Fatal(err)
	}

	suite.ctr = ctr
	suite.d = ctr.Driver
}

func (suite *MSSQLServerTestSuite) TeardownSuite() {
	tc.CleanupContainer(suite.T(), suite.ctr)
}

func (suite *MSSQLServerTestSuite) TestShouldErrorInvalidQuery() {
	t := suite.T()

	want := "Invalid column name 'invalid'."

	call := suite.d.Execute("select invalid", func(cs core.CallState, c *core.Call) {
		if cs == core.CallStateExecutingFailed {
			assert.ErrorContains(t, c.Err(), want)
		}
	})
	assert.NotNil(t, call)
}

func (suite *MSSQLServerTestSuite) TestShouldCancelQuery() {
	t := suite.T()
	want := []core.CallState{core.CallStateExecuting, core.CallStateCanceled}

	_, got, err := th.GetResultWithCancel(t, suite.d, "select 1")
	assert.NoError(t, err)

	assert.Equal(t, want, got)
}

func (suite *MSSQLServerTestSuite) TestShouldReturnSingleRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"ID", "Name", "Email"}
	wantRows := []core.Row{{int64(2), "Bob", "bob@example.com"}}

	query := "SELECT * FROM test_schema.test_view"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *MSSQLServerTestSuite) TestShouldReturnManyRows() {
	t := suite.T()

	wantStates := []core.CallState{
		core.CallStateExecuting, core.CallStateRetrieving, core.CallStateArchived,
	}
	wantCols := []string{"ID", "Name", "Email"}
	wantRows := []core.Row{
		{int64(1), "Alice", "alice@example.com"},
		{int64(2), "Bob", "bob@example.com"},
	}

	query := "SELECT * FROM test_schema.test_table"

	gotRows, gotCols, gotStates, err := th.GetResult(t, suite.d, query)
	assert.NoError(t, err)

	assert.ElementsMatch(t, wantCols, gotCols)
	assert.ElementsMatch(t, wantStates, gotStates)
	assert.Equal(t, wantRows, gotRows)
}

func (suite *MSSQLServerTestSuite) TestShouldReturnStructure() {
	t := suite.T()

	// no need to check entire structure, just some key elements
	wantSomeSchemas, wantSomeTable, wantSomeView := "test_schema", "test_table", "test_view"

	structure, err := suite.d.GetStructure()
	assert.NoError(t, err)

	gotSchemas := th.GetSchemas(t, structure)
	assert.Contains(t, gotSchemas, wantSomeSchemas)

	gotTables := th.GetModels(t, structure, core.StructureTypeTable)
	assert.Contains(t, gotTables, wantSomeTable)

	gotViews := th.GetModels(t, structure, core.StructureTypeView)
	assert.Contains(t, gotViews, wantSomeView)
}

func (suite *MSSQLServerTestSuite) TestShouldReturnColumns() {
	t := suite.T()

	want := []*core.Column{
		{Name: "ID", Type: "int"},
		{Name: "Name", Type: "nvarchar"},
		{Name: "Email", Type: "nvarchar"},
	}

	got, err := suite.d.GetColumns(&core.TableOptions{
		Table:           "test_table",
		Schema:          "test_schema",
		Materialization: core.StructureTypeTable,
	})

	assert.NoError(t, err)
	assert.Equal(t, want, got)
}

func (suite *MSSQLServerTestSuite) TestShouldSwitchDatabase() {
	t := suite.T()

	want := "master" // default database always present
	wantAllExceptCurrent := []string{"dev", "model", "msdb", "tempdb"}

	err := suite.d.SelectDatabase(want)
	assert.NoError(t, err)

	got, gotAllExceptCurrent, err := suite.d.ListDatabases()
	assert.NoError(t, err)
	assert.Equal(t, want, got)
	assert.Equal(t, wantAllExceptCurrent, gotAllExceptCurrent)
}

func (suite *MSSQLServerTestSuite) TestShouldFailSwitchDatabase() {
	t := suite.T()

	want := "doesnt exist"
	driver, err := suite.ctr.NewDriver(&core.ConnectionParams{
		ID:   "test-mssql-2",
		Name: "test-mssql-2",
	})
	assert.NoError(t, err)

	err = driver.SelectDatabase(want)
	assert.Error(t, err)
	assert.ErrorContains(t, err, want)
}



================================================
FILE: dbee/tests/testdata/bigquery_seed.yaml
================================================
# https://golang.testcontainers.org/modules/gcloud/#data-yaml-seed-file
projects:
  - id: test-project
    datasets:
      - id: dataset_test
        tables:
          - id: table_test
            columns:
              - name: id
                type: INTEGER
              - name: name
                type: STRING
              - name: createdAt
                type: TIMESTAMP
            data:
              - id: 1
                name: john
                createdAt: "2025-01-21T00:00:00"
              - id: 2
                name: bob
                createdAt: "2025-01-21T00:01:00"
      - id: dataset_test.INFORMATION_SCHEMA
        tables:
          - id: COLUMNS
            columns:
              - name: TABLE_SCHEMA
                type: STRING
              - name: TABLE_NAME
                type: STRING
              - name: COLUMN_NAME
                type: STRING
              - name: DATA_TYPE
                type: STRING
            data:
              - TABLE_SCHEMA: dataset_test
                TABLE_NAME: table_test
                COLUMN_NAME: id
                DATA_TYPE: INTEGER
              - TABLE_SCHEMA: dataset_test
                TABLE_NAME: table_test
                COLUMN_NAME: name
                DATA_TYPE: STRING
              - TABLE_SCHEMA: dataset_test
                TABLE_NAME: table_test
                COLUMN_NAME: createdAt
                DATA_TYPE: TIMESTAMP

  - id: test-project2
    datasets: []



================================================
FILE: dbee/tests/testdata/clickhouse_seed.sql
================================================
CREATE DATABASE IF NOT EXISTS test;

CREATE TABLE IF NOT EXISTS test.test_table
(
    id UInt32,
    username String,
    email String,
    created_at DateTime,
    is_active UInt8
) ENGINE = MergeTree()
ORDER BY id
;

INSERT INTO test.test_table (id, username, email, created_at, is_active) VALUES
    (1, 'john_doe', 'john@example.com', '2023-01-01 10:00:00', 1),
    (2, 'jane_smith', 'jane@example.com', '2023-01-02 11:30:00', 1),
    (3, 'bob_wilson', 'bob@example.com', '2023-01-03 09:15:00', 0)
;

CREATE VIEW IF NOT EXISTS test.test_view AS
SELECT id, username, email, created_at
FROM test.test_table
WHERE is_active = 1
;




================================================
FILE: dbee/tests/testdata/duckdb_seed.sql
================================================
CREATE SCHEMA IF NOT EXISTS test_container.test_schema;

CREATE TABLE IF NOT EXISTS test_container.test_schema.test_table (
    id INTEGER PRIMARY KEY,
    username TEXT NOT NULL,
    email TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL
);

INSERT INTO test_container.test_schema.test_table (id, username, email, created_at) VALUES
    (1, 'john_doe', 'john@example.com', '2023-01-01 10:00:00'),
    (2, 'jane_smith', 'jane@example.com', '2023-01-02 11:30:00'),
    (3, 'bob_wilson', 'bob@example.com', '2023-01-03 09:15:00');

CREATE OR REPLACE VIEW test_container.test_schema.test_view AS
SELECT id, username, email
FROM test_container.test_schema.test_table
WHERE id = 2;



================================================
FILE: dbee/tests/testdata/mysql_seed.sql
================================================
CREATE SCHEMA IF NOT EXISTS test;

CREATE TABLE IF NOT EXISTS test.test_table (
    id INT UNSIGNED,
    username VARCHAR(255),
    email VARCHAR(255),
    PRIMARY KEY (id)
);

INSERT INTO test.test_table (id, username, email) VALUES
    (1, 'john_doe', 'john@example.com'),
    (2, 'jane_smith', 'jane@example.com'),
    (3, 'bob_wilson', 'bob@example.com');

CREATE OR REPLACE VIEW test.test_view AS
SELECT id, username, email
FROM test.test_table
WHERE id = 2;




================================================
FILE: dbee/tests/testdata/oracle_seed.sql
================================================
-- Connect as system to grant privileges
ALTER SESSION SET CONTAINER = FREEPDB1;
grant create session, create table, create view, unlimited tablespace
to tester
;

-- Must match the APP_USER env in testcontainer
ALTER SESSION SET CURRENT_SCHEMA = tester;

CREATE TABLE test_table (
    id NUMBER,
    username VARCHAR2(255),
    email VARCHAR2(255),
    CONSTRAINT test_table_pk PRIMARY KEY (id)
);

INSERT INTO test_table (id, username, email) VALUES
    (1, 'john_doe', 'john@example.com');
INSERT INTO test_table (id, username, email) VALUES
    (2, 'jane_smith', 'jane@example.com');
INSERT INTO test_table (id, username, email) VALUES
    (3, 'bob_wilson', 'bob@example.com');

CREATE OR REPLACE VIEW test_view AS
    SELECT id, username, email
    FROM test_table
    WHERE id = 2;

commit
;




================================================
FILE: dbee/tests/testdata/postgres_seed.sql
================================================

CREATE SCHEMA IF NOT EXISTS test;

CREATE TABLE IF NOT EXISTS test.test_table (
    id INT,
    username VARCHAR(255),
    email VARCHAR(255),
    PRIMARY KEY (id)
);

INSERT INTO test.test_table (id, username, email) VALUES
    (1, 'john_doe', 'john@example.com'),
    (2, 'jane_smith', 'jane@example.com'),
    (3, 'bob_wilson', 'bob@example.com');

CREATE OR REPLACE VIEW test.test_view AS (
    SELECT id, username, email
    FROM test.test_table
    WHERE id = 2
);




================================================
FILE: dbee/tests/testdata/sqlite_seed.sql
================================================
CREATE TABLE IF NOT EXISTS test_table (
    id INTEGER PRIMARY KEY,
    username TEXT,
    email TEXT
);

INSERT INTO test_table (id, username, email) VALUES
    (1, 'john_doe', 'john@example.com'),
    (2, 'jane_smith', 'jane@example.com'),
    (3, 'bob_wilson', 'bob@example.com');

CREATE VIEW IF NOT EXISTS test_view AS
    SELECT id, username, email
    FROM test_table
    WHERE id = 2;




================================================
FILE: dbee/tests/testdata/sqlserver_seed.sql
================================================
/*
Each transaction need to be separated by GO,
see more how t-sql works:
http://learn.microsoft.com/en-us/sql/linux/sql-server-linux-docker-container-deployment?view=sql-server-2017&pivots=cs1-bash
*/

CREATE SCHEMA test_schema;
GO

CREATE TABLE test_schema.test_table (
    ID INT PRIMARY KEY IDENTITY,
    Name NVARCHAR(100),
    Email NVARCHAR(100) UNIQUE
);
GO

INSERT INTO test_schema.test_table (Name, Email) VALUES
    ('Alice', 'alice@example.com'),
    ('Bob', 'bob@example.com')
;
GO

CREATE VIEW test_schema.test_view AS (
    SELECT * FROM test_schema.test_table WHERE Name = 'Bob'
);
GO

CREATE DATABASE dev;
GO



================================================
FILE: dbee/tests/testhelpers/bigquery.go
================================================
package testhelpers

import (
	"context"
	"fmt"

	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	tc "github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/gcloud"
	"github.com/testcontainers/testcontainers-go/wait"
)

// BigQueryContainer is a test container for BigQuery.
type BigQueryContainer struct {
	*gcloud.GCloudContainer
	ConnURL string
	Driver  *core.Connection
}

// NewBigQueryContainer creates a new BigQuery container with
// default adapter and connection. The params.URL is overwritten.
func NewBigQueryContainer(ctx context.Context, params *core.ConnectionParams) (*BigQueryContainer, error) {
	seedFile, err := GetTestDataFile("bigquery_seed.yaml")
	if err != nil {
		return nil, err
	}

	ctr, err := gcloud.RunBigQuery(
		ctx,
		"ghcr.io/goccy/bigquery-emulator:0.6.6",
		gcloud.WithProjectID("test-project"),
		gcloud.WithDataYAML(seedFile),
		tc.CustomizeRequest(tc.GenericContainerRequest{
			ProviderType: GetContainerProvider(),
			ContainerRequest: tc.ContainerRequest{
				ImagePlatform: "linux/amd64",
			},
		}),
		tc.WithWaitStrategy(wait.ForLog("[bigquery-emulator] gRPC")),
	)
	if err != nil {
		return nil, err
	}

	connURL := fmt.Sprintf("bigquery://%s?max-bytes-billed=1000&disable-query-cache=true&endpoint=%s", ctr.Settings.ProjectID, ctr.URI)
	if params.Type == "" {
		params.Type = "bigquery"
	}

	if params.URL == "" {
		params.URL = connURL
	}

	driver, err := adapters.NewConnection(params)
	if err != nil {
		return nil, err
	}

	return &BigQueryContainer{
		GCloudContainer: ctr,
		ConnURL:         connURL,
		Driver:          driver,
	}, nil
}

// NewDriver helper function to create a new driver with the connection URL.
func (p *BigQueryContainer) NewDriver(params *core.ConnectionParams) (*core.Connection, error) {
	if params.URL == "" {
		params.URL = p.ConnURL
	}
	if params.Type == "" {
		params.Type = "bigquery"
	}
	return adapters.NewConnection(params)
}



================================================
FILE: dbee/tests/testhelpers/clickhouse.go
================================================
package testhelpers

import (
	"context"

	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	tc "github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/clickhouse"
)

type ClickHouseContainer struct {
	*clickhouse.ClickHouseContainer
	ConnURL string
	Driver  *core.Connection
}

// NewClickHouseContainer creates a new clickhouse container with
// default adapter and connection. The params.URL is overwritten.
func NewClickHouseContainer(ctx context.Context, params *core.ConnectionParams) (*ClickHouseContainer, error) {
	seedFile, err := GetTestDataFile("clickhouse_seed.sql")
	if err != nil {
		return nil, err
	}

	ctr, err := clickhouse.Run(
		ctx,
		"clickhouse/clickhouse-server:25.1-alpine",
		tc.CustomizeRequest(tc.GenericContainerRequest{
			ProviderType: GetContainerProvider(),
		}),
		clickhouse.WithUsername("admin"),
		clickhouse.WithPassword(""),
		clickhouse.WithDatabase("dev"),
		clickhouse.WithInitScripts(seedFile.Name()),
	)
	if err != nil {
		return nil, err
	}

	connURL, err := ctr.ConnectionString(ctx)
	if err != nil {
		return nil, err
	}

	if params.Type == "" {
		params.Type = "clickhouse"
	}

	if params.URL == "" {
		params.URL = connURL
	}

	driver, err := adapters.NewConnection(params)
	if err != nil {
		return nil, err
	}

	return &ClickHouseContainer{
		ClickHouseContainer: ctr,
		ConnURL:             connURL,
		Driver:              driver,
	}, nil
}

// NewDriver helper function to create a new driver with the connection URL.
func (p *ClickHouseContainer) NewDriver(params *core.ConnectionParams) (*core.Connection, error) {
	if params.URL == "" {
		params.URL = p.ConnURL
	}
	if params.Type == "" {
		params.Type = "clickhouse"
	}

	return adapters.NewConnection(params)
}



================================================
FILE: dbee/tests/testhelpers/duckdb.go
================================================
package testhelpers

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/docker/docker/api/types/container"
	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	tc "github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
)

// DuckDBContainer represents an in-memory DuckDB instance.
type DuckDBContainer struct {
	tc.Container
	ConnURL string
	Driver  *core.Connection
	TempDir string
}

// NewDuckDBContainer creates a new duckdb container with
// default adapter and connection. The params.URL is overwritten.
// It uses a temporary directory (usually the test suite tempDir) to store the db file.
// The tmpDir is then mounted to the container and all the dependencies are installed
// in the container file, while still being able to connect to the db file in the host.
func NewDuckDBContainer(ctx context.Context, params *core.ConnectionParams, tmpDir string) (*DuckDBContainer, error) {
	seedFile, err := GetTestDataFile("duckdb_seed.sql")
	if err != nil {
		return nil, err
	}

	dbName, containerDBPath := "test_container.db", "/container/db"
	entrypointCmd := []string{
		"apt-get update",
		"apt-get install -y curl",
		"curl https://install.duckdb.org | sh",
		"export PATH='/root/.duckdb/cli/latest':$PATH",
		fmt.Sprintf("duckdb %s/%s < %s", containerDBPath, dbName, seedFile.Name()),
		"echo 'ready'",
		"tail -f /dev/null", // hack to keep the container running indefinitely
	}

	req := tc.ContainerRequest{
		Image: "debian:12.10-slim",
		Files: []tc.ContainerFile{
			{
				Reader:            seedFile,
				ContainerFilePath: seedFile.Name(),
				FileMode:          0o755,
			},
		},
		HostConfigModifier: func(hc *container.HostConfig) {
			hc.Binds = append(hc.Binds, fmt.Sprintf("%s:%s", tmpDir, containerDBPath))
		},
		Cmd:        []string{"sh", "-c", strings.Join(entrypointCmd, " && ")},
		WaitingFor: wait.ForLog("ready").WithStartupTimeout(60 * time.Second),
	}

	ctr, err := tc.GenericContainer(ctx, tc.GenericContainerRequest{
		ContainerRequest: req,
		ProviderType:     GetContainerProvider(),
		Started:          true,
	})
	if err != nil {
		return nil, err
	}

	if params.Type == "" {
		params.Type = "duckdb"
	}
	connURL := filepath.Join(tmpDir, dbName)
	if params.URL == "" {
		params.URL = connURL
	}

	driver, err := adapters.NewConnection(params)
	if err != nil {
		return nil, err
	}

	return &DuckDBContainer{
		Container: ctr,
		ConnURL:   connURL,
		Driver:    driver,
		TempDir:   tmpDir,
	}, nil
}

// NewDriver helper function to create a new driver with the connection URL.
func (d *DuckDBContainer) NewDriver(params *core.ConnectionParams) (*core.Connection, error) {
	if params.Type == "" {
		params.Type = "duckdb"
	}
	if params.URL != "" {
		params.URL = d.ConnURL
	}

	return adapters.NewConnection(params)
}



================================================
FILE: dbee/tests/testhelpers/helper.go
================================================
// Package testhelpers provides helpers for integration tests.
package testhelpers

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"testing"
	"time"

	"github.com/kndndrj/nvim-dbee/dbee/core"
	"github.com/stretchr/testify/require"
	"github.com/testcontainers/testcontainers-go"
)

const (
	// eventBufferTime is a padding to let events come through (e.g. archived)
	eventBufferTime = 100 * time.Millisecond
	// eventTimeout is the maximum time to wait for an event to come through
	eventTimeout = 10 * time.Second
)

// errTimeOut is an error for when an event did not finish within the expected time.
var errTimeOut = fmt.Errorf("event did not finish within %v", eventTimeout)

// GetContainerProvider returns the container provider type to use for the tests.
// If we detect podman is available, we use it, otherwise we use docker.
func GetContainerProvider() testcontainers.ProviderType {
	if _, err := exec.LookPath("podman"); err == nil {
		fmt.Println("Podman detected. Remember to set TESTCONTAINERS_RYUK_CONTAINER_PRIVILEGED=true;")
		return testcontainers.ProviderPodman
	}
	return testcontainers.ProviderDocker
}

// GetResult is a helper function for calling the Execute method on a driver
// and waiting for the result to be available.
func GetResult(t *testing.T, d *core.Connection, query string) ([]core.Row, core.Header, []core.CallState, error) {
	t.Helper()

	var result *core.Result
	outStates := make([]core.CallState, 0)
	outRows := make([]core.Row, 0)

	call := d.Execute(query, func(state core.CallState, c *core.Call) {
		outStates = append(outStates, state)

		var err error
		if state == core.CallStateArchived || state == core.CallStateRetrieving {
			result, err = c.GetResult()
			require.NoError(t, err, "failed getting result with %s, err: %s", state, c.Err())
			outRows, err = result.Rows(0, result.Len())
			require.NoError(t, err, "failed getting rows with %s, err: %s", state, c.Err())
		}
	})

	select {
	case <-call.Done():
		time.Sleep(eventBufferTime)
		require.NotNil(t, result, call.Err())
		return outRows, result.Header(), outStates, nil

	case <-time.After(eventTimeout):
		return nil, nil, nil, errTimeOut
	}
}

// GetResultWithCancel is a helper function for calling the Execute method on a driver
// and canceling the call after the first state is received.
func GetResultWithCancel(t *testing.T, d *core.Connection, query string) (*core.Result, []core.CallState, error) {
	t.Helper()

	var (
		outResult *core.Result
		outErr    error
	)
	outStates := make([]core.CallState, 0)

	call := d.Execute(query, func(cs core.CallState, c *core.Call) {
		outStates = append(outStates, cs)
		c.Cancel()
	})

	select {
	case <-call.Done():
		time.Sleep(eventBufferTime)
		return outResult, outStates, outErr
	case <-time.After(eventTimeout):
		return nil, nil, errTimeOut
	}
}

// GetSchemas returns a list of schema names from the given structure.
func GetSchemas(t *testing.T, structure []*core.Structure) []string {
	t.Helper()

	schemas := make([]string, 0)
	for _, s := range structure {
		if s.Name == s.Schema {
			schemas = append(schemas, s.Name)
			continue
		}
	}
	return schemas
}

// GetModels returns a list of model names (views, table, etc) from the given structure.
func GetModels(t *testing.T, structure []*core.Structure, modelType core.StructureType) []string {
	t.Helper()

	out := make([]string, 0)
	for _, s := range structure {
		for _, c := range s.Children {
			if c.Type == modelType {
				out = append(out, c.Name)
				continue
			}
		}
	}
	return out
}

// GetTestDataPath returns the path to the testdata directory.
func GetTestDataPath() (string, error) {
	_, currentFile, _, ok := runtime.Caller(0)
	if !ok {
		return "", fmt.Errorf("failed to get current file path")
	}

	return filepath.Join(filepath.Dir(currentFile), "../testdata"), nil
}

// GetTestDataFile returns a file from the testdata directory.
func GetTestDataFile(filename string) (*os.File, error) {
	testDataPath, err := GetTestDataPath()
	if err != nil {
		return nil, err
	}

	path := filepath.Join(testDataPath, filename)
	return os.Open(path)
}



================================================
FILE: dbee/tests/testhelpers/mysql.go
================================================
package testhelpers

import (
	"context"

	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	tc "github.com/testcontainers/testcontainers-go"
	tcmysql "github.com/testcontainers/testcontainers-go/modules/mysql"
)

type MySQLContainer struct {
	*tcmysql.MySQLContainer
	ConnURL string
	Driver  *core.Connection
}

// NewMySQLContainer creates a new MySQL container with
// default adapter and connection. The params.URL is overwritten.
func NewMySQLContainer(ctx context.Context, params *core.ConnectionParams) (*MySQLContainer, error) {
	seedFile, err := GetTestDataFile("mysql_seed.sql")
	if err != nil {
		return nil, err
	}

	ctr, err := tcmysql.Run(
		ctx,
		"mysql:9.2.0",
		tc.CustomizeRequest(tc.GenericContainerRequest{
			ProviderType: GetContainerProvider(),
		}),
		tcmysql.WithDatabase("dev"),
		tcmysql.WithPassword("password"),
		tcmysql.WithUsername("root"),
		tcmysql.WithScripts(seedFile.Name()),
	)
	if err != nil {
		return nil, err
	}

	connURL, err := ctr.ConnectionString(ctx, "tls=skip-verify")
	if err != nil {
		return nil, err
	}

	if params.Type == "" {
		params.Type = "mysql"
	}

	if params.URL == "" {
		params.URL = connURL
	}

	driver, err := adapters.NewConnection(params)
	if err != nil {
		return nil, err
	}

	return &MySQLContainer{
		MySQLContainer: ctr,
		ConnURL:        connURL,
		Driver:         driver,
	}, nil
}

// NewDriver helper function to create a new driver with the connection URL.
func (p *MySQLContainer) NewDriver(params *core.ConnectionParams) (*core.Connection, error) {
	if params.URL == "" {
		params.URL = p.ConnURL
	}
	if params.Type == "" {
		params.Type = "mysql"
	}

	return adapters.NewConnection(params)
}



================================================
FILE: dbee/tests/testhelpers/oracle.go
================================================
package testhelpers

import (
	"context"
	"fmt"
	"time"

	"github.com/docker/docker/api/types/container"
	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	tc "github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
)

type OracleContainer struct {
	tc.Container
	ConnURL string
	Driver  *core.Connection
}

// NewOracleContainer creates a new oracle container with
// default adapter and connection. The params.URL is overwritten.
func NewOracleContainer(ctx context.Context, params *core.ConnectionParams) (*OracleContainer, error) {
	const (
		password      = "password"
		appUser       = "tester"
		port          = "1521/tcp"
		memoryLimitGB = 3 * 1024 * 1024 * 1024
	)

	seedFile, err := GetTestDataFile("oracle_seed.sql")
	if err != nil {
		return nil, err
	}

	req := tc.ContainerRequest{
		Image:        "gvenzl/oracle-free:23.6-slim-faststart",
		ExposedPorts: []string{port},
		Env: map[string]string{
			"ORACLE_PASSWORD":   password,
			"APP_USER":          appUser,
			"APP_USER_PASSWORD": password,
		},
		WaitingFor: wait.ForLog("DATABASE IS READY TO USE!").WithStartupTimeout(5 * time.Minute),
		Resources:  container.Resources{Memory: memoryLimitGB},
		Files: []tc.ContainerFile{
			{
				Reader:            seedFile,
				ContainerFilePath: "/docker-entrypoint-initdb.d/" + seedFile.Name(),
				FileMode:          0o755,
			},
		},
	}

	ctr, err := tc.GenericContainer(ctx, tc.GenericContainerRequest{
		ContainerRequest: req,
		ProviderType:     GetContainerProvider(),
		Started:          true,
	})
	if err != nil {
		return nil, err
	}

	host, err := ctr.Host(ctx)
	if err != nil {
		return nil, err
	}

	mPort, err := ctr.MappedPort(ctx, port)
	if err != nil {
		return nil, err
	}

	connURL := fmt.Sprintf("oracle://%s:%s@%s:%d/FREEPDB1", appUser, password, host, mPort.Int())
	if params.Type == "" {
		params.Type = "oracle"
	}

	if params.URL == "" {
		params.URL = connURL
	}

	driver, err := adapters.NewConnection(params)
	if err != nil {
		return nil, err
	}

	return &OracleContainer{ConnURL: connURL, Driver: driver}, nil
}

// NewDriver helper function to create a new driver with the connection URL.
func (p *OracleContainer) NewDriver(params *core.ConnectionParams) (*core.Connection, error) {
	if params.URL == "" {
		params.URL = p.ConnURL
	}
	if params.Type == "" {
		params.Type = "oracle"
	}

	return adapters.NewConnection(params)
}



================================================
FILE: dbee/tests/testhelpers/postgres.go
================================================
package testhelpers

import (
	"context"

	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	tc "github.com/testcontainers/testcontainers-go"
	tcpsql "github.com/testcontainers/testcontainers-go/modules/postgres"
)

type PostgresContainer struct {
	*tcpsql.PostgresContainer
	ConnURL string
	Driver  *core.Connection
}

// NewPostgresContainer creates a new postgres container with
// default adapter and connection. The params.URL is overwritten.
func NewPostgresContainer(ctx context.Context, params *core.ConnectionParams) (*PostgresContainer, error) {
	seedFile, err := GetTestDataFile("postgres_seed.sql")
	if err != nil {
		return nil, err
	}

	ctr, err := tcpsql.Run(
		ctx,
		"postgres:16-alpine",
		tcpsql.BasicWaitStrategies(),
		tc.CustomizeRequest(tc.GenericContainerRequest{
			ProviderType: GetContainerProvider(),
		}),
		tcpsql.WithInitScripts(seedFile.Name()),
		tcpsql.WithDatabase("dev"),
	)
	if err != nil {
		return nil, err
	}
	connURL, err := ctr.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		return nil, err
	}

	if params.Type == "" {
		params.Type = "postgres"
	}

	if params.URL == "" {
		params.URL = connURL
	}

	driver, err := adapters.NewConnection(params)
	if err != nil {
		return nil, err
	}

	return &PostgresContainer{
		PostgresContainer: ctr,
		ConnURL:           connURL,
		Driver:            driver,
	}, nil
}

// NewDriver helper function to create a new driver with the connection URL.
func (p *PostgresContainer) NewDriver(params *core.ConnectionParams) (*core.Connection, error) {
	if params.URL == "" {
		params.URL = p.ConnURL
	}
	if params.Type == "" {
		params.Type = "postgres"
	}

	return adapters.NewConnection(params)
}



================================================
FILE: dbee/tests/testhelpers/sqlite.go
================================================
package testhelpers

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/docker/docker/api/types/container"
	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	tc "github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
)

type SQLiteContainer struct {
	tc.Container
	ConnURL string
	Driver  *core.Connection
	TempDir string
}

// NewSQLiteContainer creates a new sqlite container with
// default adapter and connection. The params.URL is overwritten.
// It uses a temporary directory (usually the test suite tempDir) to store the db file.
// The tmpDir is then mounted to the container and all the dependencies are installed
// in the container file, while still being able to connect to the db file in the host.
func NewSQLiteContainer(ctx context.Context, params *core.ConnectionParams, tmpDir string) (*SQLiteContainer, error) {
	seedFile, err := GetTestDataFile("sqlite_seed.sql")
	if err != nil {
		return nil, err
	}

	dbName, containerDBPath := "test.db", "/container/db"
	entrypointCmd := []string{
		"apk add sqlite",
		fmt.Sprintf("sqlite3 %s/%s < %s", containerDBPath, dbName, seedFile.Name()),
		"echo 'ready'",
		"tail -f /dev/null", // hack to keep the container running indefinitely
	}

	req := tc.ContainerRequest{
		Image: "alpine:3.21",
		Files: []tc.ContainerFile{
			{
				Reader:            seedFile,
				ContainerFilePath: seedFile.Name(),
				FileMode:          0o755,
			},
		},
		HostConfigModifier: func(hc *container.HostConfig) {
			hc.Binds = append(hc.Binds, fmt.Sprintf("%s:%s", tmpDir, containerDBPath))
		},
		Cmd:        []string{"sh", "-c", strings.Join(entrypointCmd, " && ")},
		WaitingFor: wait.ForLog("ready").WithStartupTimeout(5 * time.Second),
	}

	ctr, err := tc.GenericContainer(ctx, tc.GenericContainerRequest{
		ContainerRequest: req,
		ProviderType:     GetContainerProvider(),
		Started:          true,
	})
	if err != nil {
		return nil, err
	}

	if params.Type == "" {
		params.Type = "sqlite"
	}

	connURL := filepath.Join(tmpDir, dbName)
	if params.URL == "" {
		params.URL = connURL
	}

	driver, err := adapters.NewConnection(params)
	if err != nil {
		return nil, err
	}

	return &SQLiteContainer{
		Container: ctr,
		ConnURL:   connURL,
		Driver:    driver,
		TempDir:   tmpDir,
	}, nil
}

// NewDriver helper function to create a new driver with the connection URL.
func (p *SQLiteContainer) NewDriver(params *core.ConnectionParams) (*core.Connection, error) {
	if params.URL == "" {
		params.URL = p.ConnURL
	}
	if params.Type == "" {
		params.Type = "sqlite"
	}

	return adapters.NewConnection(params)
}



================================================
FILE: dbee/tests/testhelpers/sqlserver.go
================================================
package testhelpers

import (
	"context"

	"github.com/kndndrj/nvim-dbee/dbee/adapters"
	"github.com/kndndrj/nvim-dbee/dbee/core"
	tc "github.com/testcontainers/testcontainers-go"
	tcmssql "github.com/testcontainers/testcontainers-go/modules/mssql"
)

type MSSQLServerContainer struct {
	*tcmssql.MSSQLServerContainer
	ConnURL string
	Driver  *core.Connection
}

// NewSQLServerContainer creates a new MS SQL Server container with
// default adapter and connection. The params.URL is overwritten.
func NewSQLServerContainer(ctx context.Context, params *core.ConnectionParams) (*MSSQLServerContainer, error) {
	const password = "H3ll0@W0rld"
	seedFile, err := GetTestDataFile("sqlserver_seed.sql")
	if err != nil {
		return nil, err
	}

	ctr, err := tcmssql.Run(
		ctx,
		"mcr.microsoft.com/mssql/server:2022-CU17-ubuntu-22.04",
		tcmssql.WithAcceptEULA(), // ok for testing purposes
		tcmssql.WithPassword(password),
		tc.CustomizeRequest(tc.GenericContainerRequest{
			ContainerRequest: tc.ContainerRequest{
				Files: []tc.ContainerFile{
					{
						Reader:            seedFile,
						ContainerFilePath: seedFile.Name(),
						FileMode:          0o644,
					},
				},
			},
			ProviderType: GetContainerProvider(),
		}),
		tc.WithAfterReadyCommand(
			tc.NewRawCommand([]string{
				"/opt/mssql-tools18/bin/sqlcmd",
				"-S", "localhost",
				"-U", "sa",
				"-P", password,
				"-No",
				"-i", seedFile.Name(),
			}),
		),
	)
	if err != nil {
		return nil, err
	}

	connURL, err := ctr.ConnectionString(ctx, "encrypt=false", "TrustServerCertificate=true")
	if err != nil {
		return nil, err
	}

	if params.Type == "" {
		params.Type = "mssql"
	}

	if params.URL == "" {
		params.URL = connURL
	}

	driver, err := adapters.NewConnection(params)
	if err != nil {
		return nil, err
	}

	return &MSSQLServerContainer{
		MSSQLServerContainer: ctr,
		ConnURL:              connURL,
		Driver:               driver,
	}, nil
}

// NewDriver helper function to create a new driver with the connection URL.
func (p *MSSQLServerContainer) NewDriver(params *core.ConnectionParams) (*core.Connection, error) {
	if params.URL == "" {
		params.URL = p.ConnURL
	}
	if params.Type == "" {
		params.Type = "mssql"
	}

	return adapters.NewConnection(params)
}



================================================
FILE: doc/dbee-reference.txt
================================================
==============================================================================
Table of Contents                                            *dbee.ref.contents*

Dbee Reference ······················································ |dbee.ref|
Dbee Configuration ··········································· |dbee.ref.config|
Types ························································· |dbee.ref.types|
Sources ····················································· |dbee.ref.sources|
UI Layout ···················································· |dbee.ref.layout|
Dbee Core API ·············································· |dbee.ref.api.core|
Dbee UI API ·················································· |dbee.ref.api.ui|

==============================================================================
Dbee Reference                                                        *dbee.ref*

Database Client for NeoVim.

dbee.setup({cfg?})                                                  *dbee.setup*
    Setup function.
    Needs to be called before calling any other function.

    Parameters: ~
        {cfg}  (nil|Config)


dbee.toggle()                                                      *dbee.toggle*
    Toggle dbee UI.


dbee.open()                                                          *dbee.open*
    Open dbee UI. If already opened, reset window layout.


dbee.close()                                                        *dbee.close*
    Close dbee UI.


dbee.is_open()                                                    *dbee.is_open*
    Check if dbee UI is open or not.

    Returns: ~
        (boolean)


dbee.execute({query})                                             *dbee.execute*
    Execute a query on current connection.
    Convenience wrapper around some api functions that executes a query on
    current connection and pipes the output to result UI.

    Parameters: ~
        {query}  (string)


dbee.store({format}, {output}, {opts})                              *dbee.store*
    Store currently displayed result.
    Convenience wrapper around some api functions.

    Parameters: ~
        {format}  (string)                                   format of the output -> "csv"|"json"|"table"
        {output}  (string)                                   where to pipe the results -> "file"|"yank"|"buffer"
        {opts}    ({from:integer,to:integer,extra_arg:any})


install_command                                                *install_command*
    Supported install commands.

    Variants: ~
        ("wget")
        ("curl")
        ("bitsadmin")
        ("go")
        ("cgo")


dbee.install({command?})                                          *dbee.install*
    Install dbee backend binary.

    Parameters: ~
        {command}  (nil|install_command)  Preffered install command

    See: ~
        |install_command|


==============================================================================
Dbee Configuration                                             *dbee.ref.config*

Config                                                                  *Config*

    Fields: ~
        {default_connection}  (nil|string)
        {sources}             (nil|Source[])                            list of connection sources
        {extra_helpers}       (nil|table<string,table<string,string>>)
        {float_options}       (nil|table<string,any>)
        {drawer}              (nil|drawer_config)
        {editor}              (nil|editor_config)
        {result}              (nil|result_config)
        {call_log}            (nil|call_log_config)
        {window_layout}       (nil|Layout)


Candy                                                                    *Candy*

    Fields: ~
        {icon}            (string)
        {icon_highlight}  (string)
        {text_highlight}  (string)


key_mapping                                                        *key_mapping*
    Keymap options.

    Type: ~
        {key:string,mode:string,opts:table,action:string|fun()}


------------------------------------------------------------------------------

result_config                                                    *result_config*
    Configuration for result UI tile.

    Type: ~
        {focus_result:boolean,mappings:key_mapping[],page_size:integer,progress:progress_config,window_options:table<string,any>,buffer_options:table<string,any>}


editor_config                                                    *editor_config*
    Configuration for editor UI tile.

    Type: ~
        {directory:string,mappings:key_mapping[],window_options:table<string,any>,buffer_options:table<string,any>}


call_log_config                                                *call_log_config*
    Configuration for call log UI tile.

    Type: ~
        {mappings:key_mapping[],disable_candies:boolean,candies:table<string,Candy>,window_options:table<string,any>,buffer_options:table<string,any>}


drawer_config                                                    *drawer_config*
    Configuration for drawer UI tile.

    Type: ~
        {disable_candies:boolean,candies:table<string,Candy>,mappings:key_mapping[],disable_help:boolean,window_options:table<string,any>,buffer_options:table<string,any>}


------------------------------------------------------------------------------

config.default                                                  *config.default*
    Default configuration.
    To see defaults, run :lua= require"dbee.config".default

    Type: ~
        (Config)  config


==============================================================================
Types                                                           *dbee.ref.types*

Overview of types used in DBee API.

------------------------------------------------------------------------------

                                                          *dbee.ref.types.table*
Table related types

Column                                                                  *Column*
    Table column

    Fields: ~
        {name}  (string)  name of the column
        {type}  (string)  database type of the column


materialization                                                *materialization*
    Table Materialization.

    Variants: ~
        ("table")
        ("view")


TableOpts                                                            *TableOpts*
    Options for gathering table specific info.

    Fields: ~
        {table}            (string)
        {schema}           (string)
        {materialization}  (materialization)


table_helpers                                                    *table_helpers*
    Table helpers queries by name.

    Type: ~
        table<string,string>


------------------------------------------------------------------------------

                                                           *dbee.ref.types.call*
Call related types.

call_id                                                                *call_id*
    ID of a call.

    Type: ~
        string


call_state                                                          *call_state*
    State of a call.

    Variants: ~
        ("unknown")
        ("executing")
        ("executing_failed")
        ("retrieving")
        ("retrieving_failed")
        ("archived")
        ("archive_failed")
        ("canceled")


CallDetails                                                        *CallDetails*
    Details and stats of a single call to database.

    Fields: ~
        {id}             (call_id)
        {time_taken_us}  (integer)     duration (time period) in microseconds
        {query}          (string)
        {state}          (call_state)
        {timestamp_us}   (integer)     time in microseconds
        {error}          (nil|string)  error message in case of error


------------------------------------------------------------------------------

                                                     *dbee.ref.types.connection*
Connection related types.

connection_id                                                    *connection_id*
    ID of a connection.

    Type: ~
        string


ConnectionParams                                              *ConnectionParams*
    Parameters of a connection.

    Fields: ~
        {id}    (connection_id)
        {name}  (string)
        {type}  (string)
        {url}   (string)


------------------------------------------------------------------------------

                                                      *dbee.ref.types.structure*
Database structure related types.

structure_type                                                  *structure_type*
    Type of node in database structure.

    Variants: ~
        ("")
        ("table")
        ("history")
        ("database_switch")
        ("view")


DBStructure                                                        *DBStructure*
    Structure of database.

    Fields: ~
        {name}    (string)          display name
        {type}    (structure_type)  type of node in structure
        {schema}  (string)


------------------------------------------------------------------------------

                                                         *dbee.ref.types.events*
Event related types.

core_event_name                                                *core_event_name*
    Avaliable core events.

    Variants: ~
        ("call_state_changed")


editor_event_name                                            *editor_event_name*
    Available editor events.

    Variants: ~
        ("note_state_changed")


event_listener                                                  *event_listener*
    Event handler function.

    Type: ~
        fun(data:any)


==============================================================================
Sources                                                       *dbee.ref.sources*

Sources can be created by implementing the Source interface.
Some methods are optional and are related to updating/editing functionality.

source_id                                                            *source_id*
    ID of a source.

    Type: ~
        string


Source                                                                  *Source*
    Source interface
    "name" and "load" methods are mandatory for basic functionality.
    "create", "update" and "delete" methods are optional and provide interactive CRUD.
    "file" method is used for providing optional manual edits of the source's file.
    A source is also in charge of managing ids of connections. A connection parameter without
    a unique id results in an error or undefined behavior.

    Fields: ~
        {name}    (fun(self:Source):string)                                         function to return the name of the source
        {load}    (fun(self:Source):ConnectionParams[])                             function to load connections from external source
        {create}  (nil|fun(self:Source,details:ConnectionParams):connection_id)     create a connection and return its id (optional)
        {delete}  (nil|fun(self:Source,id:connection_id))                           delete a connection from its id (optional)
        {update}  (nil|fun(self:Source,id:connection_id,details:ConnectionParams))  update provided connection (optional)
        {file}    (nil|fun(self:Source):string)                                     function which returns a source file to edit (optional)


------------------------------------------------------------------------------

FileSource : Source                                                 *FileSource*
    Built-In File Source.

    Fields: ~



sources.FileSource:new({path})                          *sources.FileSource:new*
     Loads connections from json file

    Parameters: ~
        {path}  (string)  path to file

    Returns: ~
        (Source)


------------------------------------------------------------------------------

EnvSource : Source                                                   *EnvSource*
    Built-In Env Source.
    Loads connections from json string of env variable.

    Fields: ~



sources.EnvSource:new({var})                             *sources.EnvSource:new*

    Parameters: ~
        {var}  (string)  env var to load connections from

    Returns: ~
        (Source)


------------------------------------------------------------------------------

MemorySource : Source                                             *MemorySource*
    Built-In Memory Source.
    Loads connections from lua table.

    Fields: ~



                                                      *sources.MemorySource:new*
sources.MemorySource:new({conns}, {name?})

    Parameters: ~
        {conns}  (ConnectionParams[])  list of connections
        {name}   (nil|string)          optional display name

    Returns: ~
        (Source)


==============================================================================
UI Layout                                                      *dbee.ref.layout*

Defines the layout of UI windows.
The default layout is already defined, but it's possible to define your own layout.

Layout implementation should implement the |Layout| interface and show the UI on screen
as seen fit.

Layout                                                                  *Layout*
    Layout that defines how windows are opened.
    Layouts are free to use both core and ui apis.
    see |dbee.ref.api.core| and |dbee.ref.api.ui|

    Important for layout implementations: when opening windows, they must be
    exclusive to dbee. When closing windows, make sure to not reuse any windows dbee left over.

    Fields: ~
        {is_open}  (fun(self:Layout):boolean)  function that returns the state of ui.
        {open}     (fun(self:Layout))          function to open ui.
        {reset}    (fun(self:Layout))          function to reset ui.
        {close}    (fun(self:Layout))          function to close ui.


------------------------------------------------------------------------------

DefaultLayout : Layout                                           *DefaultLayout*

    Fields: ~



layouts.Default:new()                                      *layouts.Default:new*

    Returns: ~
        (DefaultLayout)


==============================================================================
Dbee Core API                                                *dbee.ref.api.core*

This module contains functions to operate on the backend side.

Access it like this:
>
require("dbee").api.core.func()
<

core.is_loaded()                                                *core.is_loaded*
    Returns true if dbee core is loaded.

    Returns: ~
        (boolean)


                                                  *core.register_event_listener*
core.register_event_listener({event}, {listener})
    Registers an event handler for core events.

    Parameters: ~
        {event}     (core_event_name)
        {listener}  (event_listener)


core.add_source({source})                                      *core.add_source*
    Add new source and load connections from it.

    Parameters: ~
        {source}  (Source)


core.get_sources()                                            *core.get_sources*
    Get a list of registered sources.

    Returns: ~
        (Source[])


core.source_reload({id})                                    *core.source_reload*
    Reload a source by id.

    Parameters: ~
        {id}  (source_id)


                                                    *core.source_add_connection*
core.source_add_connection({id}, {details})
    Add connection to the source.
    In case the source cannot add connections, this call fails.

    Parameters: ~
        {id}       (source_id)
        {details}  (ConnectionParams)

    Returns: ~
        (connection_id)


                                                 *core.source_remove_connection*
core.source_remove_connection({id}, {conn_id})
    Remove a connection from the source.
    In case the source cannot delete connections, this call fails.

    Parameters: ~
        {id}       (source_id)
        {conn_id}  (connection_id)


                                                 *core.source_update_connection*
core.source_update_connection({id}, {conn_id}, {details})
    Update an existing connection from the source.
    In case the source cannot edit connections, this call fails.

    Parameters: ~
        {id}       (source_id)
        {conn_id}  (connection_id)
        {details}  (ConnectionParams)


core.source_get_connections({id})                  *core.source_get_connections*
     Get a list of connections from source.

    Parameters: ~
        {id}  (source_id)

    Returns: ~
        (ConnectionParams[])


core.add_helpers({helpers})                                   *core.add_helpers*
    Register helper queries per database type.
    every helper value is a go-template with values set for
    "Table", "Schema" and "Materialization".

    Parameters: ~
        {helpers}  (table<string,table<string,string>>)  extra helpers per type

    See: ~
        |table_helpers|

    Usage: ~
>lua
        {
          ["postgres"] = {
            ["List All"] = "SELECT * FROM {{ .Table }}",
          }
        }
<


                                                   *core.connection_get_helpers*
core.connection_get_helpers({id}, {opts})
    Get helper queries for a specific connection.

    Parameters: ~
        {id}    (connection_id)
        {opts}  (TableOpts)

    Returns: ~
        (table<string,string>)  list of table helpers

    See: ~
        |table_helpers|


core.get_current_connection()                      *core.get_current_connection*
    Get the currently active connection.

    Returns: ~
        (ConnectionParams|nil)


core.set_current_connection({id})                  *core.set_current_connection*
    Set a currently active connection.

    Parameters: ~
        {id}  (connection_id)


core.connection_execute({id}, {query})                 *core.connection_execute*
    Execute a query on a connection.

    Parameters: ~
        {id}     (connection_id)
        {query}  (string)

    Returns: ~
        (CallDetails)


core.connection_get_structure({id})              *core.connection_get_structure*
    Get database structure of a connection.

    Parameters: ~
        {id}  (connection_id)

    Returns: ~
        (DBStructure[])


                                                   *core.connection_get_columns*
core.connection_get_columns({id}, {opts})
    Get columns of a table

    Parameters: ~
        {id}    (connection_id)
        {opts}  ({table:string,schema:string,materialization:string})

    Returns: ~
        (Column[])


core.connection_get_params({id})                    *core.connection_get_params*
    Get parameters that define the connection.

    Parameters: ~
        {id}  (connection_id)

    Returns: ~
        (ConnectionParams|nil)


core.connection_list_databases({id})            *core.connection_list_databases*
    List databases of a connection.
    Some databases might not support this - in that case, a call to this
    function returns an error.

    Parameters: ~
        {id}  (connection_id)

    Returns: ~
        (string)    selected database
        (string[])  available databases


                                               *core.connection_select_database*
core.connection_select_database({id}, {database})
    Select an active database of a connection.
    Some databases might not support this - in that case, a call to this
    function returns an error.

    Parameters: ~
        {id}        (connection_id)
        {database}  (string)


core.connection_get_calls({id})                      *core.connection_get_calls*
    Get a list of past calls of a connection.

    Parameters: ~
        {id}  (connection_id)

    Returns: ~
        (CallDetails[])


core.call_cancel({id})                                        *core.call_cancel*
    Cancel call execution.
    If call is finished, nothing happens.

    Parameters: ~
        {id}  (call_id)


                                                      *core.call_display_result*
core.call_display_result({id}, {bufnr}, {from}, {to})
    Display the result of a call formatted as a table in a buffer.

    Parameters: ~
        {id}     (call_id)  id of the call
        {bufnr}  (integer)
        {from}   (integer)
        {to}     (integer)

    Returns: ~
        (integer)  number of rows


                                                        *core.call_store_result*
core.call_store_result({id}, {format}, {output}, {opts})
    Store the result of a call.

    Parameters: ~
        {id}      (call_id)
        {format}  (string)                                   format of the output -> "csv"|"json"|"table"
        {output}  (string)                                   where to pipe the results -> "file"|"yank"|"buffer"
        {opts}    ({from:integer,to:integer,extra_arg:any})


==============================================================================
Dbee UI API                                                    *dbee.ref.api.ui*

UI API module for nvim dbee.

This module contains functions to operate with UI tiles.
Functions are prefixed with a ui name:
- editor
- result
- drawer
- call_log

 Access the module like this:
>
require("dbee").api.ui.func()
<

ui.is_loaded()                                                    *ui.is_loaded*
    Returns true if dbee ui is loaded.

    Returns: ~
        (boolean)


------------------------------------------------------------------------------

                                                        *dbee.ref.api.ui.editor*
Editor API

                                             *ui.editor_register_event_listener*
ui.editor_register_event_listener({event}, {listener})
    Registers an event handler for editor events.

    Parameters: ~
        {event}     (editor_event_name)
        {listener}  (event_listener)


ui.editor_search_note({id})                              *ui.editor_search_note*
     Search for a note with provided id across namespaces.

    Parameters: ~
        {id}  (note_id)

    Returns: ~
        (note_details|nil)
        (namespace_id)      namespace of the note


ui.editor_search_note_with_buf({bufnr})         *ui.editor_search_note_with_buf*
     Search for a note with provided buffer across namespaces.

    Parameters: ~
        {bufnr}  (integer)

    Returns: ~
        (note_details|nil)
        (namespace_id)      namespace of the note


ui.editor_search_note_with_file({file})        *ui.editor_search_note_with_file*
     Search for a note with provided file name across namespaces.

    Parameters: ~
        {file}  (string)

    Returns: ~
        (note_details|nil)
        (namespace_id)      namespace of the note


                                               *ui.editor_namespace_create_note*
ui.editor_namespace_create_note({id}, {name})
     Creates a new note in namespace.
     Errors if id or name is nil or there is a note with the same
     name in namespace already.

    Parameters: ~
        {id}    (namespace_id)
        {name}  (string)

    Returns: ~
        (note_id)


ui.editor_namespace_get_notes({id})              *ui.editor_namespace_get_notes*
     Get notes of a specified namespace.

    Parameters: ~
        {id}  (namespace_id)

    Returns: ~
        (note_details[])


                                               *ui.editor_namespace_remove_note*
ui.editor_namespace_remove_note({id}, {note_id})
     Removes an existing note.
     Errors if there is no note with provided id in namespace.

    Parameters: ~
        {id}       (namespace_id)
        {note_id}  (note_id)


ui.editor_note_rename({id}, {name})                      *ui.editor_note_rename*
     Renames an existing note.
     Errors if no name or id provided, there is no note with provided id or
     there is already an existing note with the same name in the same namespace.

    Parameters: ~
        {id}    (note_id)
        {name}  (string)   new name


ui.editor_get_current_note()                        *ui.editor_get_current_note*
     Get details of a current note

    Returns: ~
        (note_details|nil)


ui.editor_set_current_note({id})                    *ui.editor_set_current_note*
     Sets note with id as the current note
     and opens it in the window.

    Parameters: ~
        {id}  (note_id)


ui.editor_show({winid})                                         *ui.editor_show*
     Open the editor UI.

    Parameters: ~
        {winid}  (integer)


ui.editor_do_action({action})                              *ui.editor_do_action*
     Trigger an action in editor.

    Parameters: ~
        {action}  (string)


------------------------------------------------------------------------------

                                                      *dbee.ref.api.ui.call_log*
Call Log API

ui.call_log_refresh()                                      *ui.call_log_refresh*
     Refresh the call log.


ui.call_log_show({winid})                                     *ui.call_log_show*
     Open the call log UI.

    Parameters: ~
        {winid}  (integer)


ui.call_log_do_action({action})                          *ui.call_log_do_action*
     Trigger an action in call_log.

    Parameters: ~
        {action}  (string)


------------------------------------------------------------------------------

                                                        *dbee.ref.api.ui.drawer*
Drawer API

ui.drawer_refresh()                                          *ui.drawer_refresh*
     Refresh the drawer.


ui.drawer_show({winid})                                         *ui.drawer_show*
     Open the drawer UI.

    Parameters: ~
        {winid}  (integer)


ui.drawer_do_action({action})                              *ui.drawer_do_action*
     Trigger an action in drawer.

    Parameters: ~
        {action}  (string)


------------------------------------------------------------------------------

                                                        *dbee.ref.api.ui.result*
Result API

ui.result_set_call({call})                                  *ui.result_set_call*
     Sets call's result to Result's buffer.

    Parameters: ~
        {call}  (CallDetails)


ui.result_get_call()                                        *ui.result_get_call*
     Gets the currently displayed call.

    Returns: ~
        (CallDetails|nil)


ui.result_page_current()                                *ui.result_page_current*
     Display the currently selected page in results UI.


ui.result_page_next()                                      *ui.result_page_next*
     Go to next page in results UI and display it.


ui.result_page_prev()                                      *ui.result_page_prev*
     Go to previous page in results UI and display it.


ui.result_page_last()                                      *ui.result_page_last*
     Go to last page in results UI and display it.


ui.result_page_first()                                    *ui.result_page_first*
     Go to first page in results UI and display it.


ui.result_show({winid})                                         *ui.result_show*
     Open the result UI.

    Parameters: ~
        {winid}  (integer)


ui.result_do_action({action})                              *ui.result_do_action*
     Trigger an action in result.

    Parameters: ~
        {action}  (string)


vim:tw=78:ts=8:noet:ft=help:norl:



================================================
FILE: doc/dbee.txt
================================================
*dbee.txt*                                          Database Client for NeoVim

==============================================================================
Table of Contents                                     *dbee-table-of-contents*

1. Neovim DBee                                              |dbee-neovim-dbee|
  - Installation                               |dbee-neovim-dbee-installation|
  - Configuration                             |dbee-neovim-dbee-configuration|
  - Usage                                             |dbee-neovim-dbee-usage|
  - API                                                 |dbee-neovim-dbee-api|
  - Extensions                                   |dbee-neovim-dbee-extensions|
2. DBee Architecture Overview                |dbee-dbee-architecture-overview|
  - Lua Architecture        |dbee-dbee-architecture-overview-lua-architecture|
  - Go Architecture          |dbee-dbee-architecture-overview-go-architecture|

==============================================================================
1. Neovim DBee                                              *dbee-neovim-dbee*

**Database Client for NeoVim!**

**Execute Your Favourite Queries From the Comfort of Your Editor!**

**Backend in Go!**

**Frontend in Lua!**

**Doesn’t rely on CLI tools!**

**Get Results FAST With Under-the-hood Iterator!**

**Bees Love It!**

**Alpha Software - Expect Breaking Changes!**


INSTALLATION                                   *dbee-neovim-dbee-installation*

**requires nvim>=0.10**

- packer.nvim:
    >lua
        use {
          "kndndrj/nvim-dbee",
          requires = {
            "MunifTanjim/nui.nvim",
          },
          run = function()
            -- Install tries to automatically detect the install method.
            -- if it fails, try calling it with one of these parameters:
            --    "curl", "wget", "bitsadmin", "go"
            require("dbee").install()
          end,
          config = function()
            require("dbee").setup(--[[optional config]])
          end
        }
    <
- lazy.nvim:
    >lua
        {
          "kndndrj/nvim-dbee",
          dependencies = {
            "MunifTanjim/nui.nvim",
          },
          build = function()
            -- Install tries to automatically detect the install method.
            -- if it fails, try calling it with one of these parameters:
            --    "curl", "wget", "bitsadmin", "go"
            require("dbee").install()
          end,
          config = function()
            require("dbee").setup(--[[optional config]])
          end,
        },
    <


PLATFORM SUPPORT ~

This project aims to be as cross-platform as possible, but there are some
limitations (for example some of the go dependencies only work on certain
platforms). To address this issue, the client implementations are detached from
the main logic and they register themselves to dbee backend on plugin start.
This allows the use of build constraints, which we use to exclued certain
client implementations on certain platforms.

The CI pipeline tries building the binary for GOARCH/GOOS combinations
specified in targets.json <ci/targets.json> - if the builds succeed, they are
stored in a remote bucket <https://github.com/kndndrj/nvim-dbee-bucket> on a
separate branch per run. Additionally, the install manifest
<lua/dbee/install/__manifest.lua> gets created.

To increase cgo cross-platform support, the pipeline uses zig as a C compiler.

To check if your platform is currently supported, check out the mentioned
manifest and the targets file.


MANUAL BINARY INSTALLATION ~

The installation examples include the `build`/`run` functions, which get
triggered once the plugin updates. This should be sufficient for the majority
of users. If that doesn’t include you, then you have a few options:

- just install with the `"go"` option (this performs `go build` under the hood):
    >lua
        require("dbee").install("go")
    <
- Download an already compiled binary from one of urls in the install manifest
    <lua/dbee/install/__manifest.lua>
- `go install` (the install location will vary depending on your local go
    configuration):
    >sh
        go install github.com/kndndrj/nvim-dbee/dbee@<version>
    <
- Clone and build
    >sh
        # Clone the repository and cd into the "go subfolder"
        git clone <this_repo>
        cd <this_repo>/dbee
        # Build the binary (optional output path)
        go build [-o ~/.local/share/nvim/dbee/bin/dbee]
    <


CONFIGURATION                                 *dbee-neovim-dbee-configuration*

You can pass an optional table parameter to `setup()` function.

Here are the defaults:

>lua
    ---Default configuration.
    ---To see defaults, run :lua= require"dbee.config".default
    ---@type Config config
    config.default = {
      -- you can specify an optional default connection id and it will be the active one
      -- when dbee starts
      default_connection = nil,
      -- loads connections from files and environment variables
      sources = {
        require("dbee.sources").EnvSource:new("DBEE_CONNECTIONS"),
        require("dbee.sources").FileSource:new(vim.fn.stdpath("state") .. "/dbee/persistence.json"),
      },
      -- extra table helpers per connection type
      -- every helper value is a go-template with values set for
      -- "Table", "Schema" and "Materialization"
      extra_helpers = {
        -- example:
        -- ["postgres"] = {
        --   ["List All"] = "select * from {{ .Table }}",
        -- },
      },
      -- options passed to floating windows - :h nvim_open_win()
      float_options = {},
    
      -- drawer window config
      drawer = {
        -- these two option settings can be added to all UI elements and
        -- allow for passing specific window/buffer options.
        -- Note that you probably shouldn't be passing buffer options, since
        -- the functionality of the plugin might rely on them.
        -- TL;DR: only use this if you know what you are doing!
        window_options = {},
        buffer_options = {},
    
        -- show help or not
        disable_help = false,
        -- mappings for the buffer
        mappings = {
          -- manually refresh drawer
          { key = "r", mode = "n", action = "refresh" },
          -- actions perform different stuff depending on the node:
          -- action_1 opens a note or executes a helper
          { key = "<CR>", mode = "n", action = "action_1" },
          -- action_2 renames a note or sets the connection as active manually
          { key = "cw", mode = "n", action = "action_2" },
          -- action_3 deletes a note or connection (removes connection from the file if you configured it like so)
          { key = "dd", mode = "n", action = "action_3" },
          -- these are self-explanatory:
          -- { key = "c", mode = "n", action = "collapse" },
          -- { key = "e", mode = "n", action = "expand" },
          { key = "o", mode = "n", action = "toggle" },
          -- mappings for menu popups:
          { key = "<CR>", mode = "n", action = "menu_confirm" },
          { key = "y", mode = "n", action = "menu_yank" },
          { key = "<Esc>", mode = "n", action = "menu_close" },
          { key = "q", mode = "n", action = "menu_close" },
        },
        -- icon settings:
        disable_candies = false,
        candies = {
          -- these are what's available for now:
          history = {
            icon = "",
            icon_highlight = "Constant",
            text_highlight = "",
          },
          note = {
            icon = "",
            icon_highlight = "Character",
            text_highlight = "",
          },
          connection = {
            icon = "󱘖",
            icon_highlight = "SpecialChar",
            text_highlight = "",
          },
          database_switch = {
            icon = "",
            icon_highlight = "Character",
            text_highlight = "",
          },
          schema = {
            icon = "",
            icon_highlight = "Removed",
            text_highlight = "",
          },
          table = {
            icon = "",
            icon_highlight = "Conditional",
            text_highlight = "",
          },
          streaming_table = {
            icon = "",
            icon_highlight = "Conditional",
            text_highlight = "",
          },
          managed = {
            icon = "",
            icon_highlight = "Conditional",
            text_highlight = "",
          },
          view = {
            icon = "",
            icon_highlight = "Debug",
            text_highlight = "",
          },
          materialized_view = {
            icon = "",
            icon_highlight = "Type",
            text_highlight = "",
          },
          sink = {
            icon = "",
            icon_highlight = "String",
            text_highlight = "",
          },
          column = {
            icon = "󰠵",
            icon_highlight = "WarningMsg",
            text_highlight = "",
          },
          add = {
            icon = "",
            icon_highlight = "String",
            text_highlight = "String",
          },
          edit = {
            icon = "󰏫",
            icon_highlight = "Directory",
            text_highlight = "Directory",
          },
          remove = {
            icon = "󰆴",
            icon_highlight = "SpellBad",
            text_highlight = "SpellBad",
          },
          help = {
            icon = "󰋖",
            icon_highlight = "Title",
            text_highlight = "Title",
          },
          source = {
            icon = "󰃖",
            icon_highlight = "MoreMsg",
            text_highlight = "MoreMsg",
          },
    
          -- if there is no type
          -- use this for normal nodes...
          none = {
            icon = " ",
            icon_highlight = "",
            text_highlight = "",
          },
          -- ...and use this for nodes with children
          none_dir = {
            icon = "",
            icon_highlight = "NonText",
            text_highlight = "",
          },
    
          -- chevron icons for expanded/closed nodes
          node_expanded = {
            icon = "",
            icon_highlight = "NonText",
            text_highlight = "",
          },
          node_closed = {
            icon = "",
            icon_highlight = "NonText",
            text_highlight = "",
          },
        },
      },
    
      -- results window config
      result = {
        -- see drawer comment.
        window_options = {},
        buffer_options = {},
    
        -- number of rows in the results set to display per page
        page_size = 100,
    
        -- whether to focus the result window after a query
        focus_result = true,
    
        -- progress (loading) screen options
        progress = {
          -- spinner to use in progress display
          spinner = { "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" },
          -- prefix to display before the timer
          text_prefix = "Executing...",
        },
    
        -- mappings for the buffer
        mappings = {
          -- next/previous page
          { key = "L", mode = "", action = "page_next" },
          { key = "H", mode = "", action = "page_prev" },
          { key = "E", mode = "", action = "page_last" },
          { key = "F", mode = "", action = "page_first" },
          -- yank rows as csv/json
          { key = "yaj", mode = "n", action = "yank_current_json" },
          { key = "yaj", mode = "v", action = "yank_selection_json" },
          { key = "yaJ", mode = "", action = "yank_all_json" },
          { key = "yac", mode = "n", action = "yank_current_csv" },
          { key = "yac", mode = "v", action = "yank_selection_csv" },
          { key = "yaC", mode = "", action = "yank_all_csv" },
    
          -- cancel current call execution
          { key = "<C-c>", mode = "", action = "cancel_call" },
        },
      },
    
      -- editor window config
      editor = {
        -- see drawer comment.
        window_options = {},
        buffer_options = {},
    
        -- directory where to store the scratchpads.
        --directory = "path/to/scratchpad/dir",
    
        -- mappings for the buffer
        mappings = {
          -- run what's currently selected on the active connection
          { key = "BB", mode = "v", action = "run_selection" },
          -- run the whole file on the active connection
          { key = "BB", mode = "n", action = "run_file" },
          -- run what's under the cursor to the next newline
          { key = "<CR>", mode = "n", action = "run_under_cursor" },
        },
      },
    
      -- call log window config
      call_log = {
        -- see drawer comment.
        window_options = {},
        buffer_options = {},
    
        -- mappings for the buffer
        mappings = {
          -- show the result of the currently selected call record
          { key = "<CR>", mode = "", action = "show_result" },
          -- cancel the currently selected call (if its still executing)
          { key = "<C-c>", mode = "", action = "cancel_call" },
        },
    
        -- candies (icons and highlights)
        disable_candies = false,
        candies = {
          -- all of these represent call states
          unknown = {
            icon = "", -- this or first letters of state
            icon_highlight = "NonText", -- highlight of the state
            text_highlight = "", -- highlight of the rest of the line
          },
          executing = {
            icon = "󰑐",
            icon_highlight = "Constant",
            text_highlight = "Constant",
          },
          executing_failed = {
            icon = "󰑐",
            icon_highlight = "Error",
            text_highlight = "",
          },
          retrieving = {
            icon = "",
            icon_highlight = "String",
            text_highlight = "String",
          },
          retrieving_failed = {
            icon = "",
            icon_highlight = "Error",
            text_highlight = "",
          },
          archived = {
            icon = "",
            icon_highlight = "Title",
            text_highlight = "",
          },
          archive_failed = {
            icon = "",
            icon_highlight = "Error",
            text_highlight = "",
          },
          canceled = {
            icon = "",
            icon_highlight = "Error",
            text_highlight = "",
          },
        },
      },
    
      -- window layout
      window_layout = require("dbee.layouts").Default:new(),
    }
<


USAGE                                                 *dbee-neovim-dbee-usage*

Call the `setup()` function with an optional config parameter.

>lua
    -- Open/close/toggle the UI.
    require("dbee").open()
    require("dbee").close()
    require("dbee").toggle()
    -- Run a query on the currently active connection.
    require("dbee").execute(query)
    -- Store the current result to file/buffer/yank-register (see "Getting Started").
    require("dbee").store(format, output, opts)
<

The same functions are also available through the `:Dbee` user command.


GETTING STARTED ~

Here are a few steps to quickly get started:

- call the `setup()` function in your `init.lua`
- Specify connections using one or more sources (reffer to |dbee-this-section|).
- When you restart the editor, call `lua require("dbee").open()` to open the UI.
- Navigate to the drawer (tree) and use the following key-bindings to perform
    different actions depending on the context (the mappings can all be changed in
    the config):
    - All nodes:
        - Press `o` to toggle the tree node.
        - Press `r` to manually refresh the tree.
    - Connections:
        - Press `cw` to edit the connection
        - Press `dd` to delete it (if source supports saving, it’s also removed from there - see more
            below.)
        - Press `<CR>` to perform an action - view history or look at helper queries. Pressing `<CR>`
            directly on the connection node will set it as the active one
    - Scratchpads:
        - Press `<CR>` on the `new` node to create a new scratchpad.
        - When you try to save it to disk (`:w`), the path is automatically filled for you. You can
            change the name to anything you want, if you save it to the suggested directory, it will load
            the next time you open DBee.
        - Press `cw` to rename the scratchpad.
        - Press `dd` to delete it (also from disk).
        - Pressing `<CR>` on an existing scratchpad in the drawer will open it in the editor pane.
    - Help:
        - Just view the key bindings.
- Once you selected the connection and created a scratchpad, you can navigate to
    the editor pane (top-right by default) and start writing queries. In editor
    pane, you can use the following actions:
    - Highlight some text in visual mode and press `BB` - this will run the selected query on the
        active connection.
    - If you press `BB` in normal mode, you run the whole scratchpad on the active connection.
- If the request was successful, the results should appear in the "result" buffer
    (bottom right by default). If the total number of results was lower than the
    `page_size` parameter in config (100 by default), all results should already be
    present. If there are more than `page_size` results, you can "page" through
    them using one of the following:

  -------------------------------------------------------------------------------------
  Navigation using lua script (even if your     Description     Default key mapping
  cursor is outside the result buffer)                        (cursor should be inside
                                                                   result buffer)
  -------------------------------------------- ------------- --------------------------
  require("dbee").api.ui.result_page_next()     Go to next               L
                                                   page      

  require("dbee").api.ui.result_page_prev()      Go to the               H
                                               previous page 

  require("dbee").api.ui.result_page_last()      Go to the               E
                                                 last page   

  require("dbee").api.ui.result_page_first()     Go to the               F
                                                first page   
  -------------------------------------------------------------------------------------
- Once in the "result" buffer, you can yank the results with the following keys:
    - `yaj` yank current row as json (or row range in visual mode)
    - `yac` yank current row as CSV (or row range in visual mode)
    - `yaJ` to yank all rows as json
    - `yaC` to yank all rows as CSV
- The current result (of the active connection) can also be saved to a file,
    yank-register or buffer using `require("dbee").store()` lua function or `:Dbee
    store` Ex command. Here are some examples:
    >lua
        -- All rows as CSV to current buffer:
        require("dbee").store("csv", "buffer", { extra_arg = 0 })
        -- Results from row 2 to row 7 as json to file (index is zero based):
        require("dbee").store("json", "file", { from = 2, to = 7, extra_arg = "path/to/file.json"  })
        -- Yank the first row as table
        require("dbee").store("table", "yank", { from = 0, to = 1 })
        -- Yank the last 2 rows as CSV
        -- (negative indices are interpreted as length+1+index - same as nvim_buf_get_lines())
        -- Be aware that using negative indices requires for the
        -- iterator of the result to be drained completely, which might affect large result sets.
        require("dbee").store("csv", "yank", { from = -3, to = -1 })
    <
- Once you are done or you want to go back to where you were, you can call
    `require("dbee").close()`.


SPECIFYING CONNECTIONS ~

Connection represents an instance of the database client (i.e. one database).
This is how it looks like:

>lua
    {
      id = "optional_identifier" -- only mandatory if you edit a file by hand. IT'S YOUR JOB TO KEEP THESE UNIQUE!
      name = "My Database",
      type = "sqlite", -- type of database driver
      url = "~/path/to/mydb.db",
    }
<

The connections are loaded to dbee using so-called "sources". They can be added
to dbee using the `setup()` function:

>lua
      require("dbee").setup {
        sources = {
          require("dbee.sources").MemorySource:new({
            {
              name = "...",
              type = "...",
              url = "...",
            },
            -- ...
          }),
          require("dbee.sources").EnvSource:new("DBEE_CONNECTIONS"),
          require("dbee.sources").FileSource:new(vim.fn.stdpath("cache") .. "/dbee/persistence.json"),
        },
        -- ...
      },
<

The above sources are just built-ins. Here is a short description of them:

- `MemorySource` just loads the connections you give it as an argument.
- `EnvSource` loads connection from an environment variable Just export the
    variable you gave to the loader and you are good to go:
    >sh
          export DBEE_CONNECTIONS='[
              {
                  "name": "DB from env",
                  "url": "username:password@tcp(host)/database-name",
                  "type": "mysql"
              }
          ]'
    <
- `FileSource` loads connections from a given json file. It also supports editing
    and adding connections interactively

If the source supports saving and editing you can add connections manually
using the "add" item in the drawer. Fill in the values and write the buffer
(`:w`) to save the connection. By default, this will save the connection to the
global connections file and will persist over restarts (because default
`FileSource` supports saving)

Another option is to use "edit" item in the tree and just edit the source
manually.

If you aren’t satisfied with the default capabilities, you can implement your
own source. You just need to fill the `Source` interface and pass it to config
at setup (`:h dbee.sources`).


SECRETS

If you don’t want to have secrets laying around your disk in plain text, you
can use the special placeholders in connection strings (this works using any
method for specifying connections).

Each connection parameter is passed through go templating engine, which has two
available functions:

- `env` for retrieving environment variables and
- `exec` for evaluating shell commands.

The template syntax for functions is the following: `{{ <func> "<param>" }}`.
If you are dealing with json, you need to escape double quotes, so it’s
sometimes better to use backticks instead (`{{ <func> `<param>` }}`).

Example:

Using the `DBEE_CONNECTIONS` environment variable for specifying connections
and exporting secrets to environment:

>sh
    # Define connections
    export DBEE_CONNECTIONS='[
        {
            "name": "{{ exec `echo Hidden Database` }}",
            "url": "postgres://{{ env \"SECRET_DB_USER\" }}:{{ env `SECRET_DB_PASS` }}@localhost:5432/{{ env `SECRET_DB_NAME` }}?sslmode=disable",
            "type": "postgres"
        }
    ]'
    
    # Export secrets
    export SECRET_DB_NAME="secretdb"
    export SECRET_DB_USER="secretuser"
    export SECRET_DB_PASS="secretpass"
<

If you start neovim in the same shell, this will evaluate to the following
connection:

>lua
    { {
      name = "Hidden Database",
      url = "postgres://secretuser:secretpass@localhost:5432/secretdb?sslmode=disable",
      type = "postgres",
    } }
<


API                                                     *dbee-neovim-dbee-api*

Dbee comes with it’s own API interface. It is split into two parts:

- core (interacting with core of the plugin),
- ui (interacting with ui of the plugin).

You can access it like this:

>lua
    require("dbee").api.core.some_func()
    require("dbee").api.ui.some_func()
<


EXTENSIONS                                       *dbee-neovim-dbee-extensions*

- `nvim-projector` <https://github.com/kndndrj/nvim-projector> To use dbee with
    projector, use this extension <https://github.com/kndndrj/projector-dbee>.
- `nvim-cmp` <https://github.com/hrsh7th/nvim-cmp> Here
    <https://github.com/MattiasMTS/cmp-dbee>, a completion plugin with dbee
    support.


==============================================================================
2. DBee Architecture Overview                *dbee-dbee-architecture-overview*

The plugin is created from 2 parts:

- Go backend that interacts with databases,
- Lua frontend which wraps the backend with neat nvim integration.

These two parts should have clearly defined borders and not "leak"
responsibilities.


LUA ARCHITECTURE            *dbee-dbee-architecture-overview-lua-architecture*

The following diagram shows a high level overview of lua packages. Note that a
lot of connections are removed for diagram clarity.

>
                                            ui
                                        ┌──────────┐
                                 ┌─────►│ Result   ├──────┐
                                 │      └──────────┘      │
                                 │                        │
                                 │      ┌──────────┐      │
                                 ├─────►│ Editor   ├──────┤        core
    ┌──────────┐   ┌──────────┐  │      └──────────┘      │     ┌──────────┐
    │ API      ├──►│ entry    ├──┤                        ├────►│ Handler  ├───► Go
    └──────────┘   └──────────┘  │      ┌──────────┐      │     └──────────┘
                                 ├─────►│ Drawer   ├──────┤
                                 │      └──────────┘      │
                                 │                        │
                                 │      ┌──────────┐      │
                                 └─────►│ Call Log ├──────┘
                                        └──────────┘
    
                   ┌──────────┐   ┌──────────┐
                   │ sources  │   │ layouts  │
                   └──────────┘   └──────────┘
                   ┌──────────┐
                   │ install  │
                   └──────────┘
<

Description:

- The "dbee" package consists of 2 major functional packages, ui and handler
    (core).
    - `handler` or core package is a wrapper around the go backend handler. The only extra thing lua
        handler does on top is information about sources.
    - `ui` package consists of the following packages:
        - `Drawer` represents the tree view. It uses the handler and editor to provide the view of
            connections and notes.
        - `Editor` represents the notepad view. It manages notes per namespace (namespace is an
            arbitrary name - Drawer uses it to have connection-local notes).
        - `Result` represents the results view.
        - `Call Log` represents the history of calls vie view and supports managing past calls.
- `install` package is independent of the other packages and is used for
    installation of the compiled go binary using the manifest generated by the CI
    pipeline.
- `sources` package holds an implementation of some of the most common sources.
- `layouts` package holds the implementation of the default window layout.


GO ARCHITECTURE              *dbee-dbee-architecture-overview-go-architecture*

As We said, the Go backend is accessed exclusively through `handler` in lua.
The way the communication workd both ways is that lua can call the handler
method directly and go triggers events that lua then listens to.

An example of this event based message passing is executing a query on
connection:

- lua registers an event listener to display results.
- lua calls go execute method, which returns call details immediately.
- lua then waits for call to yield some results, to display them.

One way of looking at the handler package in go is that it’s just an
implementation specific use case of the `core` go package.


CORE PACKAGE ~

Here is the godoc <https://pkg.go.dev/github.com/kndndrj/nvim-dbee/dbee/core>
of the core package.

Main construct is a `Connection`. It takes the parameters to connect to the
database and an adapter for the database. Adapter is a provider for specific
databases, which can return a database driver and returns common database
queries (helpers).

Then the connection can execute queries using a driver. This procudes a `Call`.
A call represents a single call to the database and holds it’s state.

Database call returns a result, which transforms the iterator returned from
driver to different formats using a formatter.


ADAPTERS PACKAGE

One of the subpackages of core package is `adapters`. It contains
implemetations of multiple database drivers and adapters. One special thing it
does is that it has it’s own method to create a connection. This is done so
that individual adapters can register themselves on startup in their init
functions (so that we can exclude some adapters on certain
architectures/os-es).


BUILDERS PACKAGE

Another subpackage of `core`, which holds convenience functions for creating
some of the most used constructs. An example are multiple implementations of
the `ResultStream` interface.

Generated by panvimdoc <https://github.com/kdheepak/panvimdoc>

vim:tw=78:ts=8:noet:ft=help:norl:



================================================
FILE: lua/dbee.lua
================================================
local install = require("dbee.install")
local api = require("dbee.api")
local config = require("dbee.config")

---@toc dbee.ref.contents

---@mod dbee.ref Dbee Reference
---@brief [[
---Database Client for NeoVim.
---@brief ]]

local dbee = {
  api = {
    core = api.core,
    ui = api.ui,
  },
}

---Setup function.
---Needs to be called before calling any other function.
---@param cfg? Config
function dbee.setup(cfg)
  -- merge with defaults
  local merged = config.merge_with_default(cfg)

  -- validate config
  config.validate(merged)

  api.setup(merged)
end

---Toggle dbee UI.
function dbee.toggle()
  if api.current_config().window_layout:is_open() then
    dbee.close()
  else
    dbee.open()
  end
end

---Open dbee UI. If already opened, reset window layout.
function dbee.open()
  if api.current_config().window_layout:is_open() then
    return api.current_config().window_layout:reset()
  end
  api.current_config().window_layout:open()
end

---Close dbee UI.
function dbee.close()
  if not api.current_config().window_layout:is_open() then
    return
  end
  api.current_config().window_layout:close()
end

---Check if dbee UI is open or not.
---@return boolean
function dbee.is_open()
  return api.current_config().window_layout:is_open()
end

---Execute a query on current connection.
---Convenience wrapper around some api functions that executes a query on
---current connection and pipes the output to result UI.
---@param query string
function dbee.execute(query)
  local conn = api.core.get_current_connection()
  if not conn then
    error("no connection currently selected")
  end

  local call = api.core.connection_execute(conn.id, query)
  api.ui.result_set_call(call)

  dbee.open()
end

---Store currently displayed result.
---Convenience wrapper around some api functions.
---@param format string format of the output -> "csv"|"json"|"table"
---@param output string where to pipe the results -> "file"|"yank"|"buffer"
---@param opts { from: integer, to: integer, extra_arg: any }
function dbee.store(format, output, opts)
  local call = api.ui.result_get_call()
  if not call then
    error("no current call to store")
  end

  api.core.call_store_result(call.id, format, output, opts)
end

---Supported install commands.
---@alias install_command
---| '"wget"'
---| '"curl"'
---| '"bitsadmin"'
---| '"go"'
---| '"cgo"'

---Install dbee backend binary.
---@param command? install_command Preffered install command
---@see install_command
function dbee.install(command)
  install.exec(command)
end

return dbee



================================================
FILE: lua/dbee/config.lua
================================================
local config = {}

---@mod dbee.ref.config Dbee Configuration

-- Configuration object.
---@class Config
---@field default_connection? string
---@field sources? Source[] list of connection sources
---@field extra_helpers? table<string, table<string, string>>
---@field float_options? table<string, any>
---@field drawer? drawer_config
---@field editor? editor_config
---@field result? result_config
---@field call_log? call_log_config
---@field window_layout? Layout

---@class Candy
---@field icon string
---@field icon_highlight string
---@field text_highlight string

---Keymap options.
---@alias key_mapping { key: string, mode: string, opts: table, action: string|fun() }

---@divider -

---Configuration for result UI tile.
---@alias result_config { focus_result: boolean, mappings: key_mapping[], page_size: integer, progress: progress_config, window_options: table<string, any>, buffer_options: table<string, any> }

---Configuration for editor UI tile.
---@alias editor_config { directory: string, mappings: key_mapping[], window_options: table<string, any>, buffer_options: table<string, any> }

---Configuration for call log UI tile.
---@alias call_log_config { mappings: key_mapping[], disable_candies: boolean, candies: table<string, Candy>, window_options: table<string, any>, buffer_options: table<string, any> }

---Configuration for drawer UI tile.
---@alias drawer_config { disable_candies: boolean, candies: table<string, Candy>, mappings: key_mapping[], disable_help: boolean, window_options: table<string, any>, buffer_options: table<string, any> }

---@divider -

-- DOCGEN_START
---Default configuration.
---To see defaults, run :lua= require"dbee.config".default
---@type Config config
config.default = {
  -- you can specify an optional default connection id and it will be the active one
  -- when dbee starts
  default_connection = nil,
  -- loads connections from files and environment variables
  sources = {
    require("dbee.sources").EnvSource:new("DBEE_CONNECTIONS"),
    require("dbee.sources").FileSource:new(vim.fn.stdpath("state") .. "/dbee/persistence.json"),
  },
  -- extra table helpers per connection type
  -- every helper value is a go-template with values set for
  -- "Table", "Schema" and "Materialization"
  extra_helpers = {
    -- example:
    -- ["postgres"] = {
    --   ["List All"] = "select * from {{ .Table }}",
    -- },
  },
  -- options passed to floating windows - :h nvim_open_win()
  float_options = {},

  -- drawer window config
  drawer = {
    -- these two option settings can be added to all UI elements and
    -- allow for passing specific window/buffer options.
    -- Note that you probably shouldn't be passing buffer options, since
    -- the functionality of the plugin might rely on them.
    -- TL;DR: only use this if you know what you are doing!
    window_options = {},
    buffer_options = {},

    -- show help or not
    disable_help = false,
    -- mappings for the buffer
    mappings = {
      -- manually refresh drawer
      { key = "r", mode = "n", action = "refresh" },
      -- actions perform different stuff depending on the node:
      -- action_1 opens a note or executes a helper
      { key = "<CR>", mode = "n", action = "action_1" },
      -- action_2 renames a note or sets the connection as active manually
      { key = "cw", mode = "n", action = "action_2" },
      -- action_3 deletes a note or connection (removes connection from the file if you configured it like so)
      { key = "dd", mode = "n", action = "action_3" },
      -- these are self-explanatory:
      -- { key = "c", mode = "n", action = "collapse" },
      -- { key = "e", mode = "n", action = "expand" },
      { key = "o", mode = "n", action = "toggle" },
      -- mappings for menu popups:
      { key = "<CR>", mode = "n", action = "menu_confirm" },
      { key = "y", mode = "n", action = "menu_yank" },
      { key = "<Esc>", mode = "n", action = "menu_close" },
      { key = "q", mode = "n", action = "menu_close" },
    },
    -- icon settings:
    disable_candies = false,
    candies = {
      -- these are what's available for now:
      history = {
        icon = "",
        icon_highlight = "Constant",
        text_highlight = "",
      },
      note = {
        icon = "",
        icon_highlight = "Character",
        text_highlight = "",
      },
      connection = {
        icon = "󱘖",
        icon_highlight = "SpecialChar",
        text_highlight = "",
      },
      database_switch = {
        icon = "",
        icon_highlight = "Character",
        text_highlight = "",
      },
      schema = {
        icon = "",
        icon_highlight = "Removed",
        text_highlight = "",
      },
      table = {
        icon = "",
        icon_highlight = "Conditional",
        text_highlight = "",
      },
      streaming_table = {
        icon = "",
        icon_highlight = "Conditional",
        text_highlight = "",
      },
      managed = {
        icon = "",
        icon_highlight = "Conditional",
        text_highlight = "",
      },
      view = {
        icon = "",
        icon_highlight = "Debug",
        text_highlight = "",
      },
      materialized_view = {
        icon = "",
        icon_highlight = "Type",
        text_highlight = "",
      },
      sink = {
        icon = "",
        icon_highlight = "String",
        text_highlight = "",
      },
      column = {
        icon = "󰠵",
        icon_highlight = "WarningMsg",
        text_highlight = "",
      },
      add = {
        icon = "",
        icon_highlight = "String",
        text_highlight = "String",
      },
      edit = {
        icon = "󰏫",
        icon_highlight = "Directory",
        text_highlight = "Directory",
      },
      remove = {
        icon = "󰆴",
        icon_highlight = "SpellBad",
        text_highlight = "SpellBad",
      },
      help = {
        icon = "󰋖",
        icon_highlight = "Title",
        text_highlight = "Title",
      },
      source = {
        icon = "󰃖",
        icon_highlight = "MoreMsg",
        text_highlight = "MoreMsg",
      },

      -- if there is no type
      -- use this for normal nodes...
      none = {
        icon = " ",
        icon_highlight = "",
        text_highlight = "",
      },
      -- ...and use this for nodes with children
      none_dir = {
        icon = "",
        icon_highlight = "NonText",
        text_highlight = "",
      },

      -- chevron icons for expanded/closed nodes
      node_expanded = {
        icon = "",
        icon_highlight = "NonText",
        text_highlight = "",
      },
      node_closed = {
        icon = "",
        icon_highlight = "NonText",
        text_highlight = "",
      },
    },
  },

  -- results window config
  result = {
    -- see drawer comment.
    window_options = {},
    buffer_options = {},

    -- number of rows in the results set to display per page
    page_size = 100,

    -- whether to focus the result window after a query
    focus_result = true,

    -- progress (loading) screen options
    progress = {
      -- spinner to use in progress display
      spinner = { "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" },
      -- prefix to display before the timer
      text_prefix = "Executing...",
    },

    -- mappings for the buffer
    mappings = {
      -- next/previous page
      { key = "L", mode = "", action = "page_next" },
      { key = "H", mode = "", action = "page_prev" },
      { key = "E", mode = "", action = "page_last" },
      { key = "F", mode = "", action = "page_first" },
      -- yank rows as csv/json
      { key = "yaj", mode = "n", action = "yank_current_json" },
      { key = "yaj", mode = "v", action = "yank_selection_json" },
      { key = "yaJ", mode = "", action = "yank_all_json" },
      { key = "yac", mode = "n", action = "yank_current_csv" },
      { key = "yac", mode = "v", action = "yank_selection_csv" },
      { key = "yaC", mode = "", action = "yank_all_csv" },

      -- cancel current call execution
      { key = "<C-c>", mode = "", action = "cancel_call" },
    },
  },

  -- editor window config
  editor = {
    -- see drawer comment.
    window_options = {},
    buffer_options = {},

    -- directory where to store the scratchpads.
    --directory = "path/to/scratchpad/dir",

    -- mappings for the buffer
    mappings = {
      -- run what's currently selected on the active connection
      { key = "BB", mode = "v", action = "run_selection" },
      -- run the whole file on the active connection
      { key = "BB", mode = "n", action = "run_file" },
      -- run what's under the cursor to the next newline
      { key = "<CR>", mode = "n", action = "run_under_cursor" },
    },
  },

  -- call log window config
  call_log = {
    -- see drawer comment.
    window_options = {},
    buffer_options = {},

    -- mappings for the buffer
    mappings = {
      -- show the result of the currently selected call record
      { key = "<CR>", mode = "", action = "show_result" },
      -- cancel the currently selected call (if its still executing)
      { key = "<C-c>", mode = "", action = "cancel_call" },
    },

    -- candies (icons and highlights)
    disable_candies = false,
    candies = {
      -- all of these represent call states
      unknown = {
        icon = "", -- this or first letters of state
        icon_highlight = "NonText", -- highlight of the state
        text_highlight = "", -- highlight of the rest of the line
      },
      executing = {
        icon = "󰑐",
        icon_highlight = "Constant",
        text_highlight = "Constant",
      },
      executing_failed = {
        icon = "󰑐",
        icon_highlight = "Error",
        text_highlight = "",
      },
      retrieving = {
        icon = "",
        icon_highlight = "String",
        text_highlight = "String",
      },
      retrieving_failed = {
        icon = "",
        icon_highlight = "Error",
        text_highlight = "",
      },
      archived = {
        icon = "",
        icon_highlight = "Title",
        text_highlight = "",
      },
      archive_failed = {
        icon = "",
        icon_highlight = "Error",
        text_highlight = "",
      },
      canceled = {
        icon = "",
        icon_highlight = "Error",
        text_highlight = "",
      },
    },
  },

  -- window layout
  window_layout = require("dbee.layouts").Default:new(),
}
-- DOCGEN_END

-- Validates provided input config
---@package
---@param cfg Config
function config.validate(cfg)
  vim.validate {
    sources = { cfg.sources, "table" },
    extra_helpers = { cfg.extra_helpers, "table" },
    float_options = { cfg.float_options, "table" },

    drawer_disable_candies = { cfg.drawer.disable_candies, "boolean" },
    drawer_disable_help = { cfg.drawer.disable_help, "boolean" },
    drawer_candies = { cfg.drawer.candies, "table" },
    drawer_mappings = { cfg.drawer.mappings, "table" },
    result_page_size = { cfg.result.page_size, "number" },
    result_progress = { cfg.result.progress, "table" },
    result_mappings = { cfg.result.mappings, "table" },
    editor_mappings = { cfg.editor.mappings, "table" },
    call_log_mappings = { cfg.call_log.mappings, "table" },

    window_layout = { cfg.window_layout, "table" },
    window_layout_open = { cfg.window_layout.open, "function" },
    window_layout_is_open = { cfg.window_layout.is_open, "function" },
    window_layout_close = { cfg.window_layout.close, "function" },
  }
end

-- Merges changes from config on top of default config.
-- Keys settings provided via arguments take precedence.
---@package
---@param changes? Config
---@return Config
function config.merge_with_default(changes)
  changes = changes or {}

  -- merge basic settings
  ---@type Config
  local merged = vim.tbl_deep_extend("force", config.default, changes)

  -- classes need some extra love (frustrating, I know)
  if changes.sources and #changes.sources > 0 then
    merged.sources = changes.sources
  end
  if changes.window_layout then
    merged.window_layout = changes.window_layout
  end

  return merged
end

return config



================================================
FILE: lua/dbee/doc.lua
================================================
---@mod dbee.ref.types Types
---@brief [[
---Overview of types used in DBee API.
---@brief ]]

---@divider -
---@tag dbee.ref.types.table
---@brief [[
---Table related types
---@brief ]]

---Table column
---@class Column
---@field name string name of the column
---@field type string database type of the column

---Table Materialization.
---@alias materialization
---| '"table"'
---| '"view"'

---Options for gathering table specific info.
---@class TableOpts
---@field table string
---@field schema string
---@field materialization materialization

---Table helpers queries by name.
---@alias table_helpers table<string, string>

---@divider -
---@tag dbee.ref.types.call
---@brief [[
---Call related types.
---@brief ]]

---ID of a call.
---@alias call_id string

---State of a call.
---@alias call_state
---| '"unknown"'
---| '"executing"'
---| '"executing_failed"'
---| '"retrieving"'
---| '"retrieving_failed"'
---| '"archived"'
---| '"archive_failed"'
---| '"canceled"'

---Details and stats of a single call to database.
---@class CallDetails
---@field id call_id
---@field time_taken_us integer duration (time period) in microseconds
---@field query string
---@field state call_state
---@field timestamp_us integer time in microseconds
---@field error? string error message in case of error

---@divider -
---@tag dbee.ref.types.connection
---@brief [[
---Connection related types.
---@brief ]]

---ID of a connection.
---@alias connection_id string

---Parameters of a connection.
---@class ConnectionParams
---@field id connection_id
---@field name string
---@field type string
---@field url string

---@divider -
---@tag dbee.ref.types.structure
---@brief [[
---Database structure related types.
---@brief ]]

---Type of node in database structure.
---@alias structure_type
---| '""'
---| '"table"'
---| '"history"'
---| '"database_switch"'
---| '"view"'

---Structure of database.
---@class DBStructure
---@field name string display name
---@field type structure_type type of node in structure
---@field schema string? parent schema
---@field children DBStructure[]? child layout nodes

---@divider -
---@tag dbee.ref.types.events
---@brief [[
---Event related types.
---@brief ]]

---Avaliable core events.
---@alias core_event_name
---| '"call_state_changed"' {call}
---| '"current_connection_changed"' {conn_id}
---| '"database_selected"' {conn_id, database_name}

---Available editor events.
---@alias editor_event_name
---| '"note_state_changed"' {note_id}
---| '"note_removed"' {note_id}
---| '"note_created"' {note_id}
---| '"current_note_changed"' {note_id}

---Event handler function.
---@alias event_listener fun(data: any)

local M = {}
return M



================================================
FILE: lua/dbee/health.lua
================================================
local install = require("dbee.install")

local M = {}

---@param cmd string
---@return string
local function run_cmd(cmd)
  local handle = assert(io.popen(cmd))
  local result = handle:read("*all")
  handle:close()

  return string.gsub(result, "\n", "") or ""
end

---@return string _ path of git repo
local function repo()
  local p, _ = debug.getinfo(1).source:sub(2):gsub("/lua/dbee/health.lua$", "/")
  return p
end

-- Gets a git hash from which the go binary is compiled.
---@return string
local function get_go_hash()
  return run_cmd(string.format("%s -version", install.bin()))
end

-- Gets currently checked out git hash.
---@return string
local function get_current_hash()
  return run_cmd(string.format("git -C %q rev-parse HEAD", repo()))
end

-- Gets git hash of the install manifest
---@return string
local function get_manifest_hash()
  return install.version()
end

function M.check()
  vim.health.start("DBee report")

  if vim.fn.executable(install.bin()) ~= 1 then
    vim.health.error("Binary not executable: " .. install.bin() .. ".")
    return
  end

  if vim.fn.executable("git") ~= 1 then
    vim.health.warn("Git not installed -- could not determine binary version.")
    return
  end

  local go_hash = get_go_hash()
  local current_hash = get_current_hash()
  local manifest_hash = get_manifest_hash()

  if go_hash == "unknown" then
    vim.health.error("Could not determine binary version.")
    return
  end

  if go_hash == current_hash then
    vim.health.ok("Binary version matches version of current HEAD.")
    return
  elseif go_hash == manifest_hash then
    vim.health.ok("Binary version matches version of install manifest.")
    return
  end

  vim.health.error(
    string.format(
      "Binary version %q doesn't match either:\n  - current hash: %q or\n  - hash of install manifest %q.",
      go_hash,
      current_hash,
      manifest_hash
    )
  )
end

return M



================================================
FILE: lua/dbee/sources.lua
================================================
local utils = require("dbee.utils")

---@mod dbee.ref.sources Sources
---@brief [[
---Sources can be created by implementing the Source interface.
---Some methods are optional and are related to updating/editing functionality.
---@brief ]]

---ID of a source.
---@alias source_id string

---Source interface
---"name" and "load" methods are mandatory for basic functionality.
---"create", "update" and "delete" methods are optional and provide interactive CRUD.
---"file" method is used for providing optional manual edits of the source's file.
---A source is also in charge of managing ids of connections. A connection parameter without
---a unique id results in an error or undefined behavior.
---@class Source
---@field name fun(self: Source):string function to return the name of the source
---@field load fun(self: Source):ConnectionParams[] function to load connections from external source
---@field create? fun(self: Source, details: ConnectionParams):connection_id create a connection and return its id (optional)
---@field delete? fun(self: Source, id: connection_id) delete a connection from its id (optional)
---@field update? fun(self: Source, id: connection_id, details: ConnectionParams) update provided connection (optional)
---@field file? fun(self: Source):string function which returns a source file to edit (optional)

local sources = {}

---@divider -

---Built-In File Source.
---@class FileSource: Source
---@field private path string path to file
sources.FileSource = {}

--- Loads connections from json file
---@param path string path to file
---@return Source
function sources.FileSource:new(path)
  if not path then
    error("no path provided")
  end
  local o = {
    path = path,
  }
  setmetatable(o, self)
  self.__index = self
  return o
end

---@package
---@return string
function sources.FileSource:name()
  return vim.fs.basename(self.path)
end

---@package
---@return ConnectionParams[]
function sources.FileSource:load()
  local path = self.path

  ---@type ConnectionParams[]
  local conns = {}

  if not vim.loop.fs_stat(path) then
    return {}
  end

  local lines = {}
  for line in io.lines(path) do
    if not vim.startswith(vim.trim(line), "//") then
      table.insert(lines, line)
    end
  end

  local contents = table.concat(lines, "\n")
  local ok, data = pcall(vim.fn.json_decode, contents)
  if not ok then
    error('Could not parse json file: "' .. path .. '".')
    return {}
  end

  for _, conn in pairs(data) do
    if type(conn) == "table" then
      table.insert(conns, conn)
    end
  end

  return conns
end

---@package
---@param conn ConnectionParams
---@return connection_id
function sources.FileSource:create(conn)
  local path = self.path

  if not conn or vim.tbl_isempty(conn) then
    error("cannot create an empty connection")
  end

  -- read from file
  local existing = self:load()

  conn.id = "file_source_/" .. utils.random_string()
  table.insert(existing, conn)

  -- write back to file
  local ok, json = pcall(vim.fn.json_encode, existing)
  if not ok then
    error("could not convert connection list to json")
  end

  -- overwrite file
  local file = assert(io.open(path, "w+"), "could not open file")
  file:write(json)
  file:close()

  return conn.id
end

---@package
---@param id connection_id
function sources.FileSource:delete(id)
  local path = self.path

  if not id or id == "" then
    error("no id passed to delete function")
  end

  -- read from file
  local existing = self:load()

  local new = {}
  for _, ex in ipairs(existing) do
    if ex.id ~= id then
      table.insert(new, ex)
    end
  end

  -- write back to file
  local ok, json = pcall(vim.fn.json_encode, new)
  if not ok then
    error("could not convert connection list to json")
    return
  end

  -- overwrite file
  local file = assert(io.open(path, "w+"), "could not open file")
  file:write(json)
  file:close()
end

---@package
---@param id connection_id
---@param details ConnectionParams
function sources.FileSource:update(id, details)
  local path = self.path

  if not id or id == "" then
    error("no id passed to update function")
  end

  if not details or vim.tbl_isempty(details) then
    error("cannot create an empty connection")
  end

  -- read from file
  local existing = self:load()

  for _, ex in ipairs(existing) do
    if ex.id == id then
      ex.name = details.name
      ex.url = details.url
      ex.type = details.type
    end
  end

  -- write back to file
  local ok, json = pcall(vim.fn.json_encode, existing)
  if not ok then
    error("could not convert connection list to json")
    return
  end

  -- overwrite file
  local file = assert(io.open(path, "w+"), "could not open file")
  file:write(json)
  file:close()
end

---@package
---@return string
function sources.FileSource:file()
  return self.path
end

---@divider -

---Built-In Env Source.
---Loads connections from json string of env variable.
---@class EnvSource: Source
---@field private var string path to file
sources.EnvSource = {}

---@param var string env var to load connections from
---@return Source
function sources.EnvSource:new(var)
  if not var then
    error("no path provided")
  end
  local o = {
    var = var,
  }
  setmetatable(o, self)
  self.__index = self
  return o
end

---@package
---@return string
function sources.EnvSource:name()
  return self.var
end

---@package
---@return ConnectionParams[]
function sources.EnvSource:load()
  ---@type ConnectionParams[]
  local conns = {}

  local raw = os.getenv(self.var)
  if not raw then
    return {}
  end

  local ok, data = pcall(vim.fn.json_decode, raw)
  if not ok then
    error('Could not parse connections from env: "' .. self.var .. '".')
    return {}
  end

  for i, conn in pairs(data) do
    if type(conn) == "table" and conn.url and conn.type then
      conn.id = conn.id or ("environment_source_" .. self.var .. "_" .. i)
      table.insert(conns, conn)
    end
  end

  return conns
end

---@divider -

---Built-In Memory Source.
---Loads connections from lua table.
---@class MemorySource: Source
---@field private conns ConnectionParams[]
---@field private display_name string
sources.MemorySource = {}

---@param conns ConnectionParams[] list of connections
---@param name? string optional display name
---@return Source
function sources.MemorySource:new(conns, name)
  name = name or "memory"

  local parsed = {}
  for i, conn in pairs(conns or {}) do
    if type(conn) == "table" and conn.url and conn.type then
      conn.id = "memory_source_" .. name .. i
      table.insert(parsed, conn)
    end
  end

  local o = {
    conns = parsed,
    display_name = name,
  }
  setmetatable(o, self)
  self.__index = self
  return o
end

---@package
---@return string
function sources.MemorySource:name()
  return self.display_name
end

---@package
---@return ConnectionParams[]
function sources.MemorySource:load()
  return self.conns
end

return sources



================================================
FILE: lua/dbee/utils.lua
================================================
local M = {}

-- private variable with registered onces
---@type table<string, boolean>
local used_onces = {}

---@param id string unique id of this singleton bool
---@return boolean
function M.once(id)
  id = id or ""

  if used_onces[id] then
    return false
  end

  used_onces[id] = true

  return true
end

-- Get cursor range of current selection
---@return integer start row
---@return integer start column
---@return integer end row
---@return integer end column
function M.visual_selection()
  -- return to normal mode ('< and '> become available only after you exit visual mode)
  local key = vim.api.nvim_replace_termcodes("<esc>", true, false, true)
  vim.api.nvim_feedkeys(key, "x", false)

  local _, srow, scol, _ = unpack(vim.fn.getpos("'<"))
  local _, erow, ecol, _ = unpack(vim.fn.getpos("'>"))
  if ecol > 200000 then
    ecol = 20000
  end
  if srow < erow or (srow == erow and scol <= ecol) then
    return srow - 1, scol - 1, erow - 1, ecol
  else
    return erow - 1, ecol - 1, srow - 1, scol
  end
end

---@param level "info"|"warn"|"error"
---@param message string
---@param subtitle? string
function M.log(level, message, subtitle)
  -- log level
  local l = vim.log.levels.OFF
  if level == "info" then
    l = vim.log.levels.INFO
  elseif level == "warn" then
    l = vim.log.levels.WARN
  elseif level == "error" then
    l = vim.log.levels.ERROR
  end

  -- subtitle
  if subtitle then
    subtitle = "[" .. subtitle .. "]:"
  else
    subtitle = ""
  end
  vim.notify(subtitle .. " " .. message, l, { title = "nvim-dbee" })
end

-- Gets keys of a map and sorts them by name
---@param obj table<string, any> map-like table
---@return string[]
function M.sorted_keys(obj)
  local keys = {}
  for k, _ in pairs(obj) do
    table.insert(keys, k)
  end
  table.sort(keys)
  return keys
end

-- create an autocmd that is associated with a window rather than a buffer.
---@param events string[]
---@param winid integer
---@param opts table<string, any>
local function create_window_autocmd(events, winid, opts)
  opts = opts or {}
  if not events or not winid or not opts.callback then
    return
  end

  local cb = opts.callback

  opts.callback = function(event)
    -- remove autocmd if window is closed
    if not vim.api.nvim_win_is_valid(winid) then
      vim.api.nvim_del_autocmd(event.id)
      return
    end

    local wid = vim.fn.bufwinid(event.buf or -1)
    if wid ~= winid then
      return
    end
    cb(event)
  end

  vim.api.nvim_create_autocmd(events, opts)
end

-- create an autocmd just once in a single place in code.
-- If opts hold a "window" key, autocmd is defined per window rather than a buffer.
-- If window and buffer are provided, this results in an error.
---@param events string[] events list as defined in nvim api
---@param opts table<string, any> options as in api
function M.create_singleton_autocmd(events, opts)
  if opts.window and opts.buffer then
    error("cannot register autocmd for buffer and window at the same time")
  end

  local caller_info = debug.getinfo(2)
  if not caller_info or not caller_info.name or not caller_info.currentline then
    error("could not determine function caller")
  end

  if
    not M.once(
      "autocmd_singleton_"
        .. caller_info.name
        .. caller_info.currentline
        .. tostring(opts.window)
        .. tostring(opts.buffer)
    )
  then
    -- already configured
    return
  end

  if opts.window then
    local window = opts.window
    opts.window = nil
    create_window_autocmd(events, window, opts)
    return
  end

  vim.api.nvim_create_autocmd(events, opts)
end

local random_charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"

--- Generate a random string
---@return string _ random string of 10 characters
function M.random_string()
  local function r(length)
    if length < 1 then
      return ""
    end

    local i = math.random(1, #random_charset)
    return r(length - 1) .. random_charset:sub(i, i)
  end

  return r(10)
end

--- Get the SQL statement under the cursor and its range (using treesitter).
--- Potential returns are 1. the SQL query, 2. empty string, 3. nil if filetype isn't SQL.
---@param bufnr integer buffer containing the SQL queries.
---@return nil|string query, nil|integer start_row, nil|integer end_row
function M.query_under_cursor(bufnr)
  bufnr = bufnr or vim.api.nvim_get_current_buf()
  local ft = vim.bo[bufnr].filetype
  if ft ~= "sql" then
    return
  end

  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
  local cursor_row = vim.api.nvim_win_get_cursor(0)[1] - 1
  local query = ""
  local start_row, end_row = 0, 0

  -- tmp_buf is a temporary buffer for treesitter to parse the SQL statements
  local tmp_buf = vim.api.nvim_create_buf(false, true)

  -- replace empty lines with semicolons to make sure treesitter parse them
  -- as statement (still supports newlines between CTEs)
  local content = vim.tbl_map(function(line)
    return line ~= "" and line or ";"
  end, lines)

  vim.api.nvim_buf_set_lines(tmp_buf, 0, -1, false, content)

  local parser = vim.treesitter.get_parser(tmp_buf, "sql", {})
  if not parser then
    vim.api.nvim_buf_delete(tmp_buf, { force = true })
    return query, start_row, end_row
  end

  local root = parser:parse()[1]:root()

  for node in root:iter_children() do
    if node:type() == "statement" then
      local node_start_row, _, node_end_row, _ = node:range()
      if cursor_row >= node_start_row and cursor_row <= node_end_row then
        query = vim.treesitter.get_node_text(node, tmp_buf)
        start_row, end_row = node_start_row, node_end_row
        break
      end
    end
  end

  -- clean up the tmp_buf
  vim.api.nvim_buf_delete(tmp_buf, { force = true })
  return query:gsub(";", ""), start_row, end_row
end

return M



================================================
FILE: lua/dbee/api/__register.lua
================================================
-- This file is automatically generated using "dbee -manifest <file>"
-- DO NOT EDIT!

return function()
  -- Register host
  vim.fn["remote#host#Register"]("nvim_dbee", "x", function()
    return vim.fn.jobstart({ "dbee" }, {
      rpc = true,
      detach = true,
      on_stderr = function(_, data, _)
        for _, line in ipairs(data) do
          print(line)
        end
      end,
    })
  end)

  -- Manifest
  vim.fn["remote#host#RegisterPlugin"]("nvim_dbee", "0", {
    { type = "function", name = "DbeeAddHelpers", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeCallCancel", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeCallDisplayResult", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeCallStoreResult", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeConnectionExecute", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeConnectionGetCalls", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeConnectionGetColumns", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeConnectionGetHelpers", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeConnectionGetParams", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeConnectionGetStructure", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeConnectionListDatabases", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeConnectionSelectDatabase", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeCreateConnection", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeDeleteConnection", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeGetConnections", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeGetCurrentConnection", sync = true, opts = vim.empty_dict() },
    { type = "function", name = "DbeeSetCurrentConnection", sync = true, opts = vim.empty_dict() },
  })
end



================================================
FILE: lua/dbee/api/core.lua
================================================
---@mod dbee.ref.api.core Dbee Core API
---@brief [[
---This module contains functions to operate on the backend side.
---
---Access it like this:
--->
---require("dbee").api.core.func()
---<
---@brief ]]

local state = require("dbee.api.state")

local core = {}

---Returns true if dbee core is loaded.
---@return boolean
function core.is_loaded()
  return state.is_core_loaded()
end

---Registers an event handler for core events.
---@param event core_event_name
---@param listener event_listener
function core.register_event_listener(event, listener)
  state.handler():register_event_listener(event, listener)
end

---Add new source and load connections from it.
---@param source Source
function core.add_source(source)
  state.handler():add_source(source)
end

---Get a list of registered sources.
---@return Source[]
function core.get_sources()
  return state.handler():get_sources()
end

---Reload a source by id.
---@param id source_id
function core.source_reload(id)
  state.handler():source_reload(id)
end

---Add connection to the source.
---In case the source cannot add connections, this call fails.
---@param id source_id
---@param details ConnectionParams
---@return connection_id
function core.source_add_connection(id, details)
  return state.handler():source_add_connection(id, details)
end

---Remove a connection from the source.
---In case the source cannot delete connections, this call fails.
---@param id source_id
---@param conn_id connection_id
function core.source_remove_connection(id, conn_id)
  state.handler():source_remove_connection(id, conn_id)
end

---Update an existing connection from the source.
---In case the source cannot edit connections, this call fails.
---@param id source_id
---@param conn_id connection_id
---@param details ConnectionParams
function core.source_update_connection(id, conn_id, details)
  state.handler():source_update_connection(id, conn_id, details)
end

--- Get a list of connections from source.
---@param id source_id
---@return ConnectionParams[]
function core.source_get_connections(id)
  return state.handler():source_get_connections(id)
end

---Register helper queries per database type.
---every helper value is a go-template with values set for
---"Table", "Schema" and "Materialization".
---@param helpers table<string, table<string, string>> extra helpers per type
---@see table_helpers
---@usage lua [[
---{
---  ["postgres"] = {
---    ["List All"] = "SELECT * FROM {{ .Table }}",
---  }
---}
---@usage ]]
function core.add_helpers(helpers)
  state.handler():add_helpers(helpers)
end

---Get helper queries for a specific connection.
---@param id connection_id
---@param opts TableOpts
---@return table<string, string> _ list of table helpers
---@see table_helpers
function core.connection_get_helpers(id, opts)
  return state.handler():connection_get_helpers(id, opts)
end

---Get the currently active connection.
---@return ConnectionParams|nil
function core.get_current_connection()
  return state.handler():get_current_connection()
end

---Set a currently active connection.
---@param id connection_id
function core.set_current_connection(id)
  state.handler():set_current_connection(id)
end

---Execute a query on a connection.
---@param id connection_id
---@param query string
---@return CallDetails
function core.connection_execute(id, query)
  return state.handler():connection_execute(id, query)
end

---Get database structure of a connection.
---@param id connection_id
---@return DBStructure[]
function core.connection_get_structure(id)
  return state.handler():connection_get_structure(id)
end

---Get columns of a table
---@param id connection_id
---@param opts { table: string, schema: string, materialization: string }
---@return Column[]
function core.connection_get_columns(id, opts)
  return state.handler():connection_get_columns(id, opts)
end

---Get parameters that define the connection.
---@param id connection_id
---@return ConnectionParams|nil
function core.connection_get_params(id)
  return state.handler():connection_get_params(id)
end

---List databases of a connection.
---Some databases might not support this - in that case, a call to this
---function returns an error.
---@param id connection_id
---@return string currently selected database
---@return string[] other available databases
function core.connection_list_databases(id)
  return state.handler():connection_list_databases(id)
end

---Select an active database of a connection.
---Some databases might not support this - in that case, a call to this
---function returns an error.
---@param id connection_id
---@param database string
function core.connection_select_database(id, database)
  state.handler():connection_select_database(id, database)
end

---Get a list of past calls of a connection.
---@param id connection_id
---@return CallDetails[]
function core.connection_get_calls(id)
  return state.handler():connection_get_calls(id)
end

---Cancel call execution.
---If call is finished, nothing happens.
---@param id call_id
function core.call_cancel(id)
  state.handler():call_cancel(id)
end

---Display the result of a call formatted as a table in a buffer.
---@param id call_id id of the call
---@param bufnr integer
---@param from integer
---@param to integer
---@return integer total number of rows
function core.call_display_result(id, bufnr, from, to)
  return state.handler():call_display_result(id, bufnr, from, to)
end

---Store the result of a call.
---@param id call_id
---@param format string format of the output -> "csv"|"json"|"table"
---@param output string where to pipe the results -> "file"|"yank"|"buffer"
---@param opts { from: integer, to: integer, extra_arg: any }
function core.call_store_result(id, format, output, opts)
  state.handler():call_store_result(id, format, output, opts)
end

return core



================================================
FILE: lua/dbee/api/init.lua
================================================
return {
  core = require("dbee.api.core"),
  ui = require("dbee.api.ui"),
  setup = require("dbee.api.state").setup,
  current_config = require("dbee.api.state").config,
}



================================================
FILE: lua/dbee/api/state.lua
================================================
local floats = require("dbee.ui.common.floats")
local DrawerUI = require("dbee.ui.drawer")
local EditorUI = require("dbee.ui.editor")
local ResultUI = require("dbee.ui.result")
local CallLogUI = require("dbee.ui.call_log")
local Handler = require("dbee.handler")
local install = require("dbee.install")
local register = require("dbee.api.__register")

-- public and private module objects
local M = {}
local m = {}

-- is core set up?
m.core_loaded = false
-- is ui set up?
m.ui_loaded = false
-- was setup function called?
m.setup_called = false
---@type Config
m.config = {}

local function setup_handler()
  if m.core_loaded then
    return
  end

  if not m.setup_called then
    error("setup() has not been called yet")
  end

  -- register remote plugin
  register()

  -- add install binary to path
  local pathsep = ":"
  if vim.fn.has("win32") == 1 then
    pathsep = ";"
  end
  vim.env.PATH = install.dir() .. pathsep .. vim.env.PATH

  m.handler = Handler:new(m.config.sources)
  m.handler:add_helpers(m.config.extra_helpers)

  -- activate default connection if present
  if m.config.default_connection then
    pcall(m.handler.set_current_connection, m.handler, m.config.default_connection)
  end

  m.core_loaded = true
end

local function setup_ui()
  if m.ui_loaded then
    return
  end

  setup_handler()

  -- configure options for floating windows
  floats.configure(m.config.float_options)

  -- initiate all UI elements
  m.result = ResultUI:new(m.handler, m.config.result)
  m.call_log = CallLogUI:new(m.handler, m.result, m.config.call_log)
  m.editor = EditorUI:new(m.handler, m.result, m.config.editor)
  m.drawer = DrawerUI:new(m.handler, m.editor, m.result, m.config.drawer)

  m.ui_loaded = true
end

---@param cfg Config
function M.setup(cfg)
  if m.setup_called then
    error("setup() can only be called once")
  end
  m.config = cfg

  m.setup_called = true
end

---@return boolean
function M.is_core_loaded()
  return m.core_loaded
end

---@return boolean
function M.is_ui_loaded()
  return m.ui_loaded
end

---@return Handler
function M.handler()
  setup_handler()
  return m.handler
end

---@return EditorUI
function M.editor()
  setup_ui()
  return m.editor
end

---@return CallLogUI
function M.call_log()
  setup_ui()
  return m.call_log
end

---@return DrawerUI
function M.drawer()
  setup_ui()
  return m.drawer
end

---@return ResultUI
function M.result()
  setup_ui()
  return m.result
end

---@return Config
function M.config()
  return m.config
end

return M



================================================
FILE: lua/dbee/api/ui.lua
================================================
---@mod dbee.ref.api.ui Dbee UI API
---@brief [[
---UI API module for nvim dbee.
---
---This module contains functions to operate with UI tiles.
---Functions are prefixed with a ui name:
---- editor
---- result
---- drawer
---- call_log
---
--- Access the module like this:
--->
---require("dbee").api.ui.func()
---<
---@brief ]]

local state = require("dbee.api.state")

local ui = {}

---Returns true if dbee ui is loaded.
---@return boolean
function ui.is_loaded()
  return state.is_ui_loaded()
end

---@divider -
---@tag dbee.ref.api.ui.editor
---@brief [[
---Editor API
---@brief ]]

---Registers an event handler for editor events.
---@param event editor_event_name
---@param listener event_listener
function ui.editor_register_event_listener(event, listener)
  state.editor():register_event_listener(event, listener)
end

--- Search for a note with provided id across namespaces.
---@param id note_id
---@return note_details|nil
---@return namespace_id _ namespace of the note
function ui.editor_search_note(id)
  return state.editor():search_note(id)
end

--- Search for a note with provided buffer across namespaces.
---@param bufnr integer
---@return note_details|nil
---@return namespace_id _ namespace of the note
function ui.editor_search_note_with_buf(bufnr)
  return state.editor():search_note_with_buf(bufnr)
end

--- Search for a note with provided file name across namespaces.
---@param file string
---@return note_details|nil
---@return namespace_id _ namespace of the note
function ui.editor_search_note_with_file(file)
  return state.editor():search_note_with_file(file)
end

--- Creates a new note in namespace.
--- Errors if id or name is nil or there is a note with the same
--- name in namespace already.
---@param id namespace_id
---@param name string
---@return note_id
function ui.editor_namespace_create_note(id, name)
  return state.editor():namespace_create_note(id, name)
end

--- Get notes of a specified namespace.
---@param id namespace_id
---@return note_details[]
function ui.editor_namespace_get_notes(id)
  return state.editor():namespace_get_notes(id)
end

--- Removes an existing note.
--- Errors if there is no note with provided id in namespace.
---@param id namespace_id
---@param note_id note_id
function ui.editor_namespace_remove_note(id, note_id)
  state.editor():namespace_remove_note(id, note_id)
end

--- Renames an existing note.
--- Errors if no name or id provided, there is no note with provided id or
--- there is already an existing note with the same name in the same namespace.
---@param id note_id
---@param name string new name
function ui.editor_note_rename(id, name)
  state.editor():note_rename(id, name)
end

--- Get details of a current note
---@return note_details|nil
function ui.editor_get_current_note()
  return state.editor():get_current_note()
end

--- Sets note with id as the current note
--- and opens it in the window.
---@param id note_id
function ui.editor_set_current_note(id)
  state.editor():set_current_note(id)
end

--- Open the editor UI.
---@param winid integer
function ui.editor_show(winid)
  state.editor():show(winid)
end

--- Trigger an action in editor.
---@param action string
function ui.editor_do_action(action)
  state.editor():do_action(action)
end

---@divider -
---@tag dbee.ref.api.ui.call_log
---@brief [[
---Call Log API
---@brief ]]

--- Refresh the call log.
function ui.call_log_refresh()
  state.call_log():refresh()
end

--- Open the call log UI.
---@param winid integer
function ui.call_log_show(winid)
  state.call_log():show(winid)
end

--- Trigger an action in call_log.
---@param action string
function ui.call_log_do_action(action)
  state.call_log():do_action(action)
end

---@divider -
---@tag dbee.ref.api.ui.drawer
---@brief [[
---Drawer API
---@brief ]]

--- Refresh the drawer.
function ui.drawer_refresh()
  state.drawer():refresh()
end

--- Open the drawer UI.
---@param winid integer
function ui.drawer_show(winid)
  state.drawer():show(winid)
end

--- Trigger an action in drawer.
---@param action string
function ui.drawer_do_action(action)
  state.drawer():do_action(action)
end

---@divider -
---@tag dbee.ref.api.ui.result
---@brief [[
---Result API
---@brief ]]

--- Sets call's result to Result's buffer.
---@param call CallDetails
function ui.result_set_call(call)
  state.result():set_call(call)
end

--- Gets the currently displayed call.
---@return CallDetails|nil
function ui.result_get_call()
  return state.result():get_call()
end

--- Display the currently selected page in results UI.
function ui.result_page_current()
  state.result():page_current()
end

--- Go to next page in results UI and display it.
function ui.result_page_next()
  state.result():page_next()
end

--- Go to previous page in results UI and display it.
function ui.result_page_prev()
  state.result():page_prev()
end

--- Go to last page in results UI and display it.
function ui.result_page_last()
  state.result():page_last()
end

--- Go to first page in results UI and display it.
function ui.result_page_first()
  state.result():page_first()
end

--- Open the result UI.
---@param winid integer
function ui.result_show(winid)
  state.result():show(winid)
end

--- Trigger an action in result.
---@param action string
function ui.result_do_action(action)
  state.result():do_action(action)
end

return ui



================================================
FILE: lua/dbee/handler/__events.lua
================================================
-- This package is used for triggering lua callbacks from go.
-- It uses unique ids to register the callbacks and trigger them.
local M = {}

---@type table<core_event_name, event_listener[]>
local callbacks = {}

---@param event core_event_name event name to register the callback for
---@param cb event_listener callback function - "data" argument type depends on the event
function M.register(event, cb)
  callbacks[event] = callbacks[event] or {}
  table.insert(callbacks[event], cb)
end

---@param event core_event_name
---@param data any
function M.trigger(event, data)
  vim.schedule(function()
    local cbs = callbacks[event] or {}
    for _, cb in ipairs(cbs) do
      cb(data)
    end
  end)
end

return M



================================================
FILE: lua/dbee/handler/init.lua
================================================
local event_bus = require("dbee.handler.__events")
local utils = require("dbee.utils")

-- Handler is an aggregator of connections
---@class Handler
---@field private sources table<source_id, Source>
---@field private source_conn_lookup table<source_id, connection_id[]>
local Handler = {}

---@param sources? Source[]
---@return Handler
function Handler:new(sources)
  -- class object
  local o = {
    sources = {},
    source_conn_lookup = {},
  }
  setmetatable(o, self)
  self.__index = self

  -- initialize the sources
  sources = sources or {}
  for _, source in ipairs(sources) do
    local ok, mes = pcall(o.add_source, o, source)
    if not ok then
      utils.log("error", "failed registering source: " .. source:name() .. " " .. mes, "core")
    end
  end

  return o
end

---@param event core_event_name
---@param listener event_listener
function Handler:register_event_listener(event, listener)
  event_bus.register(event, listener)
end

-- add new source and load connections from it
---@param source Source
function Handler:add_source(source)
  local id = source:name()

  -- keep the old source if present
  self.sources[id] = self.sources[id] or source

  self:source_reload(id)
end

---@return Source[]
function Handler:get_sources()
  local sources = vim.tbl_values(self.sources)
  table.sort(sources, function(k1, k2)
    return k1:name() < k2:name()
  end)
  return sources
end

---Closes old connections of that source
---and loads new ones.
---@param id source_id
function Handler:source_reload(id)
  local source = self.sources[id]
  if not source then
    error("no source with id: " .. id)
  end

  -- close old connections
  for _, c in ipairs(self:source_get_connections(id)) do
    pcall(vim.fn.DbeeDeleteConnection, c.id)
  end

  -- create new ones
  self.source_conn_lookup[id] = {}
  for _, spec in ipairs(source:load()) do
    if not spec.id or spec.id == "" then
      error(
        string.format('connection without an id: { name: "%s", type: %s, url: %s } ', spec.name, spec.type, spec.url)
      )
    end

    local conn_id = vim.fn.DbeeCreateConnection(spec)
    table.insert(self.source_conn_lookup[id], conn_id)
  end
end

---@param id source_id
---@param details ConnectionParams
---@return connection_id
function Handler:source_add_connection(id, details)
  if not details then
    error("no connection details provided")
  end

  local source = self.sources[id]
  if not source then
    error("no source with id: " .. id)
  end

  if type(source.create) ~= "function" then
    error("source does not support adding connections")
  end

  local conn_id = source:create(details)
  self:source_reload(id)

  return conn_id
end

---@param id source_id
---@param conn_id connection_id
function Handler:source_remove_connection(id, conn_id)
  local source = self.sources[id]
  if not source then
    error("no source with id: " .. id)
  end

  if not conn_id or conn_id == "" then
    error("no connection id provided")
  end

  if type(source.delete) ~= "function" then
    error("source does not support removing connections")
  end

  source:delete(conn_id)
  self:source_reload(id)
end

---@param id source_id
---@param conn_id connection_id
---@param details ConnectionParams
function Handler:source_update_connection(id, conn_id, details)
  local source = self.sources[id]
  if not source then
    error("no source with id: " .. id)
  end

  if not conn_id or conn_id == "" then
    error("no connection id provided")
  end

  if not details then
    error("no connection details provided")
  end

  if type(source.update) ~= "function" then
    error("source does not support updating connections")
  end

  source:update(conn_id, details)
  self:source_reload(id)
end

---@param id source_id
---@return ConnectionParams[]
function Handler:source_get_connections(id)
  local conn_ids = self.source_conn_lookup[id] or {}
  if #conn_ids < 1 then
    return {}
  end

  ---@type ConnectionParams[]?
  local ret = vim.fn.DbeeGetConnections(conn_ids)
  if not ret or ret == vim.NIL then
    return {}
  end

  table.sort(ret, function(k1, k2)
    return k1.name < k2.name
  end)

  return ret
end

---@param helpers table<string, table_helpers> extra helpers per type
function Handler:add_helpers(helpers)
  for type, help in pairs(helpers) do
    vim.fn.DbeeAddHelpers(type, help)
  end
end

---@param id connection_id
---@param opts TableOpts
---@return table_helpers helpers list of table helpers
function Handler:connection_get_helpers(id, opts)
  local helpers = vim.fn.DbeeConnectionGetHelpers(id, {
    table = opts.table,
    schema = opts.schema,
    materialization = opts.materialization,
  })
  if not helpers or helpers == vim.NIL then
    return {}
  end

  return helpers
end

---@return ConnectionParams?
function Handler:get_current_connection()
  local ok, ret = pcall(vim.fn.DbeeGetCurrentConnection)
  if not ok or ret == vim.NIL then
    return
  end
  return ret
end

---@param id connection_id
function Handler:set_current_connection(id)
  vim.fn.DbeeSetCurrentConnection(id)
end

---@param id connection_id
---@param query string
---@return CallDetails
function Handler:connection_execute(id, query)
  return vim.fn.DbeeConnectionExecute(id, query)
end

---@param id connection_id
---@return DBStructure[]
function Handler:connection_get_structure(id)
  local ret = vim.fn.DbeeConnectionGetStructure(id)
  if not ret or ret == vim.NIL then
    return {}
  end
  return ret
end

---@param id connection_id
---@param opts { table: string, schema: string, materialization: string }
---@return Column[]
function Handler:connection_get_columns(id, opts)
  local out = vim.fn.DbeeConnectionGetColumns(id, opts)
  if not out or out == vim.NIL then
    return {}
  end

  return out
end

---@param id connection_id
---@return ConnectionParams?
function Handler:connection_get_params(id)
  local ret = vim.fn.DbeeConnectionGetParams(id)
  if not ret or ret == vim.NIL then
    return
  end
  return ret
end

---@param id connection_id
---@return string current_db
---@return string[] available_dbs
function Handler:connection_list_databases(id)
  local ret = vim.fn.DbeeConnectionListDatabases(id)
  if not ret or ret == vim.NIL then
    return "", {}
  end

  return unpack(ret)
end

---@param id connection_id
---@param database string
function Handler:connection_select_database(id, database)
  vim.fn.DbeeConnectionSelectDatabase(id, database)
end

---@param id connection_id
---@return CallDetails[]
function Handler:connection_get_calls(id)
  local ret = vim.fn.DbeeConnectionGetCalls(id)
  if not ret or ret == vim.NIL then
    return {}
  end
  return ret
end

---@param id call_id
function Handler:call_cancel(id)
  vim.fn.DbeeCallCancel(id)
end

---@param id call_id
---@param bufnr integer
---@param from integer
---@param to integer
---@return integer # total number of rows
function Handler:call_display_result(id, bufnr, from, to)
  local length = vim.fn.DbeeCallDisplayResult(id, { buffer = bufnr, from = from, to = to })
  if not length or length == vim.NIL then
    return 0
  end
  return length
end

---@alias store_format "csv"|"json"|"table"
---@alias store_output "file"|"yank"|"buffer"

---@param id call_id
---@param format store_format format of the output
---@param output store_output where to pipe the results
---@param opts { from: integer, to: integer, extra_arg: any }
function Handler:call_store_result(id, format, output, opts)
  opts = opts or {}

  local from = opts.from or 0
  local to = opts.to or -1

  vim.fn.DbeeCallStoreResult(id, format, output, {
    from = from,
    to = to,
    extra_arg = opts.extra_arg,
  })
end

return Handler



================================================
FILE: lua/dbee/install/__manifest.lua
================================================
-- This file is automatically generated using CI pipeline
-- DO NOT EDIT!
local M = {}

-- Links to binary releases
M.urls = {
  ["android/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_android_amd64.tar.gz",
  ["android/arm64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_android_arm64.tar.gz",
  ["darwin/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_darwin_amd64.tar.gz",
  ["darwin/arm64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_darwin_arm64.tar.gz",
  ["dragonfly/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_dragonfly_amd64.tar.gz",
  ["freebsd/386"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_freebsd_386.tar.gz",
  ["freebsd/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_freebsd_amd64.tar.gz",
  ["freebsd/arm"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_freebsd_arm.tar.gz",
  ["freebsd/arm64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_freebsd_arm64.tar.gz",
  ["freebsd/riscv64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_freebsd_riscv64.tar.gz",
  ["illumos/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_illumos_amd64.tar.gz",
  ["linux/386"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_386.tar.gz",
  ["linux/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_amd64.tar.gz",
  ["linux/arm"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_arm.tar.gz",
  ["linux/arm64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_arm64.tar.gz",
  ["linux/loong64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_loong64.tar.gz",
  ["linux/mips64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_mips64.tar.gz",
  ["linux/mips64le"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_mips64le.tar.gz",
  ["linux/ppc64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_ppc64.tar.gz",
  ["linux/ppc64le"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_ppc64le.tar.gz",
  ["linux/riscv64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_riscv64.tar.gz",
  ["linux/s390x"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_linux_s390x.tar.gz",
  ["netbsd/386"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_netbsd_386.tar.gz",
  ["netbsd/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_netbsd_amd64.tar.gz",
  ["netbsd/arm"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_netbsd_arm.tar.gz",
  ["netbsd/arm64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_netbsd_arm64.tar.gz",
  ["openbsd/386"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_openbsd_386.tar.gz",
  ["openbsd/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_openbsd_amd64.tar.gz",
  ["openbsd/arm"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_openbsd_arm.tar.gz",
  ["openbsd/arm64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_openbsd_arm64.tar.gz",
  ["solaris/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_solaris_amd64.tar.gz",
  ["windows/386"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_windows_386.tar.gz",
  ["windows/amd64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_windows_amd64.tar.gz",
  ["windows/arm"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_windows_arm.tar.gz",
  ["windows/arm64"] = "https://github.com/kndndrj/nvim-dbee/releases/download/v0.1.9/dbee_windows_arm64.tar.gz",
}

-- Git sha of compiled binaries
M.version = "af5075f31ede9e7d76c87babdee0f70340061660"

return M



================================================
FILE: lua/dbee/install/init.lua
================================================
local M = {}

-- NOTE: don't use vim.notify in loop callbacks
local function log_error(mes)
  print("[dbee install - error]: " .. mes)
end
local function log_info(mes)
  print("[dbee install]: " .. mes)
end

---@return string _ path to install dir
function M.dir()
  return vim.fn.stdpath("data") .. "/dbee/bin"
end

---@return string _ path to binary
function M.bin()
  local suffix = ""
  if vim.fn.has("win32") == 1 then
    suffix = ".exe"
  end
  return M.dir() .. "/dbee" .. suffix
end

---@return string _ version (hash of install manifest)
function M.version()
  local ok, m = pcall(require, "dbee.install.__manifest")
  if not ok or type(m) ~= "table" or vim.tbl_isempty(m) then
    return "unknown"
  end

  return m.version or "unknown"
end

---@return string _ path of go source
function M.source_path()
  local p, _ = debug.getinfo(1).source:sub(2):gsub("/lua/dbee/install/init.lua$", "/dbee")
  return p
end

---@param osys string operating system in format of uv.os_uname()
---@param arch string architecture in format of uv.os_uname()
---@return string url address of compiled binary
local function get_url(osys, arch)
  local arch_aliases = {
    ["arm"] = "arm",
    ["aarch64_be"] = "arm64",
    ["aarch64"] = "arm64",
    ["armv8b"] = "arm64", -- compat
    ["armv8l"] = "arm64", -- compat
    ["mips"] = "mips",
    ["mips64"] = "mips64",
    ["ppc64"] = "ppc64",
    ["ppc64le"] = "ppc64le",
    ["s390"] = "s390x", -- compat
    ["s390x"] = "s390x",
    ["i386"] = "386",
    ["i686"] = "386", -- compat
    ["x86_64"] = "amd64",
  }
  -- TODO:
  local os_aliases = {
    ["windows_nt"] = "windows",
  }

  if not osys or not arch then
    error("no operating system and arch provided")
  end
  local ok, m = pcall(require, "dbee.install.__manifest")
  if not ok or type(m) ~= "table" or vim.tbl_isempty(m) then
    error('error reading install manifest. try installing with go directly: require("dbee").install("go")')
  end

  local a = arch_aliases[arch] or arch
  local o = os_aliases[string.lower(osys)] or string.lower(osys)
  local key = string.format("%s/%s", o, a)

  local url = m.urls[key]
  if not url then
    error("no compiled binary found for " .. osys .. "/" .. arch)
  end

  return url
end

---@param command? install_command
---@return { cmd: string, args: string[], env: { string: string } }[]
local function get_job(command)
  local uname = vim.loop.os_uname()
  local arch = uname.machine
  local osys = uname.sysname
  -- paths for final installation location
  local install_dir = M.dir()
  local install_binary = M.bin()
  -- paths for extracting archives
  local build_dir = vim.fn.stdpath("cache") .. "/dbee/build"
  local archive = build_dir .. "/dbee.tar.gz"

  -- make install and build dirs
  vim.fn.mkdir(install_dir, "p")
  vim.fn.mkdir(build_dir, "p")

  local jobs_list = {
    wget = function()
      return {
        {
          cmd = "wget",
          args = { "-qO", archive, get_url(osys, arch) },
          env = {},
        },
        {
          cmd = "tar",
          args = { "-xzf", archive, "-C", install_dir },
          env = {},
        },
        {
          cmd = "chmod",
          args = { "+x", install_binary },
          env = {},
        },
      }
    end,
    curl = function()
      return {
        {
          cmd = "curl",
          args = { "-sfLo", archive, get_url(osys, arch) },
          env = {},
        },
        {
          cmd = "tar",
          args = { "-xzf", archive, "-C", install_dir },
          env = {},
        },
        {
          cmd = "chmod",
          args = { "+x", install_binary },
          env = {},
        },
      }
    end,
    bitsadmin = function()
      return {
        {
          cmd = "bitsadmin",
          args = { "TODO" },
          env = {},
        },
      }
    end,
    go = function()
      return {
        {
          cmd = "go",
          args = { "build", "-C", M.source_path(), "-o", install_binary },
          env = {},
        },
      }
    end,
    cgo = function()
      return {
        {
          cmd = "go",
          args = { "build", "-C", M.source_path(), "-o", install_binary },
          env = { CGO_ENABLED = "1" },
        },
      }
    end,
  }
  -- priority list
  local prio_job_list = { "wget", "curl", "bitsadmin", "go" }

  -- if command is provided use it
  if command then
    local jobs = jobs_list[command]() or {}
    for _, j in ipairs(jobs) do
      if vim.fn.executable(j.cmd) ~= 1 then
        error('"' .. command .. '" is not executable')
      end
    end
    return jobs
  end

  -- else find the first suitable command
  for _, cmd in ipairs(prio_job_list) do
    local jobs = jobs_list[cmd]() or {}
    local ignore = false
    for _, j in ipairs(jobs) do
      if vim.fn.executable(j.cmd) ~= 1 then
        ignore = true
        break
      end
    end
    if not ignore then
      return jobs
    end
  end

  error("no suitable installation method found")
end

---@param jobs table jobs to run in order
---@param index integer index of the job in jobs table
local function run_jobs(jobs, index)
  local job = jobs[index]
  if not job then
    return
  end
  log_info("running command: " .. job.cmd)
  local uv = vim.loop
  -- set env and save the previous values
  -- for some reason setting env on uv.spawn doesnt work
  local saved_env = {}
  for k, v in pairs(job.env) do
    local save = uv.os_getenv(k)
    if not save then
      save = ""
    end
    saved_env[k] = save
    uv.os_setenv(k, v)
  end
  local function cleanup()
    -- restore previous env variables
    for k, v in pairs(saved_env) do
      uv.os_setenv(k, v)
    end
  end

  local handle
  handle = uv.spawn(job.cmd, {
    args = job.args,
    stdio = { nil, 1, 2 },
  }, function(code, _)
    handle:close()
    if code == 0 then
      if index >= #jobs then
        log_info("successfully installed")
        return
      end
      run_jobs(jobs, index + 1)
    else
      log_error("command: " .. job.cmd .. " exited with code " .. tostring(code))
    end
    cleanup()
  end)

  if not handle then
    log_error("could not spawn command: " .. job.cmd)
    cleanup()
  end
end

---@param command? install_command preffered command
function M.exec(command)
  -- find a suitable install command
  local jobs = get_job(command)

  local msg = ""
  for _, j in ipairs(jobs) do
    msg = msg .. " " .. j.cmd
  end
  log_info("installing dbee with: " .. msg)

  run_jobs(jobs, 1)
end

return M



================================================
FILE: lua/dbee/layouts/init.lua
================================================
local tools = require("dbee.layouts.tools")
local utils = require("dbee.utils")
local api_ui = require("dbee.api.ui")

---@mod dbee.ref.layout UI Layout
---@brief [[
---Defines the layout of UI windows.
---The default layout is already defined, but it's possible to define your own layout.
---
---Layout implementation should implement the |Layout| interface and show the UI on screen
---as seen fit.
---@brief ]]

---Layout that defines how windows are opened.
---Layouts are free to use both core and ui apis.
---see |dbee.ref.api.core| and |dbee.ref.api.ui|
---
---Important for layout implementations: when opening windows, they must be
---exclusive to dbee. When closing windows, make sure to not reuse any windows dbee left over.
---@class Layout
---@field is_open fun(self: Layout):boolean function that returns the state of ui.
---@field open fun(self: Layout) function to open ui.
---@field reset fun(self: Layout) function to reset ui.
---@field close fun(self: Layout) function to close ui.

local layouts = {}

---@divider -

-- Default layout uses a helper to save the existing window layout before opening any windows,
-- then makes a new empty window for the editor and then opens result and drawer.
-- When later calling close(), the previously saved layout is restored.
---@class DefaultLayout: Layout
---@field private drawer_width integer
---@field private result_height integer
---@field private call_log_height integer
---@field private egg? layout_egg
---@field private windows table<string, integer>
---@field private on_switch "immutable"|"close"
---@field private is_opened boolean
layouts.Default = {}

---Create a default layout.
---The on_switch parameter defines what to do in case another buffer wants to be open in any window. default: "immutable"
---@param opts? { on_switch: "immutable"|"close", drawer_width: integer, result_height: integer, call_log_height: integer }
---@return DefaultLayout
function layouts.Default:new(opts)
  opts = opts or {}

  -- validate opts
  for _, opt in ipairs { "drawer_width", "result_height", "call_log_height" } do
    if opts[opt] and opts[opt] < 0 then
      error(opt .. " must be a positive integer. Got: " .. opts[opt])
    end
  end

  ---@type DefaultLayout
  local o = {
    egg = nil,
    windows = {},
    on_switch = opts.on_switch or "immutable",
    is_opened = false,
    drawer_width = opts.drawer_width or 40,
    result_height = opts.result_height or 20,
    call_log_height = opts.call_log_height or 20,
  }
  setmetatable(o, self)
  self.__index = self
  return o
end

---Action taken when another (inapropriate) buffer is open in the window.
---@package
---@param on_switch "immutable"|"close"
---@param winid integer
---@param open_fn fun(winid: integer)
---@param is_editor? boolean special care needs to be taken with editor - it uses multiple buffers.
function layouts.Default:configure_window_on_switch(on_switch, winid, open_fn, is_editor)
  local action
  if on_switch == "close" then
    action = function(_, buf, file)
      if is_editor then
        local note, _ = api_ui.editor_search_note_with_file(file)
        if note then
          -- do nothing
          return
        end
        note, _ = api_ui.editor_search_note_with_buf(buf)
        if note then
          -- do nothing
          return
        end
      end
      -- close dbee and open buffer
      self:close()
      vim.api.nvim_win_set_buf(0, buf)
    end
  else
    action = function(win, _, _)
      open_fn(win)
    end
  end

  utils.create_singleton_autocmd({ "BufWinEnter", "BufReadPost", "BufNewFile" }, {
    window = winid,
    callback = function(event)
      action(winid, event.buf, event.file)
    end,
  })
end

---Close all other windows when one is closed.
---@package
---@param winid integer
function layouts.Default:configure_window_on_quit(winid)
  utils.create_singleton_autocmd({ "QuitPre" }, {
    window = winid,
    callback = function()
      self:close()
    end,
  })
end

---@package
---@return boolean
function layouts.Default:is_open()
  return self.is_opened
end

---@package
function layouts.Default:open()
  -- save layout before opening ui
  self.egg = tools.save()

  self.windows = {}

  -- editor
  tools.make_only(0)
  local editor_win = vim.api.nvim_get_current_win()
  self.windows["editor"] = editor_win
  api_ui.editor_show(editor_win)
  self:configure_window_on_switch(self.on_switch, editor_win, api_ui.editor_show, true)
  self:configure_window_on_quit(editor_win)

  -- result
  vim.cmd("bo" .. self.result_height .. "split")
  local win = vim.api.nvim_get_current_win()
  self.windows["result"] = win
  api_ui.result_show(win)
  self:configure_window_on_switch(self.on_switch, win, api_ui.result_show)
  self:configure_window_on_quit(win)

  -- drawer
  vim.cmd("to" .. self.drawer_width .. "vsplit")
  win = vim.api.nvim_get_current_win()
  self.windows["drawer"] = win
  api_ui.drawer_show(win)
  self:configure_window_on_switch(self.on_switch, win, api_ui.drawer_show)
  self:configure_window_on_quit(win)

  -- call log
  vim.cmd("belowright " .. self.call_log_height .. "split")
  win = vim.api.nvim_get_current_win()
  self.windows["call_log"] = win
  api_ui.call_log_show(win)
  self:configure_window_on_switch(self.on_switch, win, api_ui.call_log_show)
  self:configure_window_on_quit(win)

  -- set cursor to editor
  vim.api.nvim_set_current_win(editor_win)

  self.is_opened = true
end

---@package
function layouts.Default:reset()
  vim.api.nvim_win_set_height(self.windows["result"], self.result_height)
  vim.api.nvim_win_set_width(self.windows["drawer"], self.drawer_width)
  vim.api.nvim_win_set_height(self.windows["call_log"], self.result_height)
end

---@package
function layouts.Default:close()
  -- close all windows
  for _, win in pairs(self.windows) do
    pcall(vim.api.nvim_win_close, win, false)
  end

  -- restore layout
  tools.restore(self.egg)
  self.egg = nil
  self.is_opened = false
end

return layouts



================================================
FILE: lua/dbee/layouts/tools.lua
================================================
---@alias _layout { type: string, winid: integer, bufnr: integer, win_opts: { string: any}, children: _layout[] }

---@alias layout_egg { layout: _layout, restore: string }

-- vim.fn.winlayout() example structure:
-- { "row", { { "leaf", winid }, { "col", { { "leaf", winid }, { "leaf", winid } } } } }

local M = {}

-- list all non-floating windows from the current tabpage
---@return integer[] # list of non floating window ids
local function list_non_floating_wins()
  return vim.fn.filter(vim.api.nvim_tabpage_list_wins(vim.api.nvim_get_current_tabpage()), function(_, v)
    return vim.api.nvim_win_get_config(v).relative == ""
  end)
end

-- makes the window the only one on screen
-- same as ":only" except ignores floating windows
---@param winid integer
function M.make_only(winid)
  if not winid or winid == 0 then
    winid = vim.api.nvim_get_current_win()
  end

  for _, wid in ipairs(list_non_floating_wins()) do
    if wid ~= winid then
      local winnr = vim.fn.win_id2win(wid)
      vim.cmd(winnr .. "wincmd c")
    end
  end
end

-- exact clone of the builtin "winrestcmd()" with exclusion of floating windows
-- https://github.com/neovim/neovim/blob/fcf3519c65a2d6736de437f686e788684a6c8564/src/nvim/eval/window.c#L770
---@return string
local function winrestcmd()
  local cmd = ""

  -- Do this twice to handle some window layouts properly.
  for _ = 1, 2 do
    local winnr = 1
    for _, winid in ipairs(list_non_floating_wins()) do
      cmd = string.format("%s%dresize %d|", cmd, winnr, vim.api.nvim_win_get_height(winid))
      cmd = string.format("%svert %dresize %d|", cmd, winnr, vim.api.nvim_win_get_width(winid))
      winnr = winnr + 1
    end
  end

  return cmd
end

-- add bufnr to leaf
local function add_details(layout)
  if layout[1] == "leaf" then
    local win = layout[2]

    -- window options
    local all_options = vim.api.nvim_get_all_options_info()
    local v = vim.wo[win]
    local options = {}
    for key, val in pairs(all_options) do
      if val.global_local == false and val.scope == "win" then
        options[key] = v[key]
      end
    end

    -- create dict structure with added buffer and window opts
    ---@type _layout
    local l = {
      type = layout[1],
      winid = win,
      bufnr = vim.fn.winbufnr(win),
      win_opts = options,
    }
    return l
  else
    local children = {}
    for _, child_layout in ipairs(layout[2]) do
      table.insert(children, add_details(child_layout))
    end
    return { type = layout[1], children = children }
  end
end

---@return layout_egg layout egg (use with restore())
function M.save()
  local layout = vim.fn.winlayout()
  local restore_cmd = winrestcmd()

  layout = add_details(layout)

  return { layout = layout, restore = restore_cmd }
end

---@param layout _layout
local function apply_layout(layout)
  if layout.type == "leaf" then
    -- open the previous buffer
    if vim.fn.bufexists(layout.bufnr) == 1 then
      vim.cmd("b " .. layout.bufnr)
    end
    -- apply window options
    for opt, val in pairs(layout.win_opts) do
      if val ~= nil then
        vim.wo[opt] = val
      end
    end
  else
    -- split cols or rows, split n-1 times
    local split_method = "rightbelow vsplit"
    if layout.type == "col" then
      split_method = "rightbelow split"
    end

    local wins = { vim.fn.win_getid() }

    for i in ipairs(layout.children) do
      if i ~= 1 then
        vim.cmd(split_method)
        table.insert(wins, vim.fn.win_getid())
      end
    end

    -- recursive into child windows
    for index, win in ipairs(wins) do
      vim.fn.win_gotoid(win)
      apply_layout(layout.children[index])
    end
  end
end

---@param egg layout_egg layout to restore
function M.restore(egg)
  egg = egg or {}

  if not egg.layout or not egg.restore then
    return
  end

  -- make a new window and set it as the only one
  vim.cmd("new")
  M.make_only(0)
  local tmp_buf = vim.api.nvim_get_current_buf()

  -- apply layout and perform resize_cmd
  apply_layout(egg.layout)
  vim.cmd(egg.restore)

  -- delete temporary buffer
  vim.cmd("bd " .. tmp_buf)
end

return M



================================================
FILE: lua/dbee/ui/call_log.lua
================================================
local NuiLine = require("nui.line")
local NuiTree = require("nui.tree")
local utils = require("dbee.utils")
local common = require("dbee.ui.common")

-- CallLogUI is connection's call history.
---@class CallLogUI
---@field private result ResultUI
---@field private handler Handler
---@field private tree NuiTree
---@field private winid? integer
---@field private bufnr integer
---@field private candies table<string, Candy> map of eye-candy stuff (icons, highlight)
---@field private current_connection_id? connection_id
---@field private hover_close? fun() function that closes the hover window
---@field private window_options table<string, any> a table of window options.
---@field private buffer_options table<string, any> a table of buffer options.
local CallLogUI = {}

---@param handler Handler
---@param result ResultUI
---@param opts call_log_config
---@return CallLogUI
function CallLogUI:new(handler, result, opts)
  opts = opts or {}

  if not handler then
    error("no Handler passed to CallLogUI")
  end
  if not result then
    error("no ResultTile passed to CallLogUI")
  end

  local candies = {}
  if not opts.disable_candies then
    candies = opts.candies or {}
  end

  ---@type CallLogUI
  local o = {
    handler = handler,
    result = result,
    candies = candies,
    hover_close = function() end,
    current_connection_id = (handler:get_current_connection() or {}).id,
    window_options = vim.tbl_extend("force", {
      wrap = false,
      winfixheight = true,
      winfixwidth = true,
      number = false,
      relativenumber = false,
      spell = false,
    }, opts.window_options or {}),
    buffer_options = vim.tbl_extend("force", {
      buflisted = false,
      bufhidden = "delete",
      buftype = "nofile",
      swapfile = false,
      filetype = "dbee",
    }, opts.buffer_options or {}),
  }
  setmetatable(o, self)
  self.__index = self

  -- create a buffer for drawer and configure it
  o.bufnr = common.create_blank_buffer("dbee-call-log", o.buffer_options)
  common.configure_buffer_mappings(o.bufnr, o:get_actions(), opts.mappings)

  -- create the tree
  o.tree = o:create_tree(o.bufnr)

  handler:register_event_listener("call_state_changed", function(data)
    ---@diagnostic disable-next-line
    o:on_call_state_changed(data)
  end)
  handler:register_event_listener("current_connection_changed", function(data)
    ---@diagnostic disable-next-line
    o:on_current_connection_changed(data)
  end)

  return o
end

-- event listener for new calls
---@private
---@param _ { call: CallDetails }
function CallLogUI:on_call_state_changed(_)
  self:refresh()
end

-- event listener for current connection change
---@private
---@param data { conn_id: connection_id }
function CallLogUI:on_current_connection_changed(data)
  self.current_connection_id = data.conn_id
  self:refresh()
end

---@param str string
---@param len integer
---@return string # string of length
local function make_length(str, len)
  local orig_len = vim.fn.strchars(str)
  if orig_len > len then
    return str:sub(1, len - 1) .. "…"
  elseif orig_len < len then
    return str .. string.rep(" ", len - orig_len)
  end

  -- same length
  return str
end

-- returns the initials of the call state
---@param state call_state
---@return string # string of length
local function call_state_initials(state)
  if not state then
    return "  "
  end

  local initials = ""
  for word in string.gmatch(state, "([^_]+)") do
    initials = initials .. word:sub(1, 1)
  end

  if #initials < 2 then
    initials = initials .. string.rep(" ", 2 - #initials)
  end

  return initials
end

---@private
---@param bufnr integer
---@return NuiTree
function CallLogUI:create_tree(bufnr)
  return NuiTree {
    bufnr = bufnr,
    prepare_node = function(node)
      ---@type CallDetails
      local call = node.call
      local line = NuiLine()
      if not call then
        if node.text then
          line:append(node.text, "NonText")
        end
        return line
      end

      local candy = self.candies[call.state]
        or { icon = call_state_initials(call.state), icon_highlight = "", text_highlight = "" }

      local state_preview = candy.icon
      if not state_preview or state_preview == "" then
        state_preview = call_state_initials(call.state)
      end

      line:append(make_length(state_preview, 3), candy.icon_highlight)
      line:append(" ┃ ", "NonText")
      line:append(make_length(string.gsub(call.query, "\n", " "), 40), candy.text_highlight)

      return line
    end,
    get_node_id = function(node)
      if node.id then
        return node.id
      end
      return tostring(math.random())
    end,
  }
end

---@private
---@return table<string, fun()>
function CallLogUI:get_actions()
  return {
    show_result = function()
      local node = self.tree:get_node()
      if not node then
        return
      end
      local call = node.call
      if not call then
        return
      end

      if call.state == "archived" or call.state == "retrieving" then
        self.result:set_call(call)
        self.result:page_current()
      end
    end,
    cancel_call = function()
      local node = self.tree:get_node()
      if not node then
        return
      end
      local call = node.call
      if not call then
        return
      end

      self.handler:call_cancel(call.id)
    end,
  }
end

---Triggers an in-built action.
---@param action string
function CallLogUI:do_action(action)
  local act = self:get_actions()[action]
  if not act then
    error("unknown action: " .. action)
  end
  act()
end

function CallLogUI:refresh()
  if not self.current_connection_id then
    return
  end
  local calls = self.handler:connection_get_calls(self.current_connection_id)

  -- dummy node if no calls
  if vim.tbl_isempty(calls) then
    self.tree:set_nodes { NuiTree.Node { id = tostring(math.random()), text = "Call log will be displayed here!" } }
    self.tree:render()
    return
  end

  table.sort(calls, function(k1, k2)
    return k1.timestamp_us > k2.timestamp_us
  end)

  local nodes = {}
  for _, c in ipairs(calls) do
    table.insert(nodes, NuiTree.Node { id = tostring(math.random()), call = c })
  end

  self.tree:set_nodes(nodes)
  self.tree:render()
end

---@param winid integer window to get the position of
---@return "left"|"right"
local function get_hover_position(winid)
  ---@param wid integer window to chech the neighbors of
  ---@return boolean # true if window has a right neighbor
  local has_neighbor_right = function(wid)
    local right_winid = vim.fn.win_getid(vim.fn.winnr("l"))
    if right_winid == 0 then
      return false
    end

    return wid ~= right_winid
  end

  if has_neighbor_right(winid) then
    return "right"
  end

  return "left"
end

---@private
---@param bufnr integer
function CallLogUI:configure_preview(bufnr)
  utils.create_singleton_autocmd({ "CursorMoved", "BufEnter" }, {
    buffer = bufnr,
    callback = function()
      self.hover_close()

      local node = self.tree:get_node()
      if not node then
        return
      end
      ---@type CallDetails?
      local call = node.call
      if not call then
        return
      end

      local call_summary = {
        { key = "id", value = call.id },
        { key = "query", value = string.gsub(call.query, "\n", " ") },
        { key = "state", value = call.state },
        { key = "time_taken", value = string.format("%.3f seconds", (call.time_taken_us or 0) / 1000000) },
        { key = "timestamp", value = tostring(os.date("%c", (call.timestamp_us or 0) / 1000000)) },
      }

      if call.error and call.error ~= "" then
        table.insert(call_summary, { key = "error", value = string.gsub(call.error, "\n", " ") })
      end

      self.hover_close = common.float_hover(self.winid, call_summary, { position = get_hover_position(self.winid) })
    end,
  })

  utils.create_singleton_autocmd({ "BufLeave", "QuitPre", "BufWinLeave", "WinLeave", "WinClosed" }, {
    buffer = bufnr,
    callback = function()
      self.hover_close()
    end,
  })
end

---@param winid integer
function CallLogUI:show(winid)
  self.winid = winid

  -- configure auto preview
  self:configure_preview(self.bufnr)

  -- set buffer to window
  vim.api.nvim_win_set_buf(self.winid, self.bufnr)

  -- configure window options (needs to be set after setting the buffer to window)
  common.configure_window_options(self.winid, self.window_options)

  self:refresh()
end

return CallLogUI



================================================
FILE: lua/dbee/ui/common/floats.lua
================================================
-- this package contains various floating window utilities such as floating editor and an input prompt
local utils = require("dbee.utils")

local M = {}

---User defined options for floating windows
---@type table<string, any>
local OPTS = {}

---Set up custom floating window parameters
---@param opts? table<string, any>
function M.configure(opts)
  OPTS = vim.tbl_extend("force", {
    border = "rounded",
    title_pos = "center",
    style = "minimal",
    title = "",
    zindex = 150,
  }, opts or {})
end

---Merges user defined options with provided spec.
---@param spec table<string, any>
local function enrich_float_opts(spec)
  return vim.tbl_extend("keep", spec, OPTS)
end

---@alias kv_pair { key: string, value: string }

--- highlight the prompt keys
---@param prompt kv_pair[]
---@param winid integer window to apply the highlight to
---@param hl_group string
local function highlight_keys(prompt, winid, hl_group)
  -- assemble the command
  ---@type string[]
  local patterns = {}
  for _, p in ipairs(prompt) do
    table.insert(patterns, string.format([[^\s*%s]], p.key))
  end

  local cmd = string.format("match %s /%s/", hl_group, table.concat(patterns, [[\|]]))

  local current_win = vim.api.nvim_get_current_win()
  -- just apply the highlight if we apply the highlight to current win
  if not winid or winid == 0 or winid == current_win then
    vim.cmd(cmd)
    return
  end

  -- switch to provided window, apply hightlight and jump back
  vim.api.nvim_set_current_win(winid)
  vim.cmd(cmd)
  vim.api.nvim_set_current_win(current_win)
end

---@param prompt kv_pair[] list of lines with optional defaults to display as prompt
---@param spec? { title: string, callback: fun(result: table<string, string>) }
function M.prompt(prompt, spec)
  spec = spec or {}

  -- create lines to display
  ---@type string[]
  local display_prompt = {}
  for _, p in ipairs(prompt) do
    table.insert(display_prompt, p.key .. ": " .. (p.value or ""))
  end

  local win_width = 100
  local win_height = #display_prompt
  local ui_spec = vim.api.nvim_list_uis()[1]
  local x = math.floor((ui_spec["width"] - win_width) / 2)
  local y = math.floor((ui_spec["height"] - win_height) / 2)

  -- create new buffer
  local bufnr = vim.api.nvim_create_buf(false, false)
  local name = spec.title or utils.random_string()
  vim.api.nvim_buf_set_name(bufnr, name)
  vim.api.nvim_buf_set_option(bufnr, "filetype", "dbee")
  vim.api.nvim_buf_set_option(bufnr, "buftype", "acwrite")
  vim.api.nvim_buf_set_option(bufnr, "bufhidden", "delete")

  -- fill buffer contents
  vim.api.nvim_buf_set_lines(bufnr, 0, -1, true, display_prompt)
  vim.api.nvim_buf_set_option(bufnr, "modified", false)

  -- open window
  local winid = vim.api.nvim_open_win(
    bufnr,
    true,
    enrich_float_opts {
      relative = "editor",
      width = win_width,
      height = win_height,
      col = x,
      row = y,
      title = spec.title or "",
    }
  )
  -- apply the highlighting of keys to window
  highlight_keys(prompt, winid, "Question")

  local callback = spec.callback or function() end

  -- set callbacks
  vim.api.nvim_create_autocmd("BufWriteCmd", {
    buffer = bufnr,
    callback = function()
      -- reset modified flag
      vim.api.nvim_buf_set_option(bufnr, "modified", false)

      -- get lines
      local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)

      -- close the window if not using "wq" already
      local cmd_hist = vim.api.nvim_exec2(":history cmd -1", { output = true })
      local last_cmd = cmd_hist.output:gsub(".*\n>%s*%d+%s*(.*)%s*", "%1")
      if not last_cmd:find("^wq") then
        vim.api.nvim_win_close(winid, true)
      end

      -- create key-value from prompt and values and trigger callback
      local kv = {}
      for _, p in ipairs(prompt) do
        -- get key from prompt and store it as empty string by default
        local key = p.key
        kv[key] = ""

        for _, l in ipairs(lines) do
          -- if line has prompt prefix, get the value and strip whitespace
          if l:find("^%s*" .. p.key .. ":") then
            local val = l:gsub("^%s*" .. p.key .. ":%s*(.-)%s*$", "%1")
            kv[key] = val
          end
        end
      end

      callback(kv)
    end,
  })

  vim.api.nvim_create_autocmd({ "BufLeave", "BufWritePost" }, {
    buffer = bufnr,
    callback = function()
      vim.api.nvim_win_close(winid, true)
    end,
  })

  -- set keymaps
  vim.keymap.set("n", "q", function()
    vim.api.nvim_win_close(winid, true)
  end, { silent = true, buffer = bufnr })

  vim.keymap.set("i", "<CR>", function()
    -- write and return to normal mode
    vim.cmd(":w")
    vim.api.nvim_input("<C-\\><C-N>")
  end, { silent = true, buffer = bufnr })
end

---@param file string file to edit
---@param spec? { title: string, callback: fun() } required parameters for float.
function M.editor(file, spec)
  spec = spec or {}

  local ui_spec = vim.api.nvim_list_uis()[1]
  local win_width = ui_spec["width"] - 50
  local win_height = ui_spec["height"] - 10
  local x = math.floor((ui_spec["width"] - win_width) / 2)
  local y = math.floor((ui_spec["height"] - win_height) / 2)

  -- create new dummy buffer
  local tmp_buf = vim.api.nvim_create_buf(false, true)

  -- open window
  local winid = vim.api.nvim_open_win(
    tmp_buf,
    true,
    enrich_float_opts {
      title = spec.title or "",
      relative = "editor",
      width = win_width,
      height = win_height,
      col = x,
      row = y,
    }
  )

  -- open the file
  vim.cmd("e " .. file)
  local bufnr = vim.api.nvim_get_current_buf()
  vim.api.nvim_buf_set_option(bufnr, "bufhidden", "delete")

  local callback = spec.callback or function() end

  -- set callbacks
  vim.api.nvim_create_autocmd("BufWritePost", {
    buffer = bufnr,
    callback = callback,
  })

  vim.api.nvim_create_autocmd({ "BufLeave", "BufWritePost" }, {
    buffer = bufnr,
    callback = function()
      -- close the window if not using "wq" already
      local cmd_hist = vim.api.nvim_exec2(":history cmd -1", { output = true })
      local last_cmd = cmd_hist.output:gsub(".*\n>%s*%d+%s*(.*)%s*", "%1")
      if not last_cmd:find("^wq") then
        pcall(vim.api.nvim_win_close, winid, true)
        pcall(vim.api.nvim_buf_delete, bufnr, {})
      end
    end,
  })

  -- set keymaps
  vim.keymap.set("n", "q", function()
    vim.api.nvim_win_close(winid, true)
  end, { silent = true, buffer = bufnr })
end

-- This function splits lines that are too long so that they fit inside "max_width".
-- A single can be split over at most "max_split" lines
---@param line string
---@param max_width integer
---@param max_split integer
---@return string[] # list of split lines
local function split_line(line, max_width, max_split)
  if #line <= max_width then
    return { line }
  end

  local text_width = max_width - 4 -- indentation

  local spl = {}
  for i = 1, max_split * text_width, text_width do
    local s

    if i == 1 then
      s = line:sub(i, i + max_width)
    else
      s = line:sub(i, i + text_width)
      if s == "" then
        break
      end
      s = "    " .. s
    end

    table.insert(spl, s)
  end
  return spl
end

-- hover window with custom content
---@param relative_winid? integer window to set the hover relative to
---@param contents kv_pair[] list of key_value pairs to display in the hover
---@param opts? { position: "left"|"right", width: integer, max_split: integer }
---@return fun() # close handle
function M.hover(relative_winid, contents, opts)
  opts = opts or {}
  opts.position = opts.position or "right"
  opts.width = opts.width or 80
  opts.max_split = opts.max_split or 6

  if not contents or #contents < 1 or not relative_winid or not vim.api.nvim_win_is_valid(relative_winid) then
    return function() end
  end

  local key_width = 10
  for _, p in ipairs(contents) do
    if #p.key > key_width then
      key_width = #p.key
    end
  end

  -- create lines to display
  ---@type string[]
  local display = {}
  for _, p in ipairs(contents) do
    local n_spaces = key_width - #p.key
    table.insert(display, p.key .. ": " .. string.rep(" ", n_spaces) .. (p.value or ""))
  end

  local lines = {}
  for _, line in ipairs(display) do
    for _, spl in ipairs(split_line(line, opts.width, opts.max_split)) do
      table.insert(lines, spl)
    end
  end

  -- create new buffer with contents
  local bufnr = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)
  vim.api.nvim_buf_set_option(bufnr, "filetype", "dbee")
  vim.api.nvim_buf_set_option(bufnr, "bufhidden", "delete")

  -- row is relative to cursor in the "parent" window
  local cursor_row, _ = unpack(vim.api.nvim_win_get_cursor(relative_winid))

  -- open to left/right based on window position
  local col
  local anchor
  if opts.position == "left" then
    col = 0
    anchor = "NE"
  else -- "right"
    col = vim.api.nvim_win_get_width(relative_winid)
    anchor = "NW"
  end

  -- open window
  local winid = vim.api.nvim_open_win(
    bufnr,
    false,
    enrich_float_opts {
      relative = "win",
      win = relative_winid,
      width = opts.width,
      height = #lines,
      col = col,
      row = cursor_row - 1,
      anchor = anchor,
    }
  )

  -- apply highlight
  highlight_keys(contents, winid, "CursorLineNr")

  return function()
    pcall(vim.api.nvim_win_close, winid, true)
    pcall(vim.api.nvim_buf_delete, bufnr, {})
  end
end

return M



================================================
FILE: lua/dbee/ui/common/init.lua
================================================
local floats = require("dbee.ui.common.floats")
local utils = require("dbee.utils")

local M = {}

-- expose floats
M.float_editor = floats.editor
M.float_hover = floats.hover
M.float_prompt = floats.prompt

-- Creates a blank hidden buffer.
---@param name string
---@param opts? table<string, any> buffer options
---@return integer bufnr
function M.create_blank_buffer(name, opts)
  opts = opts or {}

  local bufnr = vim.api.nvim_create_buf(false, true)
  -- try setting buffer name - fallback to random string
  local ok = pcall(vim.api.nvim_buf_set_name, bufnr, name)
  if not ok then
    pcall(vim.api.nvim_buf_set_name, bufnr, name .. "-" .. utils.random_string())
  end

  M.configure_buffer_options(bufnr, opts)

  return bufnr
end

---@param bufnr integer
---@param opts? table<string, any> buffer options
function M.configure_buffer_options(bufnr, opts)
  if not bufnr then
    return
  end

  opts = opts or {}

  for opt, val in pairs(opts) do
    vim.api.nvim_buf_set_option(bufnr, opt, val)
  end
end

---@param winid integer
---@param opts? table<string, any> window options
function M.configure_window_options(winid, opts)
  if not winid then
    return
  end
  opts = opts or {}

  for opt, val in pairs(opts) do
    vim.api.nvim_win_set_option(winid, opt, val)
  end
end

-- Sets mappings to the buffer.
---@param bufnr integer
---@param actions table<string, fun()>
---@param keymap key_mapping[]
function M.configure_buffer_mappings(bufnr, actions, keymap)
  if not bufnr then
    return
  end
  actions = actions or {}
  keymap = keymap or {}

  local set_fn = vim.keymap.set

  -- keymaps
  local default_opts = { noremap = true, nowait = true }

  for _, km in ipairs(keymap) do
    if km.key and km.mode then
      local action
      if type(km.action) == "string" then
        action = actions[km.action]
      elseif type(km.action) == "function" then
        action = km.action
      end

      if action then
        local map_opts = km.opts or default_opts
        map_opts.buffer = bufnr
        set_fn(km.mode, km.key, action, map_opts)
      end
    end
  end
end

return M



================================================
FILE: lua/dbee/ui/drawer/convert.lua
================================================
local utils = require("dbee.utils")
local common = require("dbee.ui.common")
local NuiTree = require("nui.tree")

local M = {}

---@param parent_id string
---@param columns Column[]
---@return DrawerUINode[]
local function column_nodes(parent_id, columns)
  ---@type DrawerUINode[]
  local nodes = {}

  for _, column in ipairs(columns) do
    table.insert(
      nodes,
      NuiTree.Node {
        id = parent_id .. column.type .. column.name,
        name = column.name .. "   [" .. column.type .. "]",
        type = "column",
      }
    )
  end

  return nodes
end

---@param handler Handler
---@param conn ConnectionParams
---@param result ResultUI
---@return DrawerUINode[]
local function connection_nodes(handler, conn, result)
  ---@param structs DBStructure[]
  ---@param parent_id string
  ---@return DrawerUINode[]
  local function to_tree_nodes(structs, parent_id)
    if not structs or structs == vim.NIL then
      return {}
    end

    table.sort(structs, function(k1, k2)
      return k1.type .. k1.name < k2.type .. k2.name
    end)

    ---@type DrawerUINode[]
    local nodes = {}

    for _, struct in ipairs(structs) do
      local node_id = (parent_id or "") .. "__connection_" .. struct.name .. struct.schema .. struct.type .. "__"
      local node = NuiTree.Node({
        id = node_id,
        name = struct.name,
        schema = struct.schema,
        type = struct.type,
      }, to_tree_nodes(struct.children, node_id)) --[[@as DrawerUINode]]

      if struct.type == "table" or struct.type == "view" then
        local table_opts = { table = struct.name, schema = struct.schema, materialization = struct.type }

        -- table helpers
        node.action_1 = function(cb, select)
          local helpers = handler:connection_get_helpers(conn.id, table_opts)
          local items = vim.tbl_keys(helpers)
          table.sort(items)

          select {
            title = "Select a Query",
            items = items,
            on_confirm = function(selection)
              local call = handler:connection_execute(conn.id, helpers[selection])
              result:set_call(call)
              cb()
            end,
            on_yank = function(selection)
              vim.fn.setreg(vim.v.register, helpers[selection])
            end,
          }
        end

        node.lazy_children = function()
          return column_nodes(node_id, handler:connection_get_columns(conn.id, table_opts))
        end
      end

      table.insert(nodes, node)
    end

    return nodes
  end

  -- recursively parse structure to drawer nodes
  local nodes = to_tree_nodes(handler:connection_get_structure(conn.id), conn.id)

  -- database switching
  local current_db, available_dbs = handler:connection_list_databases(conn.id)
  if current_db ~= "" and #available_dbs > 0 then
    local ly = NuiTree.Node {
      id = conn.id .. "_database_switch__",
      name = current_db,
      type = "database_switch",
      action_1 = function(cb, select)
        select {
          title = "Select a Database",
          items = available_dbs,
          on_confirm = function(selection)
            handler:connection_select_database(conn.id, selection)
            cb()
          end,
        }
      end,
    } --[[@as DrawerUINode]]
    table.insert(nodes, 1, ly)
  end

  return nodes
end

---@param handler Handler
---@param result ResultUI
---@return DrawerUINode[]
local function handler_real_nodes(handler, result)
  ---@type DrawerUINode[]
  local nodes = {}

  for _, source in ipairs(handler:get_sources()) do
    local source_id = source:name()

    ---@type DrawerUINode[]
    local children = {}

    -- source can add connections
    if type(source.create) == "function" then
      table.insert(
        children,
        NuiTree.Node {
          id = "__source_add_connection__" .. source_id,
          name = "add",
          type = "add",
          action_1 = function(cb)
            local prompt = {
              { key = "name" },
              { key = "type" },
              { key = "url" },
            }
            common.float_prompt(prompt, {
              title = "Add Connection",
              callback = function(res)
                local spec = {
                  name = res.name,
                  url = res.url,
                  type = res.type,
                }
                pcall(handler.source_add_connection, handler, source_id, spec)
                cb()
              end,
            })
          end,
        } --[[@as DrawerUINode]]
      )
    end

    -- source has an editable source file
    if type(source.file) == "function" then
      table.insert(
        children,
        NuiTree.Node {
          id = "__source_edit_connections__" .. source_id,
          name = "edit source",
          type = "edit",
          action_1 = function(cb)
            common.float_editor(source:file(), {
              title = "Add Connection",
              callback = function()
                handler:source_reload(source_id)
                cb()
              end,
            })
          end,
        } --[[@as DrawerUINode]]
      )
    end

    -- get connections of that source
    for _, conn in ipairs(handler:source_get_connections(source_id)) do
      -- if source has update, we can edit connections
      ---@type drawer_node_action
      local edit_action
      if type(source.update) == "function" then
        edit_action = function(cb)
          local original_details = handler:connection_get_params(conn.id)
          if not original_details then
            return
          end
          local prompt = {
            { key = "name", value = original_details.name },
            { key = "type", value = original_details.type },
            { key = "url", value = original_details.url },
          }
          common.float_prompt(prompt, {
            title = "Edit Connection",
            callback = function(res)
              local spec = {
                name = res.name,
                url = res.url,
                type = res.type,
              }
              pcall(handler.source_update_connection, handler, source_id, conn.id, spec)
              cb()
            end,
          })
        end
      end

      -- if source has delete, we can delete connections
      ---@type drawer_node_action
      local delete_action
      if type(source.delete) == "function" then
        delete_action = function(cb, select)
          select {
            title = "Confirm Deletion",
            items = { "Yes", "No" },
            on_confirm = function(selection)
              if selection == "Yes" then
                pcall(handler.source_remove_connection, handler, source_id, conn.id)
              end
              cb()
            end,
          }
        end
      end

      local node = NuiTree.Node {
        id = conn.id,
        name = conn.name,
        type = "connection",
        -- set connection as active manually
        action_1 = function(cb)
          handler:set_current_connection(conn.id)
          cb()
        end,
        -- edit connection
        action_2 = edit_action,
        -- remove connection
        action_3 = delete_action,
        lazy_children = function()
          return connection_nodes(handler, conn, result)
        end,
      } --[[@as DrawerUINode]]

      table.insert(children, node)
    end

    if #children > 0 then
      local node = NuiTree.Node({
        id = "__source__" .. source_id,
        name = source_id,
        type = "source",
      }, children) --[[@as DrawerUINode]]

      if utils.once("handler_expand_once_id" .. source_id) then
        node:expand()
      end

      table.insert(nodes, node)
    end
  end

  return nodes
end

---@return DrawerUINode[]
local function handler_help_nodes()
  local node = NuiTree.Node({
    id = "__handler_help_id__",
    name = "No sources :(",
    type = "",
  }, {
    NuiTree.Node {
      id = "__handler_help_id_child_1__",
      name = 'Type ":h dbee.txt"',
      type = "",
    },
    NuiTree.Node {
      id = "__handler_help_id_child_2__",
      name = "to define your first source!",
      type = "",
    },
  })

  if utils.once("handler_expand_once_helper_id") then
    node:expand()
  end

  return { node }
end

---@param handler Handler
---@param result ResultUI
---@return DrawerUINode[]
function M.handler_nodes(handler, result)
  -- in case there are no sources defined, return helper nodes
  if #handler:get_sources() < 1 then
    return handler_help_nodes()
  end
  return handler_real_nodes(handler, result)
end

-- whitespace between nodes
---@return DrawerUINode
function M.separator_node()
  return NuiTree.Node {
    id = "__separator_node__" .. tostring(math.random()),
    name = "",
    type = "separator",
  } --[[@as DrawerUINode]]
end

---@param mappings key_mapping[]
---@return DrawerUINode
function M.help_node(mappings)
  -- help node
  ---@type DrawerUINode[]
  local children = {}
  for _, km in ipairs(mappings) do
    if type(km.action) == "string" then
      table.insert(
        children,
        NuiTree.Node {
          id = "__help_action_" .. utils.random_string(),
          name = km.action .. " = " .. km.key .. " (" .. km.mode .. ")",
          type = "",
        }
      )
    end
  end

  table.sort(children, function(k1, k2)
    return k1.name < k2.name
  end)

  local node = NuiTree.Node({
    id = "__help_node__",
    name = "help",
    type = "help",
  }, children) --[[@as DrawerUINode]]

  if utils.once("help_expand_once_id") then
    node:expand()
  end

  return node
end

---@param bufnr integer
---@param refresh fun() function that refreshes the tree
---@return string suffix
local function modified_suffix(bufnr, refresh)
  if not bufnr or not vim.api.nvim_buf_is_valid(bufnr) then
    return ""
  end

  local suffix = ""
  if vim.api.nvim_get_option_value("modified", { buf = bufnr }) then
    suffix = " ●"
  end

  utils.create_singleton_autocmd({ "BufModifiedSet" }, {
    buffer = bufnr,
    callback = refresh,
  })

  return suffix
end

---@param editor EditorUI
---@param namespace namespace_id
---@param refresh fun() function that refreshes the tree
---@return DrawerUINode[]
local function editor_namespace_nodes(editor, namespace, refresh)
  ---@type DrawerUINode[]
  local nodes = {}

  table.insert(
    nodes,
    NuiTree.Node {
      id = "__new_" .. namespace .. "_note__",
      name = "new",
      type = "add",
      action_1 = function(cb, _, input)
        input {
          title = "Enter Note Name",
          default = "note_" .. utils.random_string() .. ".sql",
          on_confirm = function(value)
            if not value or value == "" then
              return
            end
            local id = editor:namespace_create_note(namespace, value)
            editor:set_current_note(id)
            cb()
          end,
        }
      end,
    } --[[@as DrawerUINode]]
  )

  -- global notes
  for _, note in ipairs(editor:namespace_get_notes(namespace)) do
    local node = NuiTree.Node {
      id = note.id,
      name = note.name .. modified_suffix(note.bufnr, refresh),
      type = "note",
      action_1 = function(cb)
        editor:set_current_note(note.id)
        cb()
      end,
      action_2 = function(cb, _, input)
        input {
          title = "New Name",
          default = note.name,
          on_confirm = function(value)
            if not value or value == "" then
              return
            end
            editor:note_rename(note.id, value)
            cb()
          end,
        }
      end,
      action_3 = function(cb, select)
        select {
          title = "Confirm Deletion",
          items = { "Yes", "No" },
          on_confirm = function(selection)
            if selection == "Yes" then
              editor:namespace_remove_note(namespace, note.id)
            end
            cb()
          end,
        }
      end,
    } --[[@as DrawerUINode]]

    table.insert(nodes, node)
  end

  return nodes
end

---@param editor EditorUI
---@param current_connection_id connection_id
---@param refresh fun() function that refreshes the tree
---@return DrawerUINode[]
function M.editor_nodes(editor, current_connection_id, refresh)
  local nodes = {
    NuiTree.Node({
      id = "__master_note_global__",
      name = "global notes",
      type = "note",
    }, editor_namespace_nodes(editor, "global", refresh)),
  }

  if utils.once("editor_global_expand") then
    nodes[1]:expand()
  end

  if current_connection_id then
    table.insert(
      nodes,
      NuiTree.Node({
        id = "__master_note_local__",
        name = "local notes",
        type = "note",
      }, editor_namespace_nodes(editor, current_connection_id, refresh))
    )
    if utils.once("editor_local_expand") then
      nodes[2]:expand()
    end
  end

  return nodes
end

return M



================================================
FILE: lua/dbee/ui/drawer/expansion.lua
================================================
local M = {}

-- applies the expansion on new nodes
---@param tree NuiTree tree to apply the expansion map to
---@param expansion table<string, boolean> expansion map ( id:is_expanded mapping )
function M.set(tree, expansion)
  -- first pass: load lazy_loaded children
  for id, t in pairs(expansion) do
    if t then
      local node = tree:get_node(id) --[[@as DrawerUINode]]
      if node then
        -- if function for getting layout exist, call it
        if type(node.lazy_children) == "function" then
          tree:set_nodes(node.lazy_children(), node.id)
        end
      end
    end
  end

  -- second pass: expand nodes
  for id, t in pairs(expansion) do
    if t then
      local node = tree:get_node(id) --[[@as DrawerUINode]]
      if node then
        node:expand()
      end
    end
  end
end

-- gets an expansion config to restore the expansion on new nodes
---@param tree NuiTree
---@return table<string, boolean>
function M.get(tree)
  ---@type table<string, boolean>
  local nodes = {}

  local function process(node)
    if node:is_expanded() then
      nodes[node:get_id()] = true
    end

    if node:has_children() then
      for _, n in ipairs(tree:get_nodes(node:get_id())) do
        process(n)
      end
    end
  end

  for _, node in ipairs(tree:get_nodes()) do
    process(node)
  end

  return nodes
end

return M



================================================
FILE: lua/dbee/ui/drawer/init.lua
================================================
local NuiTree = require("nui.tree")
local NuiLine = require("nui.line")
local common = require("dbee.ui.common")
local menu = require("dbee.ui.drawer.menu")
local convert = require("dbee.ui.drawer.convert")
local expansion = require("dbee.ui.drawer.expansion")

-- action function of drawer nodes
---@alias drawer_node_action fun(cb: fun(), select: menu_select, input: menu_input)

-- A single line in drawer tree
---@class DrawerUINode: NuiTree.Node
---@field id string unique identifier
---@field name string display name
---@field type ""|"table"|"view"|"column"|"history"|"note"|"connection"|"database_switch"|"add"|"edit"|"remove"|"help"|"source"|"separator" type of node
---@field action_1? drawer_node_action primary action if function takes a second selection parameter, pick_items get picked before the call
---@field action_2? drawer_node_action secondary action if function takes a second selection parameter, pick_items get picked before the call
---@field action_3? drawer_node_action tertiary action if function takes a second selection parameter, pick_items get picked before the call
---@field lazy_children? fun():DrawerUINode[] lazy loaded child nodes

---@class DrawerUI
---@field private tree NuiTree
---@field private handler Handler
---@field private editor EditorUI
---@field private result ResultUI
---@field private mappings key_mapping[]
---@field private candies table<string, Candy> map of eye-candy stuff (icons, highlight)
---@field private disable_help boolean show help or not
---@field private winid? integer
---@field private bufnr integer
---@field private current_conn_id? connection_id current active connection
---@field private current_note_id? note_id current active note
---@field private window_options table<string, any> a table of window options.
---@field private buffer_options table<string, any> a table of buffer options.
local DrawerUI = {}

---@param handler Handler
---@param editor EditorUI
---@param result ResultUI
---@param opts? drawer_config
---@return DrawerUI
function DrawerUI:new(handler, editor, result, opts)
  opts = opts or {}

  if not handler then
    error("no Handler provided to Drawer")
  end
  if not editor then
    error("no Editor provided to Drawer")
  end
  if not result then
    error("no Result provided to Drawer")
  end

  local candies = {}
  if not opts.disable_candies then
    candies = opts.candies or {}
  end

  local current_conn = handler:get_current_connection() or {}
  local current_note = editor:get_current_note() or {}

  -- class object
  local o = {
    handler = handler,
    editor = editor,
    result = result,
    mappings = opts.mappings or {},
    candies = candies,
    disable_help = opts.disable_help or false,
    current_conn_id = current_conn.id,
    current_note_id = current_note.id,
    window_options = vim.tbl_extend("force", {
      wrap = false,
      winfixheight = true,
      winfixwidth = true,
      number = false,
      relativenumber = false,
      spell = false,
    }, opts.window_options or {}),
    buffer_options = vim.tbl_extend("force", {
      buflisted = false,
      bufhidden = "delete",
      buftype = "nofile",
      swapfile = false,
      filetype = "dbee",
    }, opts.buffer_options or {}),
  }
  setmetatable(o, self)
  self.__index = self

  -- create a buffer for drawer and configure it
  o.bufnr = common.create_blank_buffer("dbee-drawer", o.buffer_options)
  common.configure_buffer_mappings(o.bufnr, o:get_actions(), opts.mappings)

  -- create tree
  o.tree = o:create_tree(o.bufnr)

  -- listen to events
  handler:register_event_listener("current_connection_changed", function(data)
    o:on_current_connection_changed(data)
  end)

  editor:register_event_listener("current_note_changed", function(data)
    o:on_current_note_changed(data)
  end)

  return o
end

-- event listener for current connection change
---@private
---@param data { conn_id: connection_id }
function DrawerUI:on_current_connection_changed(data)
  if self.current_conn_id == data.conn_id then
    return
  end
  self.current_conn_id = data.conn_id
  self:refresh()
end

-- event listener for current note change
---@private
---@param data { note_id: note_id }
function DrawerUI:on_current_note_changed(data)
  if self.current_note_id == data.note_id then
    return
  end
  self.current_note_id = data.note_id
  self:refresh()
end

---@private
---@param bufnr integer
---@return NuiTree tree
function DrawerUI:create_tree(bufnr)
  return NuiTree {
    bufnr = bufnr,
    prepare_node = function(node)
      local line = NuiLine()

      if node.type == "separator" then
        return line
      end

      line:append(string.rep("  ", node:get_depth() - 1))

      if node:has_children() or node.lazy_children then
        local candy = self.candies["node_closed"] or { icon = ">", icon_highlight = "NonText" }
        if node:is_expanded() then
          candy = self.candies["node_expanded"] or { icon = "v", icon_highlight = "NonText" }
        end
        line:append(candy.icon .. " ", candy.icon_highlight)
      else
        line:append("  ")
      end

      ---@type Candy
      local candy
      -- special icons for nodes without type
      if not node.type or node.type == "" then
        if node:has_children() then
          candy = self.candies["none_dir"]
        else
          candy = self.candies["none"]
        end
      else
        candy = self.candies[node.type] or {}
      end
      candy = candy or {}

      if candy.icon then
        line:append(" " .. candy.icon .. " ", candy.icon_highlight)
      end

      -- apply a special highlight for active connection and active note
      if node.id == self.current_conn_id or self.current_note_id == node.id then
        line:append(string.gsub(node.name, "\n", " "), candy.icon_highlight)
      else
        line:append(string.gsub(node.name, "\n", " "), candy.text_highlight)
      end

      return line
    end,
    get_node_id = function(node)
      if node.id then
        return node.id
      end
      return tostring(math.random())
    end,
  }
end

---@private
---@return table<string, fun()>
function DrawerUI:get_actions()
  local function collapse_node(node)
    if node:collapse() then
      self.tree:render()
    end
  end

  local function expand_node(node)
    local expanded = node:is_expanded()

    -- if function for getting layout exist, call it
    if not expanded and type(node.lazy_children) == "function" then
      self.tree:set_nodes(node.lazy_children(), node.id)
    end

    node:expand()

    self.tree:render()
  end

  -- wrapper for actions (e.g. action_1, action_2, action_3)
  ---@param action drawer_node_action
  local function perform_action(action)
    if type(action) ~= "function" then
      return
    end

    action(function()
      self:refresh()
    end, function(opts)
      opts = opts or {}
      menu.select {
        relative_winid = self.winid,
        title = opts.title or "",
        mappings = self.mappings,
        items = opts.items or {},
        on_confirm = opts.on_confirm,
        on_yank = opts.on_yank,
      }
    end, function(opts)
      menu.input {
        relative_winid = self.winid,
        title = opts.title or "",
        mappings = self.mappings,
        default_value = opts.default or "",
        on_confirm = opts.on_confirm,
      }
    end)
  end

  return {
    refresh = function()
      self:refresh()
    end,
    action_1 = function()
      local node = self.tree:get_node() --[[@as DrawerUINode]]
      if not node then
        return
      end
      perform_action(node.action_1)
    end,
    action_2 = function()
      local node = self.tree:get_node() --[[@as DrawerUINode]]
      if not node then
        return
      end
      perform_action(node.action_2)
    end,
    action_3 = function()
      local node = self.tree:get_node() --[[@as DrawerUINode]]
      if not node then
        return
      end
      perform_action(node.action_3)
    end,
    collapse = function()
      local node = self.tree:get_node()
      if not node then
        return
      end
      collapse_node(node)
    end,
    expand = function()
      local node = self.tree:get_node()
      if not node then
        return
      end
      expand_node(node)
    end,
    toggle = function()
      local node = self.tree:get_node()
      if not node then
        return
      end
      if node:is_expanded() then
        collapse_node(node)
      else
        expand_node(node)
      end
    end,
  }
end

---Triggers an in-built action.
---@param action string
function DrawerUI:do_action(action)
  local act = self:get_actions()[action]
  if not act then
    error("unknown action: " .. action)
  end
  act()
end

---Refreshes the tree.
function DrawerUI:refresh()
  -- assemble tree layout
  ---@type DrawerUINode[]
  local nodes = {}
  local editor_nodes = convert.editor_nodes(self.editor, self.current_conn_id, function()
    self:refresh()
  end)
  for _, ly in ipairs(editor_nodes) do
    table.insert(nodes, ly)
  end
  table.insert(nodes, convert.separator_node())
  for _, ly in ipairs(convert.handler_nodes(self.handler, self.result)) do
    table.insert(nodes, ly)
  end

  if not self.disable_help then
    table.insert(nodes, convert.separator_node())
    table.insert(nodes, convert.help_node(self.mappings))
  end

  local exp = expansion.get(self.tree)
  self.tree:set_nodes(nodes)
  expansion.set(self.tree, exp)

  self.tree:render()
end

---@param winid integer
function DrawerUI:show(winid)
  self.winid = winid

  -- set buffer to window
  vim.api.nvim_win_set_buf(self.winid, self.bufnr)

  -- configure window options (needs to be set after setting the buffer to window)
  common.configure_window_options(self.winid, self.window_options)

  self:refresh()
end

return DrawerUI



================================================
FILE: lua/dbee/ui/drawer/menu.lua
================================================
local NuiMenu = require("nui.menu")
local NuiInput = require("nui.input")

local M = {}

---@alias menu_select fun(opts?: { title: string, items: string[], on_confirm: fun(selection: string), on_yank: fun(selection: string) })
---@alias menu_input fun(opts?: { title: string, default: string, on_confirm: fun(value: string) })

-- Pick items from a list.
---@param opts { relative_winid: integer, items: string[], on_confirm: fun(item: string), on_yank: fun(item:string), title: string, mappings: key_mapping[] }
function M.select(opts)
  opts = opts or {}
  if not opts.relative_winid or not vim.api.nvim_win_is_valid(opts.relative_winid) then
    error("no window id provided")
  end

  local width = vim.api.nvim_win_get_width(opts.relative_winid)
  local row, _ = unpack(vim.api.nvim_win_get_cursor(opts.relative_winid))

  local popup_options = {
    relative = {
      type = "win",
      winid = opts.relative_winid,
    },
    position = {
      row = row + 1,
      col = 0,
    },
    size = {
      width = width,
    },
    zindex = 160,
    border = {
      style = { "─", "─", "─", "", "─", "─", "─", "" },
      text = {
        top = opts.title or "",
        top_align = "left",
      },
    },
    win_options = {
      cursorline = true,
    },
  }

  local lines = {}
  for _, item in ipairs(opts.items or {}) do
    table.insert(lines, NuiMenu.item(item))
  end

  local menu = NuiMenu(popup_options, {
    lines = lines,
    keymap = {
      focus_next = { "j", "<Down>", "<Tab>" },
      focus_prev = { "k", "<Up>", "<S-Tab>" },
      close = {},
      submit = {},
    },
    on_submit = function() end,
  })

  -- configure mappings
  for _, km in ipairs(opts.mappings or {}) do
    local action
    if km.action == "menu_confirm" then
      action = opts.on_confirm
    elseif km.action == "menu_yank" then
      action = opts.on_yank
    elseif km.action == "menu_close" then
      action = function() end
    end

    local map_opts = km.opts or { noremap = true, nowait = true }

    if action then
      menu:map(km.mode, km.key, function()
        local item = menu.tree:get_node()
        menu:unmount()
        if item then
          action(item.text)
        end
      end, map_opts)
    end
  end

  menu:mount()
end

-- Ask for input.
---@param opts { relative_winid: integer, default_value: string, on_confirm: fun(item: string), title: string, mappings: key_mapping[] }
function M.input(opts)
  if not opts.relative_winid or not vim.api.nvim_win_is_valid(opts.relative_winid) then
    error("no window id provided")
  end

  local width = vim.api.nvim_win_get_width(opts.relative_winid)
  local row, _ = unpack(vim.api.nvim_win_get_cursor(opts.relative_winid))

  local popup_options = {
    relative = {
      type = "win",
      winid = opts.relative_winid,
    },
    position = {
      row = row + 1,
      col = 0,
    },
    size = {
      width = width,
    },
    zindex = 160,
    border = {
      style = { "─", "─", "─", "", "─", "─", "─", "" },
      text = {
        top = opts.title or "",
        top_align = "left",
      },
    },
    win_options = {
      cursorline = false,
    },
  }

  local input = NuiInput(popup_options, {
    default_value = opts.default_value,
    on_submit = opts.on_confirm,
  })

  -- configure mappings
  for _, km in ipairs(opts.mappings or {}) do
    local action
    if km.action == "menu_confirm" then
      action = opts.on_confirm
    elseif km.action == "menu_close" then
      action = function() end
    end

    local map_opts = km.opts or { noremap = true, nowait = true }

    if action then
      input:map(km.mode, km.key, function()
        local line = vim.api.nvim_buf_get_lines(input.bufnr, 0, 1, false)[1]
        input:unmount()
        action(line)
      end, map_opts)
    end
  end

  input:mount()
end

return M



================================================
FILE: lua/dbee/ui/editor/init.lua
================================================
local utils = require("dbee.utils")
local common = require("dbee.ui.common")
local welcome = require("dbee.ui.editor.welcome")

---@alias namespace_id "global"|string

---@alias note_id string
---@alias note_details { id: note_id, name: string, file: string, bufnr: integer? }

---@class EditorUI
---@field private handler Handler
---@field private result ResultUI
---@field private winid? integer
---@field private mappings key_mapping[]
---@field private notes table<namespace_id, table<note_id, note_details>> namespace: { id: note_details } mapping
---@field private current_note_id? note_id
---@field private directory string directory where notes are stored
---@field private event_callbacks table<editor_event_name, event_listener[]> callbacks for events
---@field private window_options table<string, any> a table of window options.
---@field private buffer_options table<string, any> a table of buffer options for all notes.
local EditorUI = {}

---@param handler Handler
---@param result ResultUI
---@param opts? editor_config
---@return EditorUI
function EditorUI:new(handler, result, opts)
  opts = opts or {}

  if not handler then
    error("no Handler provided to EditorTile")
  end
  if not result then
    error("no Result provided to EditorTile")
  end

  -- class object
  ---@type EditorUI
  local o = {
    handler = handler,
    result = result,
    notes = {},
    event_callbacks = {},
    directory = opts.directory or vim.fn.stdpath("state") .. "/dbee/notes",
    mappings = opts.mappings,
    window_options = vim.tbl_extend("force", {}, opts.window_options or {}),
    buffer_options = vim.tbl_extend("force", {
      buflisted = false,
      swapfile = false,
      filetype = "sql",
    }, opts.buffer_options or {}),
  }
  setmetatable(o, self)
  self.__index = self

  -- set the current note as first note from global namespace
  local global_notes = o:namespace_get_notes("global")
  if not vim.tbl_isempty(global_notes) then
    o.current_note_id = global_notes[1].id
  else
    -- otherwise create a welcome note in global namespace
    o.current_note_id = o:create_welcome_note()
  end

  return o
end

---@private
---@return note_id
function EditorUI:create_welcome_note()
  local note_id = self:namespace_create_note("global", "welcome")
  local note = self:search_note(note_id)
  if not note then
    error("failed creating welcome note")
  end

  -- create note buffer with contents
  local bufnr = vim.api.nvim_create_buf(false, false)
  vim.api.nvim_buf_set_name(bufnr, note.file)
  vim.api.nvim_buf_set_lines(bufnr, 0, -1, true, welcome.banner())
  vim.api.nvim_buf_set_option(bufnr, "modified", false)

  self.notes["global"][note_id].bufnr = bufnr

  -- remove all text when first change happens to text
  vim.api.nvim_create_autocmd({ "InsertEnter" }, {
    once = true,
    buffer = bufnr,
    callback = function()
      vim.api.nvim_buf_set_lines(bufnr, 0, -1, true, {})
      vim.api.nvim_buf_set_option(bufnr, "modified", false)
    end,
  })

  -- configure options and mappings on new buffer
  common.configure_buffer_options(bufnr, self.buffer_options)
  common.configure_buffer_mappings(bufnr, self:get_actions(), self.mappings)

  return note_id
end

---@private
---@return table<string, fun()>
function EditorUI:get_actions()
  return {
    run_file = function()
      if not self.winid or not vim.api.nvim_win_is_valid(self.winid) then
        return
      end
      local bufnr = vim.api.nvim_win_get_buf(self.winid)
      local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
      local query = table.concat(lines, "\n")

      local conn = self.handler:get_current_connection()
      if not conn then
        return
      end
      local call = self.handler:connection_execute(conn.id, query)
      self.result:set_call(call)
    end,
    run_selection = function()
      local srow, scol, erow, ecol = utils.visual_selection()

      local selection = vim.api.nvim_buf_get_text(0, srow, scol, erow, ecol, {})
      local query = table.concat(selection, "\n")

      local conn = self.handler:get_current_connection()
      if not conn then
        return
      end
      local call = self.handler:connection_execute(conn.id, query)
      self.result:set_call(call)
    end,
    run_under_cursor = function()
      local bufnr = vim.api.nvim_get_current_buf()
      local query, srow, erow = utils.query_under_cursor(bufnr)

      if query ~= "" then
        -- highlight the statement that will be executed
        local ns_id = vim.api.nvim_create_namespace("dbee_query_highlight")
        vim.api.nvim_buf_clear_namespace(bufnr, ns_id, 0, -1)
        vim.api.nvim_buf_set_extmark(bufnr, ns_id, srow, 0, {
          end_row = erow + 1,
          end_col = 0,
          hl_group = "DiffText",
          priority = 100,
        })

        -- run the query
        local conn = self.handler:get_current_connection()
        if conn then
          self.result:set_call(self.handler:connection_execute(conn.id, query))
        end

        -- remove highlighting after delay
        vim.defer_fn(function()
          vim.api.nvim_buf_clear_namespace(bufnr, ns_id, 0, -1)
        end, 750)
      end
    end,
  }
end

---Triggers an in-built action.
---@param action string
function EditorUI:do_action(action)
  local act = self:get_actions()[action]
  if not act then
    error("unknown action: " .. action)
  end
  act()
end

---@private
---@param event editor_event_name
---@param data any
function EditorUI:trigger_event(event, data)
  local cbs = self.event_callbacks[event] or {}
  for _, cb in ipairs(cbs) do
    cb(data)
  end
end

---@param event editor_event_name
---@param listener event_listener
function EditorUI:register_event_listener(event, listener)
  self.event_callbacks[event] = self.event_callbacks[event] or {}
  table.insert(self.event_callbacks[event], listener)
end

---@private
---@param namespace string
---@return string
function EditorUI:dir(namespace)
  return self.directory .. "/" .. namespace
end

---@private
---@param id namespace_id
---@param name string name to check
---@return boolean # true - conflict, false - no conflict
function EditorUI:namespace_check_conflict(id, name)
  local notes = self.notes[id] or {}
  for _, note in pairs(notes) do
    if note.name == name then
      return true
    end
  end
  return false
end

---@param id note_id
---@return note_details?
---@return namespace_id namespace
function EditorUI:search_note(id)
  for namespace, per_namespace in pairs(self.notes) do
    for _, note in pairs(per_namespace) do
      if note.id == id then
        return note, namespace
      end
    end
  end
  return nil, ""
end

---@param bufnr integer
---@return note_details?
---@return namespace_id namespace
function EditorUI:search_note_with_buf(bufnr)
  for namespace, per_namespace in pairs(self.notes) do
    for _, note in pairs(per_namespace) do
      if note.bufnr and note.bufnr == bufnr then
        return note, namespace
      end
    end
  end
  return nil, ""
end

---@param file string
---@return note_details?
---@return namespace_id namespace
function EditorUI:search_note_with_file(file)
  for namespace, per_namespace in pairs(self.notes) do
    for _, note in pairs(per_namespace) do
      if note.file and note.file == file then
        return note, namespace
      end
    end
  end
  return nil, ""
end

-- Creates a new note in namespace.
-- Errors if id or name is nil or there is a note with the same
-- name in namespace already.
---@param id namespace_id
---@param name string
---@return note_id
function EditorUI:namespace_create_note(id, name)
  local namespace = id
  if not namespace or namespace == "" then
    error("invalid namespace id")
  end
  if not name or name == "" then
    error("no name for global note")
  end

  if not vim.endswith(name, ".sql") then
    name = name .. ".sql"
  end

  -- create namespace directory
  vim.fn.mkdir(self:dir(namespace), "p")

  if self:namespace_check_conflict(namespace, name) then
    error('note with this name already exists in "' .. namespace .. '" namespace')
  end

  local file = self:dir(namespace) .. "/" .. name
  local note_id = file .. utils.random_string()
  ---@type note_details
  local s = {
    id = note_id,
    name = name,
    file = file,
  }

  self.notes[namespace] = self.notes[namespace] or {}
  self.notes[namespace][note_id] = s

  self:trigger_event("note_created", { note = s })

  return note_id
end

---@param id namespace_id
---@return note_details[]
function EditorUI:namespace_get_notes(id)
  local namespace = id
  if not namespace or namespace == "" then
    error("invalid namespace id")
  end

  if not self.notes[namespace] then
    self.notes[namespace] = self:load_notes_from_disk(namespace)
  end
  local notes_list = vim.tbl_values(self.notes[namespace])

  table.sort(notes_list, function(k1, k2)
    return k1.name < k2.name
  end)
  return notes_list
end

-- If no notes were found, return an empty table.
---@private
---@param namespace_id namespace_id
---@return table<note_id, note_details>
function EditorUI:load_notes_from_disk(namespace_id)
  local full_dir = self.directory .. "/" .. namespace_id
  local ret = {}
  for _, file in pairs(vim.split(vim.fn.glob(full_dir .. "/*"), "\n")) do
    if vim.fn.filereadable(file) == 1 then
      local id = file .. utils.random_string()
      ret[id] = {
        id = id,
        name = vim.fs.basename(file),
        file = file,
      }
    end
  end
  return ret
end

-- Removes an existing note.
-- Errors if there is no note with provided id in namespace.
---@param id namespace_id
---@param note_id note_id
function EditorUI:namespace_remove_note(id, note_id)
  local namespace = id
  if not self.notes[namespace] then
    error("invalid namespace id to remove the note from")
  end

  local note = self.notes[namespace][note_id]
  if not note then
    error("invalid note id to remove")
  end

  -- delete file
  vim.fn.delete(note.file)

  -- delete record
  self.notes[namespace][note_id] = nil

  self:trigger_event("note_removed", { note_id = note_id })
end

-- Renames an existing note.
-- Errors if no name or id provided, there is no note with provided id or
-- there is already an existing note with the same name in the same namespace.
---@param id note_id
---@param name string new name
function EditorUI:note_rename(id, name)
  local note, namespace = self:search_note(id)
  if not note then
    error("invalid note id to rename")
  end
  if not name or name == "" then
    error("invalid name")
  end

  if not vim.endswith(name, ".sql") then
    name = name .. ".sql"
  end

  if self:namespace_check_conflict(namespace, name) then
    error('note with this name already exists in "' .. namespace .. '" namespace')
  end

  local new_file = self:dir(namespace) .. "/" .. name

  -- rename file
  if vim.fn.filereadable(note.file) == 1 then
    vim.fn.rename(note.file, new_file)
  end

  -- rename buffer
  if note.bufnr and vim.api.nvim_buf_get_name(note.bufnr) == note.file then
    vim.api.nvim_buf_set_name(note.bufnr, new_file)
  end

  -- save changes
  self.notes[namespace][id].file = new_file
  self.notes[namespace][id].name = name

  self:trigger_event("note_state_changed", { note = self.notes[namespace][id] })
end

---@return note_details?
function EditorUI:get_current_note()
  local note, _ = self:search_note(self.current_note_id)
  return note
end

-- Sets note with id as the current note
-- and opens it in the window
---@param id note_id
function EditorUI:set_current_note(id)
  if id and self.current_note_id == id then
    self:display_note(id)
    return
  end

  local note, _ = self:search_note(id)
  if not note then
    error("invalid note set as current")
  end

  self.current_note_id = id

  self:display_note(id)

  self:trigger_event("current_note_changed", { note_id = id })
end

---@private
---@param id note_id
function EditorUI:display_note(id)
  if not self.winid or not vim.api.nvim_win_is_valid(self.winid) then
    return
  end

  local note, namespace = self:search_note(id)
  if not note then
    return
  end

  -- if buffer is configured, just open it
  if note.bufnr and vim.api.nvim_buf_is_valid(note.bufnr) then
    vim.api.nvim_win_set_buf(self.winid, note.bufnr)
    vim.api.nvim_set_current_win(self.winid)
    return
  end

  -- otherwise open a file and update note's buffer
  vim.api.nvim_set_current_win(self.winid)
  vim.cmd("e " .. note.file)

  local bufnr = vim.api.nvim_get_current_buf()
  self.notes[namespace][id].bufnr = bufnr

  -- configure options and mappings on new buffer
  common.configure_buffer_options(bufnr, self.buffer_options)
  common.configure_buffer_mappings(bufnr, self:get_actions(), self.mappings)
end

---@param winid integer
function EditorUI:show(winid)
  self.winid = winid

  -- open current note
  self:display_note(self.current_note_id)

  -- configure window options (needs to be set after setting the buffer to window)
  common.configure_window_options(winid, self.window_options)
end

return EditorUI



================================================
FILE: lua/dbee/ui/editor/welcome.lua
================================================
local M = {}

function M.banner()
  return {
    "-- [ Enter insert mode to clear ]",
    "",
    "",
    "-- Welcome to",
    "-- ",
    "--  ██████████   ███████████",
    "-- ░░███░░░░███ ░░███░░░░░███",
    "--  ░███   ░░███ ░███    ░███  ██████   ██████",
    "--  ░███    ░███ ░██████████  ███░░███ ███░░███",
    "--  ░███    ░███ ░███░░░░░███░███████ ░███████",
    "--  ░███    ███  ░███    ░███░███░░░  ░███░░░",
    "--  ██████████   ███████████ ░░██████ ░░██████",
    "-- ░░░░░░░░░░   ░░░░░░░░░░░   ░░░░░░   ░░░░░░",
    "",
    "",
    '-- Type ":h dbee.txt" to learn more about the plugin.',
    "",
    '-- Report issues to: "github.com/kndndrj/nvim-dbee/issues".',
    "",
    "-- Existing users: DO NOT PANIC:",
    "-- Your notes and connections were moved from:",
    '-- "' .. vim.fn.stdpath("cache") .. '/dbee/notes" and',
    '-- "' .. vim.fn.stdpath("cache") .. '/dbee/persistence.json"',
    "-- to:",
    '-- "' .. vim.fn.stdpath("state") .. '/dbee/notes" and',
    '-- "' .. vim.fn.stdpath("state") .. '/dbee/persistence.json"',
    "-- Move them manually or adjust the config accordingly.",
    '-- see the "Breaking Changes" issue on github for more info.',
  }
end

return M



================================================
FILE: lua/dbee/ui/result/init.lua
================================================
local utils = require("dbee.utils")
local progress = require("dbee.ui.result.progress")
local common = require("dbee.ui.common")

-- ResultUI represents the part of ui with displayed results
---@class ResultUI
---@field private handler Handler
---@field private winid? integer
---@field private bufnr integer
---@field private current_call? CallDetails
---@field private page_size integer
---@field private focus_result boolean
---@field private mappings key_mapping[]
---@field private page_index integer index of the current page
---@field private page_ammount integer number of pages in the current result set
---@field private stop_progress fun() function that stops progress display
---@field private progress_opts progress_config
---@field private window_options table<string, any> a table of window options.
---@field private buffer_options table<string, any> a table of buffer options.
local ResultUI = {}

---@param handler Handler
---@param opts? result_config
---@return ResultUI
function ResultUI:new(handler, opts)
  opts = opts or {}

  if not handler then
    error("no Handler passed to ResultUI")
  end

  -- class object
  local o = {
    handler = handler,
    page_size = opts.page_size or 100,
    page_index = 0,
    page_ammount = 0,
    focus_result = opts.focus_result,
    mappings = opts.mappings or {},
    stop_progress = function() end,
    progress_opts = opts.progress or {},
    window_options = vim.tbl_extend("force", {
      wrap = false,
      winfixheight = true,
      winfixwidth = true,
      number = false,
      relativenumber = false,
      spell = false,
    }, opts.window_options or {}),
    buffer_options = vim.tbl_extend("force", {
      buflisted = false,
      bufhidden = "delete",
      buftype = "nofile",
      swapfile = false,
      modifiable = false,
      filetype = "dbee",
    }, opts.buffer_options or {}),
  }
  setmetatable(o, self)
  self.__index = self

  -- create a buffer for drawer and configure it
  o.bufnr = common.create_blank_buffer("dbee-result", o.buffer_options)
  common.configure_buffer_mappings(o.bufnr, o:get_actions(), opts.mappings)

  handler:register_event_listener("call_state_changed", function(data)
    o:on_call_state_changed(data)
  end)

  return o
end

-- event listener for new calls
---@private
---@param data { call: CallDetails }
function ResultUI:on_call_state_changed(data)
  local call = data.call

  -- we only care about the current call
  if not self.current_call or call.id ~= self.current_call.id then
    return
  end

  -- update the current call with up to date details
  self.current_call = call

  -- perform action based on the state
  if call.state == "executing" then
    self.stop_progress()
    self:display_progress()
  elseif call.state == "retrieving" then
    self.stop_progress()
    self:page_current()
  elseif call.state == "executing_failed" or call.state == "retrieving_failed" or call.state == "canceled" then
    self.stop_progress()
    self:display_status()
  else
    self.stop_progress()
  end
end

---@private
function ResultUI:apply_highlight(winid)
  -- switch to provided window, apply hightlight and jump back
  local current_win = vim.api.nvim_get_current_win()
  vim.api.nvim_set_current_win(winid)
  -- match table separators and leading row numbers
  vim.cmd([[match NonText /^\s*\d\+\|─\|│\|┼/]])
  vim.api.nvim_set_current_win(current_win)
end

---@private
---@return boolean
function ResultUI:has_window()
  if self.winid and vim.api.nvim_win_is_valid(self.winid) then
    return true
  end
  return false
end

---@private
function ResultUI:focus_result_window()
  if self.focus_result and self:has_window() then
    return vim.api.nvim_set_current_win(self.winid)
  end
end

---@private
function ResultUI:set_default_result_window()
  if self:has_window() then
    vim.api.nvim_win_set_option(self.winid, "winbar", "Results")
  end
end

---@private
function ResultUI:display_progress()
  self.stop_progress = progress.display(self.bufnr, self.progress_opts)
end

---@private
function ResultUI:display_status()
  if not self.current_call then
    error("no call set to result")
  end

  local state = self.current_call.state

  local msg = ""
  if state == "executing_failed" then
    msg = "Call execution failed"
  elseif state == "retrieving_failed" then
    msg = "Failed retrieving results"
  elseif state == "canceled" then
    msg = "Call canceled"
  end

  local seconds = self.current_call.time_taken_us / 1000000

  local lines = {
    string.format("%s after %.3f seconds", msg, seconds),
  }

  if self.current_call.error and self.current_call.error ~= "" then
    table.insert(lines, "Reason:")
    table.insert(lines, "    " .. string.gsub(self.current_call.error, "\n", " "))
  end

  vim.api.nvim_buf_set_option(self.bufnr, "modifiable", true)
  vim.api.nvim_buf_set_lines(self.bufnr, 0, -1, false, lines)

  vim.api.nvim_buf_set_option(self.bufnr, "modifiable", false)

  -- set winbar
  self:set_default_result_window()

  -- reset modified flag
  vim.api.nvim_buf_set_option(self.bufnr, "modified", false)
end

--- Displays a page of the current result in the results buffer
---@private
---@param page integer zero based page index
---@return integer # current page
function ResultUI:display_result(page)
  if not self.current_call then
    error("no call set to result")
  end
  -- calculate the ranges
  if page < 0 then
    page = 0
  end
  if page > self.page_ammount then
    page = self.page_ammount
  end
  local from = self.page_size * page
  local to = self.page_size * (page + 1)

  -- call go function
  local length = self.handler:call_display_result(self.current_call.id, self.bufnr, from, to)

  -- adjust page ammount
  self.page_ammount = math.floor(length / self.page_size)
  if length % self.page_size == 0 and self.page_ammount ~= 0 then
    self.page_ammount = self.page_ammount - 1
  end

  -- convert from microseconds to seconds
  local seconds = self.current_call.time_taken_us / 1000000

  -- set winbar status
  if self:has_window() then
    vim.api.nvim_win_set_option(
      self.winid,
      "winbar",
      string.format("%d/%d (%d)%%=Took %.3fs", page + 1, self.page_ammount + 1, length, seconds)
    )
  end
  -- set focus if window exists
  self:focus_result_window()

  -- reset modified flag
  vim.api.nvim_buf_set_option(self.bufnr, "modified", false)

  return page
end

---@private
---@return table<string, fun()>
function ResultUI:get_actions()
  return {
    page_next = function()
      self:page_next()
    end,
    page_prev = function()
      self:page_prev()
    end,
    page_last = function()
      self:page_last()
    end,
    page_first = function()
      self:page_first()
    end,

    -- yank functions
    yank_current_json = function()
      self:store_current_wrapper("json", vim.v.register)
    end,
    yank_selection_json = function()
      self:store_selection_wrapper("json", vim.v.register)
    end,
    yank_all_json = function()
      self:store_all_wrapper("json", vim.v.register)
    end,
    yank_current_csv = function()
      self:store_current_wrapper("csv", vim.v.register)
    end,
    yank_selection_csv = function()
      self:store_selection_wrapper("csv", vim.v.register)
    end,
    yank_all_csv = function()
      self:store_all_wrapper("csv", vim.v.register)
    end,

    cancel_call = function()
      if self.current_call then
        self.handler:call_cancel(self.current_call.id)
      end
    end,
  }
end

---Triggers an in-built action.
---@param action string
function ResultUI:do_action(action)
  local act = self:get_actions()[action]
  if not act then
    error("unknown action: " .. action)
  end
  act()
end

-- sets call's result to Result's buffer
---@param call CallDetails
function ResultUI:set_call(call)
  self.page_index = 0
  self.page_ammount = 0
  self.current_call = call

  self.stop_progress()
end

-- Gets the currently displayed call.
---@return CallDetails?
function ResultUI:get_call()
  return self.current_call
end

function ResultUI:page_current()
  self.page_index = self:display_result(self.page_index)
end

function ResultUI:page_next()
  self.page_index = self:display_result(self.page_index + 1)
end

function ResultUI:page_prev()
  self.page_index = self:display_result(self.page_index - 1)
end

function ResultUI:page_last()
  self.page_index = self:display_result(self.page_ammount)
end

function ResultUI:page_first()
  self.page_index = self:display_result(0)
end

-- wrapper for storing the current row
---@private
---@param format string
---@param register string
function ResultUI:store_current_wrapper(format, register)
  if not self.current_call then
    error("no call set to result")
  end
  local index = self:current_row_index()

  -- indexes in table start with 1, but in go they start with 0,
  -- to correct this, we subtract 1 from sindex and eindex.
  -- Since range select [:] in go is exclusive for the upper bound, we additionally add 1 to eindex
  index = index - 1
  if index <= 0 then
    index = 0
  end

  self.handler:call_store_result(
    self.current_call.id,
    format,
    "yank",
    { from = index, to = index + 1, extra_arg = register }
  )
end

-- wrapper for storing the current visualy selected rows
---@private
---@param format string
---@param register string
function ResultUI:store_selection_wrapper(format, register)
  if not self.current_call then
    error("no call set to result")
  end
  local sindex, eindex = self:current_row_range()

  -- see above comment
  sindex = sindex - 1
  if sindex <= 0 then
    sindex = 0
  end

  self.handler:call_store_result(
    self.current_call.id,
    format,
    "yank",
    { from = sindex, to = eindex, extra_arg = register }
  )
end

-- wrapper for storing all rows
---@private
---@param format string
---@param register string
function ResultUI:store_all_wrapper(format, register)
  if not self.current_call then
    error("no call set to result")
  end
  self.handler:call_store_result(self.current_call.id, format, "yank", { extra_arg = register })
end

---@private
---@return number # index of the current row
function ResultUI:current_row_index()
  -- get position of the current line identifier
  local row = vim.fn.search([[^\s*[0-9]\+]], "bnc", 1)
  if row == 0 then
    error("couldn't retrieve current row number: row = 0")
  end

  -- get the line and extract the line number
  local line = vim.api.nvim_buf_get_lines(self.bufnr, row - 1, row, true)[1] or ""

  local index = line:match("%d+")
  if not index then
    error("couldn't retrieve current row number")
  end
  return index
end

---@private
---@return number # number of the first row
---@return number # number of the last row
function ResultUI:current_row_range()
  if not self:has_window() then
    error("result cannot operate without a valid window")
  end
  -- get current selection
  local srow, _, erow, _ = utils.visual_selection()

  srow = srow + 1
  erow = erow + 1

  -- save cursor position
  local cursor_position = vim.fn.getcurpos(self.winid)

  -- reposition the cursor
  vim.fn.cursor(srow, 1)
  -- get position of the start line identifier
  local row = vim.fn.search([[^\s*[0-9]\+]], "bnc", 1)
  if row == 0 then
    error("couldn't retrieve start row number: row = 0")
  end

  -- get the selected line and extract the line number
  local line = vim.api.nvim_buf_get_lines(self.bufnr, row - 1, row, true)[1] or ""

  local index_start = line:match("%d+")
  if not index_start then
    error("couldn't retrieve start row number")
  end

  -- reposition the cursor
  vim.fn.cursor(erow, 1)
  -- get position of the end line identifier
  row = vim.fn.search([[^\s*[0-9]\+]], "bnc", 1)
  if row == 0 then
    error("couldn't retrieve end row number: row = 0")
  end
  -- get the selected line and extract the line number
  line = vim.api.nvim_buf_get_lines(self.bufnr, row - 1, row, true)[1] or ""

  local index_end = tonumber(line:match("%d+"))
  if not index_end then
    error("couldn't retrieve end row number")
  end

  -- restore cursor position
  vim.fn.setpos(".", cursor_position)

  return index_start, index_end
end

---@param winid integer
function ResultUI:show(winid)
  self.winid = winid

  -- configure window highlights
  self:apply_highlight(self.winid)

  vim.api.nvim_win_set_buf(self.winid, self.bufnr)

  common.configure_buffer_options(self.bufnr, self.buffer_options)
  common.configure_buffer_mappings(self.bufnr, self:get_actions(), self.mappings)

  -- configure window options (needs to be set after setting the buffer to window)
  common.configure_window_options(self.winid, self.window_options)

  -- display the current result
  local ok = pcall(self.page_current, self)
  if not ok then
    self:set_default_result_window()
  end
end

return ResultUI



================================================
FILE: lua/dbee/ui/result/progress.lua
================================================
local M = {}

---@alias progress_config { text_prefix: string, spinner: string[] }

--- Display an updated progress loader in the specified buffer
---@param bufnr integer -- buffer to display the progres in
---@param opts? progress_config
---@return fun() # cancel function
function M.display(bufnr, opts)
  if not bufnr then
    return function() end
  end
  opts = opts or {}
  local text_prefix = opts.text_prefix or "Loading..."
  local spinner = opts.spinner or { "|", "/", "-", "\\" }

  local icon_index = 1
  local start_time = vim.fn.reltimefloat(vim.fn.reltime())

  local function update()
    local passed_time = vim.fn.reltimefloat(vim.fn.reltime()) - start_time
    icon_index = (icon_index % #spinner) + 1

    vim.api.nvim_buf_set_option(bufnr, "modifiable", true)
    local line = string.format("%s %.3f seconds %s ", text_prefix, passed_time, spinner[icon_index])
    vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, { line })
    vim.api.nvim_buf_set_option(bufnr, "modifiable", false)
  end

  local timer = vim.fn.timer_start(100, update, { ["repeat"] = -1 })
  return function()
    pcall(vim.fn.timer_stop, timer)
  end
end

return M



================================================
FILE: plugin/dbee.lua
================================================
if vim.g.loaded_dbee == 1 then
  return
end
vim.g.loaded_dbee = 1

local COMMAND_NAME = "Dbee"

local commands = {
  open = require("dbee").open,
  close = require("dbee").close,
  toggle = require("dbee").toggle,
  execute = function(args)
    require("dbee").execute(table.concat(args, " "))
  end,
  store = function(args)
    -- args are "format", "output" and "extra_arg"
    if #args < 3 then
      error("not enough arguments, got " .. #args .. " want 3")
    end

    require("dbee").store(args[1], args[2], { extra_arg = args[3] })
  end,
}

---@param args string args in form of Dbee arg1 arg2 ...
---@return string[]
local function split_args(args)
  local stripped = args:gsub(COMMAND_NAME, "")

  local ret = {}
  for word in string.gmatch(stripped, "([^ |\t]+)") do
    table.insert(ret, word)
  end

  return ret
end

---@param input integer[]
---@return string[]
local function tostringlist(input)
  local ret = {}
  for _, elem in ipairs(input) do
    table.insert(ret, tostring(elem))
  end
  return ret
end

-- Create user command for dbee
vim.api.nvim_create_user_command(COMMAND_NAME, function(opts)
  local args = split_args(opts.args)
  if #args < 1 then
    -- default is toggle
    require("dbee").toggle()
    return
  end

  local cmd = args[1]
  table.remove(args, 1)

  local fn = commands[cmd]
  if fn then
    fn(args)
    return
  end

  error("unsupported subcommand: " .. (cmd or ""))
end, {
  nargs = "*",
  complete = function(_, cmdline, _)
    local line = split_args(cmdline)
    if #line < 1 then
      return vim.tbl_keys(commands)
    end

    if line[1] ~= "store" then
      return {}
    end

    local nargs = #line
    if nargs == 1 then
      -- format
      return { "csv", "json", "table" }
    elseif nargs == 2 then
      -- output
      return { "file", "yank", "buffer" }
    elseif nargs == 3 then
      -- extra_arg
      if line[3] == "buffer" then
        return tostringlist(vim.api.nvim_list_bufs())
      end

      return
    end

    return vim.tbl_keys(commands)
  end,
})



================================================
FILE: .github/workflows/compile.yml
================================================
name: Compile and Upload Binaries

on:
  release:
    types: [published]
  workflow_dispatch: # manual trigger for full matrix
  pull_request:
    branches: [master]
  push:
    branches: [master]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs:
  assemble-os-matrix:
    runs-on: ubuntu-22.04
    name: Assemble Matrix
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - name: Create Matrix
        id: set-matrix
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            ./ci/target-matrix.sh --primary >> "$GITHUB_OUTPUT"
          else
            ./ci/target-matrix.sh >> "$GITHUB_OUTPUT"
          fi

  go-build:
    needs: [assemble-os-matrix]
    name: Go Build
    strategy:
      matrix: ${{ fromJson(needs.assemble-os-matrix.outputs.matrix) }}
    runs-on: ${{ matrix.buildplatform }}
    steps:
      - uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23.x"
          check-latest: true
          cache-dependency-path: dbee/go.sum
      - name: Setup Zig for C Cross Compilation
        uses: goto-bus-stop/setup-zig@v2
      - name: Build
        id: build
        working-directory: dbee
        shell: bash
        env:
          CGO_ENABLED: ${{ matrix.cgo }}
        run: |
          bin="dbee"
          [ '${{ matrix.goos }}' = "windows" ] && bin="dbee.exe"
          artefact="dbee_${{ matrix.goos }}_${{ matrix.goarch }}.tar.gz"
          echo "artefact=$artefact" >> "$GITHUB_OUTPUT"

          ../ci/build.sh \
            -o "${{ matrix.goos }}" \
            -a "${{ matrix.goarch }}" \
            -c "${{ matrix.crossarch }}" \
            -b "${{ matrix.buildtags }}" \
            -e "${{ matrix.cgo }}" \
            -p "../ci_tmp/bin/$bin"

          tar -C "../ci_tmp/bin" -czvf "../ci_tmp/bin/$artefact" "$bin"
      - name: Upload artefacts to release
        if: github.event_name == 'release'
        uses: svenstaro/upload-release-action@v2
        with:
          file: ci_tmp/bin/${{ steps.build.outputs.artefact }}
          tag: ${{ github.ref }}
      - name: Create metadata
        if: github.event_name == 'release'
        shell: bash
        run: |
          mkdir ci_tmp/meta
          echo "${{ github.server_url }}/${{ github.repository }}/releases/download/${{ github.ref_name }}/${{ steps.build.outputs.artefact }}" > ci_tmp/meta/url
          echo "${{ matrix.goos }}" > ci_tmp/meta/os
          echo "${{ matrix.goarch }}" > ci_tmp/meta/arch
      - name: Upload metadata
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.goos }}_${{ matrix.goarch }}
          path: ci_tmp/meta/*

  create-install-manifest:
    runs-on: ubuntu-22.04
    if: github.event_name == 'release'
    name: Create Install Manifest
    needs: [go-build]
    env:
      MANIFEST_FILE: "lua/dbee/install/__manifest.lua"
    steps:
      - uses: actions/checkout@v4
      - name: Get metadata
        uses: actions/download-artifact@v4
        with:
          path: meta
      - name: Create Install File from metadata
        run: |
          {
            echo "-- This file is automatically generated using CI pipeline"
            echo "-- DO NOT EDIT!"
            echo "local M = {}"
            echo
            echo "-- Links to binary releases"
            echo "M.urls = {"
            for art in meta/*; do
              os="$(cat "$art/os")"
              arch="$(cat "$art/arch")"
              url="$(cat "$art/url")"
              echo "  [\"$os/$arch\"] = \"$url\","
            done
            echo "}"
            echo
            echo "-- Git sha of compiled binaries"
            echo "M.version = \"${{ github.sha }}\""
            echo
            echo "return M"
          } > "$MANIFEST_FILE"
      - name: Commit Generated Manifest
        shell: bash
        run: |
          echo "fetching"
          git fetch

          branch=$(basename "$(git branch -r --contains="${{ github.ref }}" | head -n1 | cut -c3-)")

          echo "checking out"
          git pull origin "$branch" --rebase --autostash
          git checkout "$branch"

          echo "committing"
          git add "${{ env.MANIFEST_FILE }}"
          git config user.name "Github Actions"
          git config user.email "actions@github.com"
          git commit -m "[install] update install manifest"

          echo "pushing"
          git push -u origin "$branch"

          echo "moving tag"
          git tag -f "${{ github.ref_name }}"
          git push origin -f --tags



================================================
FILE: .github/workflows/docgen.yml
================================================
name: Documentation Generation

on:
  pull_request:
    branches: [master]
  push:
    branches: [master]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs:
  readme-docs:
    runs-on: ubuntu-22.04
    name: Generate Docs from Readme
    env:
      TEMP_README: "__temp_readme.md"
    steps:
      - uses: actions/checkout@v4
      - name: Prepare markdown file
        run: |
          TEMP_CONFIG="$(mktemp)"
          # Retrieve default config and put it in a temp file.
          {
            echo '```lua'
            awk '/DOCGEN_END/{f=0} f; /DOCGEN_START/{f=1}' lua/dbee/config.lua
            echo '```'
          } > "$TEMP_CONFIG"
          # Insert the default config between DOCGEN_CONFIG tags in the README.
          # And remove stuff between DOCGEN_IGNORE_START and DOCGEN_IGNORE_END tags from README.
          {
            sed -e '
              /DOCGEN_CONFIG_START/,/DOCGEN_CONFIG_END/!b
              /DOCGEN_CONFIG_START/r '"$TEMP_CONFIG"'
              /DOCGEN_CONFIG_END:/!d
            ' <(sed '/DOCGEN_IGNORE_START/,/DOCGEN_IGNORE_END/d' README.md)
            cat ARCHITECTURE.md
          } > "$TEMP_README"
      - name: Generate vimdoc
        uses: kdheepak/panvimdoc@v3.0.6
        with:
          vimdoc: dbee
          pandoc: "${{ env.TEMP_README }}"
          toc: true
          description: "Database Client for NeoVim"
          treesitter: true
          ignorerawblocks: true
          docmappingprojectname: false
      - name: Commit the Generated Help
        uses: EndBug/add-and-commit@v9
        if: github.event_name == 'push'
        with:
          add: doc/dbee.txt
          author_name: Github Actions
          author_email: actions@github.com
          message: "[docgen] Update doc/dbee.txt"
          pull: --rebase --autostash

  reference-docs:
    name: Generate Reference Docs
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - name: Generating help
        shell: bash
        run: |
          curl -Lq https://github.com/numToStr/lemmy-help/releases/latest/download/lemmy-help-x86_64-unknown-linux-gnu.tar.gz | tar xz
          ./lemmy-help lua/dbee.lua lua/dbee/{config,doc,sources,layouts/init,api/core,api/ui}.lua --expand-opt > doc/dbee-reference.txt
      - name: Commit the Generated Docs
        uses: EndBug/add-and-commit@v9
        if: github.event_name == 'push'
        with:
          add: doc/dbee-reference.txt
          author_name: Github Actions
          author_email: actions@github.com
          message: "[docgen] Update doc/dbee-reference.txt"
          pull: --rebase --autostash



================================================
FILE: .github/workflows/lint.yml
================================================
name: Linting and Style Checking

on:
  pull_request:
    branches: [master]
  push:
    branches: [master]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs:
  luacheck:
    runs-on: ubuntu-22.04
    name: Lint Lua Code
    steps:
      - uses: actions/checkout@v4
      - name: Luacheck Linter
        uses: lunarmodules/luacheck@v0
        with:
          args: lua/

  stylua:
    runs-on: ubuntu-22.04
    name: Check Lua Style
    steps:
      - uses: actions/checkout@v4
      - name: Lua Style Check
        uses: JohnnyMorganz/stylua-action@v4
        with:
          version: v0.17
          token: ${{ secrets.GITHUB_TOKEN }}
          args: --color always --check lua/

  markdown-format:
    runs-on: ubuntu-22.04
    name: Check Markdown Format
    steps:
      - uses: actions/checkout@v4
      - name: Python Setup
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"
      - name: Install mdformat
        run: |
          pip install mdformat-gfm
      - name: Markdown Style Check
        run: |
          mdformat --number --wrap 100 --check README.md ARCHITECTURE.md



================================================
FILE: .github/workflows/test.yml
================================================
name: Testing

on:
  pull_request:
  push:
    branches: [master]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

defaults:
  run:
    working-directory: dbee

env:
  GO_VERSION: "1.23.x"

jobs:
  go-unit-test:
    runs-on: ubuntu-22.04
    name: Go Unit Test
    steps:
      - uses: actions/checkout@v4
      - name: Setup Go v${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: v${{ env.GO_VERSION }}
          check-latest: true
          cache-dependency-path: ./dbee/go.sum
      # exclude tests folder (not used for unit tests)
      - name: Run Unit Tests
        run: go test $(go list ./... | grep -v tests) -v

  bootstrap-testcontainers:
    runs-on: ubuntu-22.04
    name: Bootstrap Testcontainers
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - id: generate-matrix
        run: |
          # create a JSON object with the adapter names to bootstrap matrix with.
          matrix=$(find tests/integration -name '*_integration_test.go' -exec basename {} \; \
            | sed 's/_integration_test.go//' \
            | jq -scR 'split("\n") | map(select(length > 0)) | {adapter: .}')
          echo "matrix=$matrix" | tee $GITHUB_OUTPUT

  go-integration-test:
    needs: bootstrap-testcontainers
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    env:
      TESTCONTAINERS_RYUK_DISABLED: true
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.bootstrap-testcontainers.outputs.matrix) }}
    name: Go Integration Test (${{ matrix.adapter }})
    steps:
      - uses: actions/checkout@v4
      - name: Setup Go v${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          check-latest: true
          cache-dependency-path: ./dbee/go.sum
      - name: Run Integration Tests
        run: sudo go test ./tests/integration/${{ matrix.adapter }}_integration_test.go -v


